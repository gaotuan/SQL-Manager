{"version":3,"sources":["webpack:///static/js/29.4dc8604e60c093c3cae0.js","webpack:///./~/emmet/emmet.js"],"names":["webpackJsonp","187","module","exports","__webpack_require__","_","eq","a","b","stack","_chain","_wrapped","isEqual","isFunction","className","toString","call","String","source","global","multiline","ignoreCase","length","push","size","result","constructor","key","has","pop","root","this","previousUnderscore","breaker","ArrayProto","Array","prototype","ObjProto","Object","FuncProto","Function","slice","unshift","hasOwnProperty","nativeForEach","forEach","nativeMap","map","nativeReduce","reduce","nativeReduceRight","reduceRight","nativeFilter","filter","nativeEvery","every","nativeSome","some","nativeIndexOf","indexOf","nativeLastIndexOf","lastIndexOf","nativeIsArray","isArray","nativeKeys","keys","nativeBind","bind","obj","wrapper","VERSION","each","iterator","context","i","l","collect","results","value","index","list","foldl","inject","memo","initial","arguments","TypeError","foldr","reversed","toArray","reverse","find","detect","any","select","reject","all","identity","include","contains","target","found","invoke","method","args","apply","pluck","max","Math","isEmpty","Infinity","computed","min","shuffle","rand","shuffled","floor","random","sortBy","val","criteria","sort","left","right","groupBy","sortedIndex","array","low","high","mid","isArguments","values","first","head","take","n","guard","last","rest","tail","compact","flatten","shallow","concat","without","difference","uniq","unique","isSorted","union","intersection","intersect","item","other","zip","range","start","stop","step","len","ceil","idx","ctor","func","bound","self","bindAll","funcs","functions","f","memoize","hasher","delay","wait","setTimeout","defer","throttle","timeout","throttling","more","whenDone","debounce","later","immediate","clearTimeout","once","ran","wrap","compose","after","times","methods","names","extend","prop","pick","defaults","clone","isObject","tap","interceptor","isString","isElement","nodeType","isNumber","isFinite","isNaN","isBoolean","isDate","isRegExp","isNull","isUndefined","noConflict","escape","string","replace","object","property","mixin","name","addToWrapper","idCounter","uniqueId","prefix","id","templateSettings","evaluate","interpolate","noMatch","escapes","p","escaper","unescaper","unescape","code","match","template","text","data","settings","variable","render","chain","wrapped","emmet","inherits","parent","protoProps","staticProps","child","__super__","r","modules","moduleLoader","e","define","factory","exec","require","fn","classProps","expandAbbreviation","abbr","syntax","profile","contextNode","filters","parser","get","resetTabstopIndex","extractFromAbbreviation","outputTree","parse","filtersList","composeList","defaultSyntax","defaultProfile","log","console","setModuleLoader","AbbreviationNode","children","_attributes","abbreviation","counter","_name","_text","repeatCount","hasImplicitRepeat","_data","end","content","padding","stripped","str","substring","consumeQuotedValue","stream","quote","ch","next","parseAbbreviation","trim","multiplier","addChild","create","loopProtector","eol","peek","pos","skipToPair","inner","current","_setRepeat","eatWhile","c","pairs","backUp","isMarker","isAllowedChar","setAbbreviation","extractAttributes","attrSet","attrs","eatSpace","reWord","attrName","attrValue","parseAttributes","attrMap","nameEnd","element","attributes","optimizeAttributes","attr","lookup","la","toLowerCase","extractText","unroll","node","j","maxCount","isRepeating","updateProperty","squash","isGroup","remove","charCode","charCodeAt","reValidName","spliceFn","splice","preprocessors","postprocessors","outputProcessors","position","ix","items","findAll","elemName","is","insertChildContent","res","matchedResource","attributeList","attribute","count","parseInt","that","abbrText","abbrAttrs","test","utils","innerContent","join","keepVariable","padString","hasEmptyChildren","hasImplicitName","isTextNode","deepestChild","replaceCounter","options","tree","attrLookup","addPreprocessor","removeFilter","preprocessor","addPostprocessor","removePostprocessor","addOutputProcessor","removeOutputProcessor","matchResources","resources","elements","getMatchedResource","subtree","repeatedChildren","locateOutputPlaceholder","outputPlaceholder","replaceOutputPlaceholders","ranges","replaceSubstring","hasOutputPlaceholder","insertPastedContent","overwrite","nodesWithPlaceholders","deepest","pastedContent","lines","splitByLines","pastedContentObj","resolveNodeNames","tagName","resolve","isset","v","getConf","walker","chnum","line","linenum","tokener","type","conf","w","tokens","charstart","charend","linestart","lineend","error","m","config","message","white","token","nextChar","comment","cnext","pk","q","brace","depth","identifier","pre","isNameChar","isDigit","num","nondigit","point","op","isOp","tokenize","getNewline","charAt","total_lines","init","me","split","nextLine","opsa","opsmatcha","ops","opsmatch","matchattr","lex","toSource","toks","t","src","inText","state","eat","inBlock","doctype","inTag","ok","inAttribute","style","terminator","pass","curState","cc","cont","pushContext","startOfLine","noIndent","Kludges","doNotIndent","prev","indent","indented","popContext","endtag","err","implicitlyClosed","setStyle","endclosetag","autoSelfClosers","maybePopContext","callee","nextTagName","parentTagName","contextGrabbers","attvalue","allowMissing","attvaluemaybe","allowUnquoted","startState","sol","comb","offset","score","fuzziness","start_of_string_bonus","abbreviation_score","final_score","character_score","index_in_string","index_c_lowercase","index_c_uppercase","min_index","total_character_score","abbreviation_length","string_length","fuzzies","toUpperCase","StringBuilder","append","caretPlaceholder","valueOf","reTag","endsWithTag","isNumeric","nl","getVariable","setNewline","setVariable","removeEmpty","normalizeNewline","repeatString","howMany","getStringsPads","strings","lengths","s","pad","padStr","zeroPadString","il","unindentString","search","substr","replaceUnescapedSymbol","symbol","sl","matchCount","curSl","newValue","replaceData","replaceVariables","vars","resolver","p1","processText","total","matchNum","base","decrement","matchesTag","escapeText","unescapeText","getCaretPlaceholder","setCaretPlaceholder","getLinePadding","getLinePaddingFromPosition","lineRange","findNewlineBounds","escapeForRegexp","specials","RegExp","prettifyNumber","fraction","toFixed","stringBuilder","narrowToNonSpace","reSpace","from","deepMerge","copy","copyIsArray","undefined","cmp","Range","abs","equal","shift","delta","overlap","inside","loc","create2","HandlerList","_list","add","order","listFn","skipValue","h","TokenIterator","_position","reset","hasNext","_i","_il","itemNext","itemPrev","nextUntil","callback","StringStream","skipToEnd","skipTo","open","close","braceCount","pattern","consume","caseInsensitive","cased","normalizeCaretPlaceholder","parseItem","normalizeName","cache","systemSettings","userSettings","resolvers","setVocabulary","getVocabulary","findSnippet","getSection","voc","variables","hasSyntax","addResolver","removeResolver","subsections","findItem","topSection","subsection","matchedItem","sectionName","fuzzyFindSnippet","minScore","payload","getAllSnippets","sc","scores","nk","parsedValue","cacheKey","sectionKey","section","stackItem","k","zc","humanizeActionName","actions","label","run","action","getAll","getList","getMenu","skipActions","hidden","actionName","ctx","parts","menuName","submenu","getActionNameForMenuTitle","title","menu","OutputProfile","stringCase","caseValue","createProfile","profiles","createDefaultProfiles","self_closing_tag","tag_nl","place_cursor","extraFilters","tag_case","attr_case","attr_quotes","tag_nl_leaf","inline_break","attributeName","attributeQuote","selfClosing","param","cursor","plain","isInsideTag","html","caretPos","outputInfo","editor","getProfileName","getSyntax","getContent","unindent","getCurrentLinePadding","getCurrentLine","mimeTypes","extractAbbreviation","curOffset","startIndex","groupCount","textCount","getImageSize","nextByte","width","height","marker","captureContext","allowedSyntaxes","tag","getCaretPos","startTag","tagTree","findExpressionBounds","exprStart","exprEnd","compoundUpdate","sel","getSelectionRange","replaceContent","createSelection","caret","detectSyntax","hint","isStyle","isInlineCSS","detectProfile","isXHTML","innerRange","parseFromPosition","itemFromPosition","valueRange","isSnippet","isUnary","is_empty","isInline","isInlineLevel","isBlock","hasTagsInContent","hasBlockChildren","childContent","appendIfNoChild","childVariableReplaced","output","chars","encode","input","chr1","chr2","chr3","enc1","enc2","enc3","enc4","cdp1","cdp2","cdp3","b64","decode","o1","o2","o3","h1","h2","h3","h4","bits","ac","tmpArr","fromCharCode","openTag","selfClose","closeTag","createMatcher","matches","reOpenTag","reCloseTag","findClosingPair","matcher","jl","outerRange","_c","outerContent","startPlaceholderNum","tabstopIndex","defaultOptions","replaceCarets","tabstop","maxNum","tabstops","tsOptions","group","placeholder","variablesResolver","extract","placeholders","carets","marks","ret","buf","lastIx","tabStops","mark","ph","upgrade","placeholderMemo","varName","varValue","toBoolean","isValueObj","preferences","_dbgDefaults","_dbgPreferences","description","prefs","set","getArray","getDict","load","json","exportModified","_startTest","_stopTest","registeredFilters","additionalFilters","commonFactory","factories","reAttrs","elem","elementName","core","EditContainer","_children","_positions","initialize","EditElement","nameToken","valueToken","_value","_updateSource","update","indexes","fullRange","nameRange","isAbsolute","_pos","namePosition","valuePosition","createToken","trimWhitespaceTokens","mask","WHITESPACE_REMOVE_FROM_START","WHITESPACE_REMOVE_FROM_END","whitespace","findSelectorRange","it","findValueRange","skipTokens","tok","findParts","sep","isValidIdentifier","styleBefore","styleSeparator","CSSEditContainer","editTree","selectorRange","contentStart","propertyRange","CSSEditElement","_saveStyle","styles","donor","rule","_end","valueParts","isBackward","bounds","extractRule","stopChars","bracePos","selector","baseName","styleQuote","XMLEditContainer","attrToken","XMLEditElement","extractTag","maxLen","handlers","info","getSelection","selRange","replaceRange","findAbbreviation","addHandler","removeHandler","curLine","getCurrentLineRange","editorUtils","prompt","newContent","parsedTree","toggleHTMLComment","genericCommentToggle","toggleCSSComment","cssItemFromPosition","absPos","relPos","reSafeChar","searchComment","startToken","endToken","commentStart","commentEnd","hasMatch","contentLen","commentRange","setCaretPos","findNewEditPoint","inc","curPoint","nextPoint","reEmptyLine","curChar","prevChar","curPos","newPoint","extractFn","rangeFn","itemRange","rng","contentLength","prevRange","searchPos","loop","findNextHTMLItem","isFirst","findOpeningTagFromPosition","getOpeningTagFromPosition","getRangeForHTMLItem","findPrevHTMLItem","makePossibleRangesHTML","attrValueRange","attrStart","isQuote","classNameRanges","curRange","matchedRanges","makePossibleRangesCSS","stringStream","cssEditTree","fnBody","part","matchedRangeForCSSProperty","possibleRanges","searchFn","nearestItemFn","findNextCSSItem","getRangeForNextItemInCSS","findPrevCSSItem","getRangeForPrevItemInCSS","matchPair","direction","lastMatch","narrowed","tagContentRange","startLineBounds","startLinePad","tagContent","joinTag","slash","splitTag","profileName","doCSSReflection","cssRule","oldRule","caretDelta","getReflectedCSSName","vendorPrefix","reflectValue","receiver","getReflectedValue","curName","curValue","refName","refValue","parseFloat","reName","actionUtils","expr","incrementNumber","hasSign","hasDecimal","strNum","minus","$1","intLength","hasCloseBrace","insValue","curPadding","nextPadding","selection","pair","textLen","startsWith","encodeToBase64","imgPath","file","editorFile","getFilePath","realImgPath","locateFile","read","getExt","decodeFromBase64","filePath","absPath","createPath","save","updateImageSizeHTML","xmlElem","getImageSizeForSource","compoundData","updateImageSizeCSS","fileContent","au","isSingleProperty","snippet","normalizeValue","normalizeHexColor","getKeyword","hex","repeat","color","aliases","getUnit","isValidKeyword","keyword","hasPrefix","vendorPrefixes","supports","findPrefixes","noAutofill","obsolete","addPrefix","prefixObj","getSyntaxPreference","formatProperty","transformSnippet","isImportant","getProperties","transformName","properties","descTemplate","descAddonTemplate","props","vendor","cssSyntaxes","expandToSnippet","ea","replaceFrom","replaceTo","supportsPrefix","prefixed","listPrefixes","getPrefix","removePrefix","extractPrefixes","prefixes","findValuesInAbbreviation","keywords","lastPart","parseValues","extractValues","abbrValues","unitlessProps","unit","expand","autoInsertPrefixes","prefixData","valuesData","abbrData","snippetObj","splitSnippet","propName","pads","normalizeSpace","parseLinearGradient","gradient","defaultLinearDirections","colorStops","reDeg","reKeyword","parseColorStop","colorStop","resolvePropertyName","fillImpliedPositions","cs","cs2","textualDirection","angle","oldWebkitDirection","getPrefixedNames","getPropertiesForGradient","propertyName","css","oldWebkitLinearGradient","pasteGradient","alignVendor","before","propsToInsert","valuePads","namePads","findGradient","cssProp","matchedPart","expandGradientOutsideValue","findGradientFromPosition","g","ruleStart","ruleEnd","insertPos","newCss","resolvedName","definition","generators","addGenerator","regexp","elementTypes","empty","blockLevel","inlineLevel","elementMap","getMapping","isTypeOf","isBlockLevel","isEmptyElement","addMapping","removeMapping","addElementToCollection","collection","col","getCollection","removeElementFromCollection","getSeparators","modifier","bemParse","__bem","block","classNames","normalizeClassName","reBlockName","processClassName","shortSymbol","re","transformClassName","separators","blockElem","elemModifiers","blockModifiers","entityType","reSep","cleanName","process","abbrUtils","shouldRunHtmlFilter","addComments","templateBefore","templateAfter","trigger","nodeBefore","nodeAfter","escapeChars","charMap","getIndentation","hasBlockSibling","isVeryFirstChild","shouldAddLineBreak","shouldFormatInline","shouldBreakChild","nodeCount","isRoot","processSnippet","level","shouldBreakInsideInline","processTag","forceNl","makeAttributesString","otherAttrs","attrQuote","rePad","reNl","trimAttribute","tags","randint","to","round","sample","arr","iterations","randIx","choice","sentence","words","insertCommas","totalCommas","paragraph","lang","wordCount","startWithCommon","langs","totalWords","common","en","ru","wordCound","addLang","snippets","userData"],"mappings":"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","file":"static/js/29.4dc8604e60c093c3cae0.js","sourcesContent":["webpackJsonp([29],{\n\n/***/ 187:\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(process) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;//     Underscore.js 1.3.3\n//     (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.\n//     Underscore is freely distributable under the MIT license.\n//     Portions of Underscore are inspired or borrowed from Prototype,\n//     Oliver Steele's Functional, and John Resig's Micro-Templating.\n//     For all details and documentation:\n//     http://documentcloud.github.com/underscore\n\nvar _ = (function() {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` in the browser, or `global` on the server.\n  var root = this;\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Establish the object that gets returned to break out of a loop iteration.\n  var breaker = {};\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var slice            = ArrayProto.slice,\n      unshift          = ArrayProto.unshift,\n      toString         = ObjProto.toString,\n      hasOwnProperty   = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var\n    nativeForEach      = ArrayProto.forEach,\n    nativeMap          = ArrayProto.map,\n    nativeReduce       = ArrayProto.reduce,\n    nativeReduceRight  = ArrayProto.reduceRight,\n    nativeFilter       = ArrayProto.filter,\n    nativeEvery        = ArrayProto.every,\n    nativeSome         = ArrayProto.some,\n    nativeIndexOf      = ArrayProto.indexOf,\n    nativeLastIndexOf  = ArrayProto.lastIndexOf,\n    nativeIsArray      = Array.isArray,\n    nativeKeys         = Object.keys,\n    nativeBind         = FuncProto.bind;\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) { return new wrapper(obj); };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for the old `require()` API. If we're in\n  // the browser, add `_` as a global object via a string identifier,\n  // for Closure Compiler \"advanced\" mode.\n  if (true) {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root['_'] = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.3.3';\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles objects with the built-in `forEach`, arrays, and raw objects.\n  // Delegates to **ECMAScript 5**'s native `forEach` if available.\n  var each = _.each = _.forEach = function(obj, iterator, context) {\n    if (obj == null) return;\n    if (nativeForEach && obj.forEach === nativeForEach) {\n      obj.forEach(iterator, context);\n    } else if (obj.length === +obj.length) {\n      for (var i = 0, l = obj.length; i < l; i++) {\n        if (i in obj && iterator.call(context, obj[i], i, obj) === breaker) return;\n      }\n    } else {\n      for (var key in obj) {\n        if (_.has(obj, key)) {\n          if (iterator.call(context, obj[key], key, obj) === breaker) return;\n        }\n      }\n    }\n  };\n\n  // Return the results of applying the iterator to each element.\n  // Delegates to **ECMAScript 5**'s native `map` if available.\n  _.map = _.collect = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);\n    each(obj, function(value, index, list) {\n      results[results.length] = iterator.call(context, value, index, list);\n    });\n    if (obj.length === +obj.length) results.length = obj.length;\n    return results;\n  };\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.\n  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduce && obj.reduce === nativeReduce) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);\n    }\n    each(obj, function(value, index, list) {\n      if (!initial) {\n        memo = value;\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, value, index, list);\n      }\n    });\n    if (!initial) throw new TypeError('Reduce of empty array with no initial value');\n    return memo;\n  };\n\n  // The right-associative version of reduce, also known as `foldr`.\n  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.\n  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);\n    }\n    var reversed = _.toArray(obj).reverse();\n    if (context && !initial) iterator = _.bind(iterator, context);\n    return initial ? _.reduce(reversed, iterator, memo, context) : _.reduce(reversed, iterator);\n  };\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, iterator, context) {\n    var result;\n    any(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) {\n        result = value;\n        return true;\n      }\n    });\n    return result;\n  };\n\n  // Return all the elements that pass a truth test.\n  // Delegates to **ECMAScript 5**'s native `filter` if available.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);\n    each(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) results[results.length] = value;\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    each(obj, function(value, index, list) {\n      if (!iterator.call(context, value, index, list)) results[results.length] = value;\n    });\n    return results;\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Delegates to **ECMAScript 5**'s native `every` if available.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, iterator, context) {\n    var result = true;\n    if (obj == null) return result;\n    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);\n    each(obj, function(value, index, list) {\n      if (!(result = result && iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Delegates to **ECMAScript 5**'s native `some` if available.\n  // Aliased as `any`.\n  var any = _.some = _.any = function(obj, iterator, context) {\n    iterator || (iterator = _.identity);\n    var result = false;\n    if (obj == null) return result;\n    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);\n    each(obj, function(value, index, list) {\n      if (result || (result = iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if a given value is included in the array or object using `===`.\n  // Aliased as `contains`.\n  _.include = _.contains = function(obj, target) {\n    var found = false;\n    if (obj == null) return found;\n    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;\n    found = any(obj, function(value) {\n      return value === target;\n    });\n    return found;\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = function(obj, method) {\n    var args = slice.call(arguments, 2);\n    return _.map(obj, function(value) {\n      return (_.isFunction(method) ? method || value : value[method]).apply(value, args);\n    });\n  };\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, function(value){ return value[key]; });\n  };\n\n  // Return the maximum element or (element-based computation).\n  _.max = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0]) return Math.max.apply(Math, obj);\n    if (!iterator && _.isEmpty(obj)) return -Infinity;\n    var result = {computed : -Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed >= result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0]) return Math.min.apply(Math, obj);\n    if (!iterator && _.isEmpty(obj)) return Infinity;\n    var result = {computed : Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed < result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Shuffle an array.\n  _.shuffle = function(obj) {\n    var shuffled = [], rand;\n    each(obj, function(value, index, list) {\n      rand = Math.floor(Math.random() * (index + 1));\n      shuffled[index] = shuffled[rand];\n      shuffled[rand] = value;\n    });\n    return shuffled;\n  };\n\n  // Sort the object's values by a criterion produced by an iterator.\n  _.sortBy = function(obj, val, context) {\n    var iterator = _.isFunction(val) ? val : function(obj) { return obj[val]; };\n    return _.pluck(_.map(obj, function(value, index, list) {\n      return {\n        value : value,\n        criteria : iterator.call(context, value, index, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria, b = right.criteria;\n      if (a === void 0) return 1;\n      if (b === void 0) return -1;\n      return a < b ? -1 : a > b ? 1 : 0;\n    }), 'value');\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = function(obj, val) {\n    var result = {};\n    var iterator = _.isFunction(val) ? val : function(obj) { return obj[val]; };\n    each(obj, function(value, index) {\n      var key = iterator(value, index);\n      (result[key] || (result[key] = [])).push(value);\n    });\n    return result;\n  };\n\n  // Use a comparator function to figure out at what index an object should\n  // be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iterator) {\n    iterator || (iterator = _.identity);\n    var low = 0, high = array.length;\n    while (low < high) {\n      var mid = (low + high) >> 1;\n      iterator(array[mid]) < iterator(obj) ? low = mid + 1 : high = mid;\n    }\n    return low;\n  };\n\n  // Safely convert anything iterable into a real, live array.\n  _.toArray = function(obj) {\n    if (!obj)                                     return [];\n    if (_.isArray(obj))                           return slice.call(obj);\n    if (_.isArguments(obj))                       return slice.call(obj);\n    if (obj.toArray && _.isFunction(obj.toArray)) return obj.toArray();\n    return _.values(obj);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    return _.isArray(obj) ? obj.length : _.keys(obj).length;\n  };\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n  _.first = _.head = _.take = function(array, n, guard) {\n    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];\n  };\n\n  // Returns everything but the last entry of the array. Especcialy useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N. The **guard** check allows it to work with\n  // `_.map`.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array. The **guard** check allows it to work with `_.map`.\n  _.last = function(array, n, guard) {\n    if ((n != null) && !guard) {\n      return slice.call(array, Math.max(array.length - n, 0));\n    } else {\n      return array[array.length - 1];\n    }\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail`.\n  // Especially useful on the arguments object. Passing an **index** will return\n  // the rest of the values in the array from that index onward. The **guard**\n  // check allows it to work with `_.map`.\n  _.rest = _.tail = function(array, index, guard) {\n    return slice.call(array, (index == null) || guard ? 1 : index);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, function(value){ return !!value; });\n  };\n\n  // Return a completely flattened version of an array.\n  _.flatten = function(array, shallow) {\n    return _.reduce(array, function(memo, value) {\n      if (_.isArray(value)) return memo.concat(shallow ? value : _.flatten(value));\n      memo[memo.length] = value;\n      return memo;\n    }, []);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = function(array) {\n    return _.difference(array, slice.call(arguments, 1));\n  };\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iterator) {\n    var initial = iterator ? _.map(array, iterator) : array;\n    var results = [];\n    // The `isSorted` flag is irrelevant if the array only contains two elements.\n    if (array.length < 3) isSorted = true;\n    _.reduce(initial, function (memo, value, index) {\n      if (isSorted ? _.last(memo) !== value || !memo.length : !_.include(memo, value)) {\n        memo.push(value);\n        results.push(array[index]);\n      }\n      return memo;\n    }, []);\n    return results;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = function() {\n    return _.uniq(_.flatten(arguments, true));\n  };\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays. (Aliased as \"intersect\" for back-compat.)\n  _.intersection = _.intersect = function(array) {\n    var rest = slice.call(arguments, 1);\n    return _.filter(_.uniq(array), function(item) {\n      return _.every(rest, function(other) {\n        return _.indexOf(other, item) >= 0;\n      });\n    });\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = function(array) {\n    var rest = _.flatten(slice.call(arguments, 1), true);\n    return _.filter(array, function(value){ return !_.include(rest, value); });\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = function() {\n    var args = slice.call(arguments);\n    var length = _.max(_.pluck(args, 'length'));\n    var results = new Array(length);\n    for (var i = 0; i < length; i++) results[i] = _.pluck(args, \"\" + i);\n    return results;\n  };\n\n  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),\n  // we need this function. Return the position of the first occurrence of an\n  // item in an array, or -1 if the item is not included in the array.\n  // Delegates to **ECMAScript 5**'s native `indexOf` if available.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = function(array, item, isSorted) {\n    if (array == null) return -1;\n    var i, l;\n    if (isSorted) {\n      i = _.sortedIndex(array, item);\n      return array[i] === item ? i : -1;\n    }\n    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item);\n    for (i = 0, l = array.length; i < l; i++) if (i in array && array[i] === item) return i;\n    return -1;\n  };\n\n  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.\n  _.lastIndexOf = function(array, item) {\n    if (array == null) return -1;\n    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) return array.lastIndexOf(item);\n    var i = array.length;\n    while (i--) if (i in array && array[i] === item) return i;\n    return -1;\n  };\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (arguments.length <= 1) {\n      stop = start || 0;\n      start = 0;\n    }\n    step = arguments[2] || 1;\n\n    var len = Math.max(Math.ceil((stop - start) / step), 0);\n    var idx = 0;\n    var range = new Array(len);\n\n    while(idx < len) {\n      range[idx++] = start;\n      start += step;\n    }\n\n    return range;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Reusable constructor function for prototype setting.\n  var ctor = function(){};\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Binding with arguments is also known as `curry`.\n  // Delegates to **ECMAScript 5**'s native `Function.bind` if available.\n  // We check for `func.bind` first, to fail fast when `func` is undefined.\n  _.bind = function bind(func, context) {\n    var bound, args;\n    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n    if (!_.isFunction(func)) throw new TypeError;\n    args = slice.call(arguments, 2);\n    return bound = function() {\n      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));\n      ctor.prototype = func.prototype;\n      var self = new ctor;\n      var result = func.apply(self, args.concat(slice.call(arguments)));\n      if (Object(result) === result) return result;\n      return self;\n    };\n  };\n\n  // Bind all of an object's methods to that object. Useful for ensuring that\n  // all callbacks defined on an object belong to it.\n  _.bindAll = function(obj) {\n    var funcs = slice.call(arguments, 1);\n    if (funcs.length == 0) funcs = _.functions(obj);\n    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });\n    return obj;\n  };\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memo = {};\n    hasher || (hasher = _.identity);\n    return function() {\n      var key = hasher.apply(this, arguments);\n      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));\n    };\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = function(func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function(){ return func.apply(null, args); }, wait);\n  };\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = function(func) {\n    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));\n  };\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time.\n  _.throttle = function(func, wait) {\n    var context, args, timeout, throttling, more, result;\n    var whenDone = _.debounce(function(){ more = throttling = false; }, wait);\n    return function() {\n      context = this; args = arguments;\n      var later = function() {\n        timeout = null;\n        if (more) func.apply(context, args);\n        whenDone();\n      };\n      if (!timeout) timeout = setTimeout(later, wait);\n      if (throttling) {\n        more = true;\n      } else {\n        result = func.apply(context, args);\n      }\n      whenDone();\n      throttling = true;\n      return result;\n    };\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout;\n    return function() {\n      var context = this, args = arguments;\n      var later = function() {\n        timeout = null;\n        if (!immediate) func.apply(context, args);\n      };\n      if (immediate && !timeout) func.apply(context, args);\n      clearTimeout(timeout);\n      timeout = setTimeout(later, wait);\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = function(func) {\n    var ran = false, memo;\n    return function() {\n      if (ran) return memo;\n      ran = true;\n      return memo = func.apply(this, arguments);\n    };\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return function() {\n      var args = [func].concat(slice.call(arguments, 0));\n      return wrapper.apply(this, args);\n    };\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var funcs = arguments;\n    return function() {\n      var args = arguments;\n      for (var i = funcs.length - 1; i >= 0; i--) {\n        args = [funcs[i].apply(this, args)];\n      }\n      return args[0];\n    };\n  };\n\n  // Returns a function that will only be executed after being called N times.\n  _.after = function(times, func) {\n    if (times <= 0) return func();\n    return function() {\n      if (--times < 1) { return func.apply(this, arguments); }\n    };\n  };\n\n  // Object Functions\n  // ----------------\n\n  // Retrieve the names of an object's properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\n  _.keys = nativeKeys || function(obj) {\n    if (obj !== Object(obj)) throw new TypeError('Invalid object');\n    var keys = [];\n    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    return _.map(obj, _.identity);\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      for (var prop in source) {\n        obj[prop] = source[prop];\n      }\n    });\n    return obj;\n  };\n\n  // Return a copy of the object only containing the whitelisted properties.\n  _.pick = function(obj) {\n    var result = {};\n    each(_.flatten(slice.call(arguments, 1)), function(key) {\n      if (key in obj) result[key] = obj[key];\n    });\n    return result;\n  };\n\n  // Fill in a given object with default properties.\n  _.defaults = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      for (var prop in source) {\n        if (obj[prop] == null) obj[prop] = source[prop];\n      }\n    });\n    return obj;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Internal recursive comparison function.\n  function eq(a, b, stack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.\n    if (a === b) return a !== 0 || 1 / a == 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if (a == null || b == null) return a === b;\n    // Unwrap any wrapped objects.\n    if (a._chain) a = a._wrapped;\n    if (b._chain) b = b._wrapped;\n    // Invoke a custom `isEqual` method if one is provided.\n    if (a.isEqual && _.isFunction(a.isEqual)) return a.isEqual(b);\n    if (b.isEqual && _.isFunction(b.isEqual)) return b.isEqual(a);\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className != toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, dates, and booleans are compared by value.\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return a == String(b);\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\n        // other numeric values.\n        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a == +b;\n      // RegExps are compared by their source patterns and flags.\n      case '[object RegExp]':\n        return a.source == b.source &&\n               a.global == b.global &&\n               a.multiline == b.multiline &&\n               a.ignoreCase == b.ignoreCase;\n    }\n    if (typeof a != 'object' || typeof b != 'object') return false;\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n    var length = stack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (stack[length] == a) return true;\n    }\n    // Add the first object to the stack of traversed objects.\n    stack.push(a);\n    var size = 0, result = true;\n    // Recursively compare objects and arrays.\n    if (className == '[object Array]') {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      size = a.length;\n      result = size == b.length;\n      if (result) {\n        // Deep compare the contents, ignoring non-numeric properties.\n        while (size--) {\n          // Ensure commutative equality for sparse arrays.\n          if (!(result = size in a == size in b && eq(a[size], b[size], stack))) break;\n        }\n      }\n    } else {\n      // Objects with different constructors are not equivalent.\n      if ('constructor' in a != 'constructor' in b || a.constructor != b.constructor) return false;\n      // Deep compare objects.\n      for (var key in a) {\n        if (_.has(a, key)) {\n          // Count the expected number of properties.\n          size++;\n          // Deep compare each member.\n          if (!(result = _.has(b, key) && eq(a[key], b[key], stack))) break;\n        }\n      }\n      // Ensure that both objects contain the same number of properties.\n      if (result) {\n        for (key in b) {\n          if (_.has(b, key) && !(size--)) break;\n        }\n        result = !size;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    stack.pop();\n    return result;\n  }\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b, []);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (obj == null) return true;\n    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;\n    for (var key in obj) if (_.has(obj, key)) return false;\n    return true;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType == 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) == '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    return obj === Object(obj);\n  };\n\n  // Is a given variable an arguments object?\n  _.isArguments = function(obj) {\n    return toString.call(obj) == '[object Arguments]';\n  };\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function(obj) {\n      return !!(obj && _.has(obj, 'callee'));\n    };\n  }\n\n  // Is a given value a function?\n  _.isFunction = function(obj) {\n    return toString.call(obj) == '[object Function]';\n  };\n\n  // Is a given value a string?\n  _.isString = function(obj) {\n    return toString.call(obj) == '[object String]';\n  };\n\n  // Is a given value a number?\n  _.isNumber = function(obj) {\n    return toString.call(obj) == '[object Number]';\n  };\n\n  // Is a given object a finite number?\n  _.isFinite = function(obj) {\n    return _.isNumber(obj) && isFinite(obj);\n  };\n\n  // Is the given value `NaN`?\n  _.isNaN = function(obj) {\n    // `NaN` is the only value for which `===` is not reflexive.\n    return obj !== obj;\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n  };\n\n  // Is a given value a date?\n  _.isDate = function(obj) {\n    return toString.call(obj) == '[object Date]';\n  };\n\n  // Is the given value a regular expression?\n  _.isRegExp = function(obj) {\n    return toString.call(obj) == '[object RegExp]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Has own property?\n  _.has = function(obj, key) {\n    return hasOwnProperty.call(obj, key);\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iterators.\n  _.identity = function(value) {\n    return value;\n  };\n\n  // Run a function **n** times.\n  _.times = function (n, iterator, context) {\n    for (var i = 0; i < n; i++) iterator.call(context, i);\n  };\n\n  // Escape a string for HTML interpolation.\n  _.escape = function(string) {\n    return (''+string).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;').replace(/'/g, '&#x27;').replace(/\\//g,'&#x2F;');\n  };\n\n  // If the value of the named property is a function then invoke it;\n  // otherwise, return it.\n  _.result = function(object, property) {\n    if (object == null) return null;\n    var value = object[property];\n    return _.isFunction(value) ? value.call(object) : value;\n  };\n\n  // Add your own custom functions to the Underscore object, ensuring that\n  // they're correctly added to the OOP wrapper as well.\n  _.mixin = function(obj) {\n    each(_.functions(obj), function(name){\n      addToWrapper(name, _[name] = obj[name]);\n    });\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = idCounter++;\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate    : /<%([\\s\\S]+?)%>/g,\n    interpolate : /<%=([\\s\\S]+?)%>/g,\n    escape      : /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /.^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    '\\\\': '\\\\',\n    \"'\": \"'\",\n    'r': '\\r',\n    'n': '\\n',\n    't': '\\t',\n    'u2028': '\\u2028',\n    'u2029': '\\u2029'\n  };\n\n  for (var p in escapes) escapes[escapes[p]] = p;\n  var escaper = /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g;\n  var unescaper = /\\\\(\\\\|'|r|n|t|u2028|u2029)/g;\n\n  // Within an interpolation, evaluation, or escaping, remove HTML escaping\n  // that had been previously added.\n  var unescape = function(code) {\n    return code.replace(unescaper, function(match, escape) {\n      return escapes[escape];\n    });\n  };\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  _.template = function(text, data, settings) {\n    settings = _.defaults(settings || {}, _.templateSettings);\n\n    // Compile the template source, taking care to escape characters that\n    // cannot be included in a string literal and then unescape them in code\n    // blocks.\n    var source = \"__p+='\" + text\n      .replace(escaper, function(match) {\n        return '\\\\' + escapes[match];\n      })\n      .replace(settings.escape || noMatch, function(match, code) {\n        return \"'+\\n_.escape(\" + unescape(code) + \")+\\n'\";\n      })\n      .replace(settings.interpolate || noMatch, function(match, code) {\n        return \"'+\\n(\" + unescape(code) + \")+\\n'\";\n      })\n      .replace(settings.evaluate || noMatch, function(match, code) {\n        return \"';\\n\" + unescape(code) + \"\\n;__p+='\";\n      }) + \"';\\n\";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n    source = \"var __p='';\" +\n      \"var print=function(){__p+=Array.prototype.join.call(arguments, '')};\\n\" +\n      source + \"return __p;\\n\";\n\n    var render = new Function(settings.variable || 'obj', '_', source);\n    if (data) return render(data, _);\n    var template = function(data) {\n      return render.call(this, data, _);\n    };\n\n    // Provide the compiled function source as a convenience for build time\n    // precompilation.\n    template.source = 'function(' + (settings.variable || 'obj') + '){\\n' +\n      source + '}';\n\n    return template;\n  };\n\n  // Add a \"chain\" function, which will delegate to the wrapper.\n  _.chain = function(obj) {\n    return _(obj).chain();\n  };\n\n  // The OOP Wrapper\n  // ---------------\n\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n  var wrapper = function(obj) { this._wrapped = obj; };\n\n  // Expose `wrapper.prototype` as `_.prototype`\n  _.prototype = wrapper.prototype;\n\n  // Helper function to continue chaining intermediate results.\n  var result = function(obj, chain) {\n    return chain ? _(obj).chain() : obj;\n  };\n\n  // A method to easily add functions to the OOP wrapper.\n  var addToWrapper = function(name, func) {\n    wrapper.prototype[name] = function() {\n      var args = slice.call(arguments);\n      unshift.call(args, this._wrapped);\n      return result(func.apply(_, args), this._chain);\n    };\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    wrapper.prototype[name] = function() {\n      var wrapped = this._wrapped;\n      method.apply(wrapped, arguments);\n      var length = wrapped.length;\n      if ((name == 'shift' || name == 'splice') && length === 0) delete wrapped[0];\n      return result(wrapped, this._chain);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    wrapper.prototype[name] = function() {\n      return result(method.apply(this._wrapped, arguments), this._chain);\n    };\n  });\n\n  // Start chaining a wrapped Underscore object.\n  wrapper.prototype.chain = function() {\n    this._chain = true;\n    return this;\n  };\n\n  // Extracts the result from a wrapped and chained object.\n  wrapper.prototype.value = function() {\n    return this._wrapped;\n  };\n  return _;\n}).call({});\n/**\n * Core Emmet object, available in global scope\n */\nvar emmet = (function(global) {\n\tvar defaultSyntax = 'html';\n\tvar defaultProfile = 'plain';\n\t\n\tif (typeof _ == 'undefined') {\n\t\ttry {\n\t\t\t// avoid collisions with RequireJS loader\n\t\t\t// also, JS obfuscators tends to translate\n\t\t\t// a[\"name\"] to a.name, which also breaks RequireJS\n\t\t\t_ = global[['require'][0]]('underscore'); // node.js\n\t\t} catch (e) {}\n\t}\n\n\tif (typeof _ == 'undefined') {\n\t\tthrow 'Cannot access to Underscore.js lib';\n\t}\n\n\t/** List of registered modules */\n\tvar modules = {\n\t\t_ : _\n\t};\n\t\n\t/**\n\t * Shared empty constructor function to aid in prototype-chain creation.\n\t */\n\tvar ctor = function(){};\n\t\n\t/**\n\t * Helper function to correctly set up the prototype chain, for subclasses.\n\t * Similar to `goog.inherits`, but uses a hash of prototype properties and\n\t * class properties to be extended.\n\t * Took it from Backbone.\n\t * @param {Object} parent\n\t * @param {Object} protoProps\n\t * @param {Object} staticProps\n\t * @returns {Object}\n\t */\n\tfunction inherits(parent, protoProps, staticProps) {\n\t\tvar child;\n\n\t\t// The constructor function for the new subclass is either defined by\n\t\t// you (the \"constructor\" property in your `extend` definition), or\n\t\t// defaulted by us to simply call the parent's constructor.\n\t\tif (protoProps && protoProps.hasOwnProperty('constructor')) {\n\t\t\tchild = protoProps.constructor;\n\t\t} else {\n\t\t\tchild = function() {\n\t\t\t\tparent.apply(this, arguments);\n\t\t\t};\n\t\t}\n\n\t\t// Inherit class (static) properties from parent.\n\t\t_.extend(child, parent);\n\n\t\t// Set the prototype chain to inherit from `parent`, without calling\n\t\t// `parent`'s constructor function.\n\t\tctor.prototype = parent.prototype;\n\t\tchild.prototype = new ctor();\n\n\t\t// Add prototype properties (instance properties) to the subclass,\n\t\t// if supplied.\n\t\tif (protoProps)\n\t\t\t_.extend(child.prototype, protoProps);\n\n\t\t// Add static properties to the constructor function, if supplied.\n\t\tif (staticProps)\n\t\t\t_.extend(child, staticProps);\n\n\t\t// Correctly set child's `prototype.constructor`.\n\t\tchild.prototype.constructor = child;\n\n\t\t// Set a convenience property in case the parent's prototype is needed\n\t\t// later.\n\t\tchild.__super__ = parent.prototype;\n\n\t\treturn child;\n\t};\n\t\n\t/**\n\t * @type Function Function that loads module definition if it's not defined\n\t */\n\tvar moduleLoader = null;\n\t\n\t/**\n\t * Generic Emmet module loader (actually, it doesn’t load anything, just \n\t * returns module reference). Not using `require` name to avoid conflicts\n\t * with Node.js and RequireJS\n\t */\n\tfunction r(name) {\n\t\tif (!(name in modules) && moduleLoader)\n\t\t\tmoduleLoader(name);\n\t\t\n\t\treturn modules[name];\n\t}\n\t\n\treturn {\n\t\t/**\n\t\t * Simple, AMD-like module definition. The module will be added into\n\t\t * <code>emmet</code> object and will be available via\n\t\t * <code>emmet.require(name)</code> or <code>emmet[name]</code>\n\t\t * @param {String} name\n\t\t * @param {Function} factory\n\t\t * @memberOf emmet\n\t\t */\n\t\tdefine: function(name, factory) {\n\t\t\t// do not let redefine existing properties\n\t\t\tif (!(name in modules)) {\n\t\t\t\tmodules[name] = _.isFunction(factory) \n\t\t\t\t\t? this.exec(factory)\n\t\t\t\t\t: factory;\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns reference to Emmet module\n\t\t * @param {String} name Module name\n\t\t */\n\t\trequire: r,\n\t\t\n\t\t/**\n\t\t * Helper method that just executes passed function but with all \n\t\t * important arguments like 'require' and '_'\n\t\t * @param {Function} fn\n\t\t * @param {Object} context Execution context\n\t\t */\n\t\texec: function(fn, context) {\n\t\t\treturn fn.call(context || global, _.bind(r, this), _, this);\n\t\t},\n\t\t\n\t\t/**\n\t\t * The self-propagating extend function for classes.\n\t\t * Took it from Backbone \n\t\t * @param {Object} protoProps\n\t\t * @param {Object} classProps\n\t\t * @returns {Object}\n\t\t */\n\t\textend: function(protoProps, classProps) {\n\t\t\tvar child = inherits(this, protoProps, classProps);\n\t\t\tchild.extend = this.extend;\n\t\t\t// a hack required to WSH inherit `toString` method\n\t\t\tif (protoProps.hasOwnProperty('toString'))\n\t\t\t\tchild.prototype.toString = protoProps.toString;\n\t\t\treturn child;\n\t\t},\n\t\t\n\t\t/**\n\t\t * The essential function that expands Emmet abbreviation\n\t\t * @param {String} abbr Abbreviation to parse\n\t\t * @param {String} syntax Abbreviation's context syntax\n\t\t * @param {String} profile Output profile (or its name)\n\t\t * @param {Object} contextNode Contextual node where abbreviation is\n\t\t * written\n\t\t * @return {String}\n\t\t */\n\t\texpandAbbreviation: function(abbr, syntax, profile, contextNode) {\n\t\t\tif (!abbr) return '';\n\t\t\t\n\t\t\tsyntax = syntax || defaultSyntax;\n//\t\t\tprofile = profile || defaultProfile;\n\t\t\t\n\t\t\tvar filters = r('filters');\n\t\t\tvar parser = r('abbreviationParser');\n\t\t\t\n\t\t\tprofile = r('profile').get(profile, syntax);\n\t\t\tr('tabStops').resetTabstopIndex();\n\t\t\t\n\t\t\tvar data = filters.extractFromAbbreviation(abbr);\n\t\t\tvar outputTree = parser.parse(data[0], {\n\t\t\t\tsyntax: syntax, \n\t\t\t\tcontextNode: contextNode\n\t\t\t});\n\t\t\t\n\t\t\tvar filtersList = filters.composeList(syntax, profile, data[1]);\n\t\t\tfilters.apply(outputTree, filtersList, profile);\n\t\t\treturn outputTree.toString();\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns default syntax name used in abbreviation engine\n\t\t * @returns {String}\n\t\t */\n\t\tdefaultSyntax: function() {\n\t\t\treturn defaultSyntax;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns default profile name used in abbreviation engine\n\t\t * @returns {String}\n\t\t */\n\t\tdefaultProfile: function() {\n\t\t\treturn defaultProfile;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Log message into console if it exists\n\t\t */\n\t\tlog: function() {\n\t\t\tif (global.console && global.console.log)\n\t\t\t\tglobal.console.log.apply(global.console, arguments);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Setups function that should synchronously load undefined modules\n\t\t * @param {Function} fn\n\t\t */\n\t\tsetModuleLoader: function(fn) {\n\t\t\tmoduleLoader = fn;\n\t\t}\n\t};\n})(this);\n\n// export core for Node.JS\nif (true) {\n\tif (typeof module !== 'undefined' && module.exports) {\n\t\texports = module.exports = emmet;\n\t}\n\texports.emmet = emmet;\n}\n\n// export as Require.js module\nif (true) {\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (emmet),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n}/**\n * Emmet abbreviation parser.\n * Takes string abbreviation and recursively parses it into a tree. The parsed \n * tree can be transformed into a string representation with \n * <code>toString()</code> method. Note that string representation is defined\n * by custom processors (called <i>filters</i>), not by abbreviation parser \n * itself.\n * \n * This module can be extended with custom pre-/post-processors to shape-up\n * final tree or its representation. Actually, many features of abbreviation \n * engine are defined in other modules as tree processors\n * \n * \n * @author Sergey Chikuyonok (serge.che@gmail.com)\n * @link http://chikuyonok.ru\n * @memberOf __abbreviationParser\n * @constructor\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.define('abbreviationParser', function(require, _) {\n\tvar reValidName = /^[\\w\\-\\$\\:@\\!%]+\\+?$/i;\n\tvar reWord = /[\\w\\-:\\$@]/;\n\t\n\tvar pairs = {\n\t\t'[': ']',\n\t\t'(': ')',\n\t\t'{': '}'\n\t};\n\t\n\tvar spliceFn = Array.prototype.splice;\n\t\n\tvar preprocessors = [];\n\tvar postprocessors = [];\n\tvar outputProcessors = [];\n\t\n\t/**\n\t * @type AbbreviationNode\n\t */\n\tfunction AbbreviationNode(parent) {\n\t\t/** @type AbbreviationNode */\n\t\tthis.parent = null;\n\t\tthis.children = [];\n\t\tthis._attributes = [];\n\t\t\n\t\t/** @type String Raw abbreviation for current node */\n\t\tthis.abbreviation = '';\n\t\tthis.counter = 1;\n\t\tthis._name = null;\n\t\tthis._text = '';\n\t\tthis.repeatCount = 1;\n\t\tthis.hasImplicitRepeat = false;\n\t\t\n\t\t/** Custom data dictionary */\n\t\tthis._data = {};\n\t\t\n\t\t// output properties\n\t\tthis.start = '';\n\t\tthis.end = '';\n\t\tthis.content = '';\n\t\tthis.padding = '';\n\t}\n\t\n\tAbbreviationNode.prototype = {\n\t\t/**\n\t\t * Adds passed node as child or creates new child\n\t\t * @param {AbbreviationNode} child\n\t\t * @param {Number} position Index in children array where child should \n\t\t * be inserted\n\t\t * @return {AbbreviationNode}\n\t\t */\n\t\taddChild: function(child, position) {\n\t\t\tchild = child || new AbbreviationNode;\n\t\t\tchild.parent = this;\n\t\t\t\n\t\t\tif (_.isUndefined(position)) {\n\t\t\t\tthis.children.push(child);\n\t\t\t} else {\n\t\t\t\tthis.children.splice(position, 0, child);\n\t\t\t}\n\t\t\t\n\t\t\treturn child;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Creates a deep copy of current node\n\t\t * @returns {AbbreviationNode}\n\t\t */\n\t\tclone: function() {\n\t\t\tvar node = new AbbreviationNode();\n\t\t\tvar attrs = ['abbreviation', 'counter', '_name', '_text', 'repeatCount', 'hasImplicitRepeat', 'start', 'end', 'content', 'padding'];\n\t\t\t_.each(attrs, function(a) {\n\t\t\t\tnode[a] = this[a];\n\t\t\t}, this);\n\t\t\t\n\t\t\t// clone attributes\n\t\t\tnode._attributes = _.map(this._attributes, function(attr) {\n\t\t\t\treturn _.clone(attr);\n\t\t\t});\n\t\t\t\n\t\t\tnode._data = _.clone(this._data);\n\t\t\t\n\t\t\t// clone children\n\t\t\tnode.children = _.map(this.children, function(child) {\n\t\t\t\tchild = child.clone();\n\t\t\t\tchild.parent = node;\n\t\t\t\treturn child;\n\t\t\t});\n\t\t\t\n\t\t\treturn node;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Removes current node from parent‘s child list\n\t\t * @returns {AbbreviationNode} Current node itself\n\t\t */\n\t\tremove: function() {\n\t\t\tif (this.parent) {\n\t\t\t\tthis.parent.children = _.without(this.parent.children, this);\n\t\t\t}\n\t\t\t\n\t\t\treturn this;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Replaces current node in parent‘s children list with passed nodes\n\t\t * @param {AbbreviationNode} node Replacement node or array of nodes\n\t\t */\n\t\treplace: function() {\n\t\t\tvar parent = this.parent;\n\t\t\tvar ix = _.indexOf(parent.children, this);\n\t\t\tvar items = _.flatten(arguments);\n\t\t\tspliceFn.apply(parent.children, [ix, 1].concat(items));\n\t\t\t\n\t\t\t// update parent\n\t\t\t_.each(items, function(item) {\n\t\t\t\titem.parent = parent;\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Recursively sets <code>property</code> to <code>value</code> of current\n\t\t * node and its children \n\t\t * @param {String} name Property to update\n\t\t * @param {Object} value New property value\n\t\t */\n\t\tupdateProperty: function(name, value) {\n\t\t\tthis[name] = value;\n\t\t\t_.each(this.children, function(child) {\n\t\t\t\tchild.updateProperty(name, value);\n\t\t\t});\n\t\t\t\n\t\t\treturn this;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Finds first child node that matches truth test for passed \n\t\t * <code>fn</code> function\n\t\t * @param {Function} fn\n\t\t * @returns {AbbreviationNode}\n\t\t */\n\t\tfind: function(fn) {\n\t\t\treturn this.findAll(fn)[0];\n//\t\t\tif (!_.isFunction(fn)) {\n//\t\t\t\tvar elemName = fn.toLowerCase();\n//\t\t\t\tfn = function(item) {return item.name().toLowerCase() == elemName;};\n//\t\t\t}\n//\t\t\t\n//\t\t\tvar result = null;\n//\t\t\t_.find(this.children, function(child) {\n//\t\t\t\tif (fn(child)) {\n//\t\t\t\t\treturn result = child;\n//\t\t\t\t}\n//\t\t\t\t\n//\t\t\t\treturn result = child.find(fn);\n//\t\t\t});\n//\t\t\t\n//\t\t\treturn result;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Finds all child nodes that matches truth test for passed \n\t\t * <code>fn</code> function\n\t\t * @param {Function} fn\n\t\t * @returns {Array}\n\t\t */\n\t\tfindAll: function(fn) {\n\t\t\tif (!_.isFunction(fn)) {\n\t\t\t\tvar elemName = fn.toLowerCase();\n\t\t\t\tfn = function(item) {return item.name().toLowerCase() == elemName;};\n\t\t\t}\n\t\t\t\t\n\t\t\tvar result = [];\n\t\t\t_.each(this.children, function(child) {\n\t\t\t\tif (fn(child))\n\t\t\t\t\tresult.push(child);\n\t\t\t\t\n\t\t\t\tresult = result.concat(child.findAll(fn));\n\t\t\t});\n\t\t\t\n\t\t\treturn _.compact(result);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Sets/gets custom data\n\t\t * @param {String} name\n\t\t * @param {Object} value\n\t\t * @returns {Object}\n\t\t */\n\t\tdata: function(name, value) {\n\t\t\tif (arguments.length == 2) {\n\t\t\t\tthis._data[name] = value;\n\t\t\t\t\n\t\t\t\tif (name == 'resource' && require('elements').is(value, 'snippet')) {\n\t\t\t\t\t// setting snippet as matched resource: update `content`\n\t\t\t\t\t// property with snippet value\n\t\t\t\t\tthis.content = value.data;\n\t\t\t\t\tif (this._text) {\n\t\t\t\t\t\tthis.content = require('abbreviationUtils')\n\t\t\t\t\t\t\t.insertChildContent(value.data, this._text);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn this._data[name];\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns name of current node\n\t\t * @returns {String}\n\t\t */\n\t\tname: function() {\n\t\t\tvar res = this.matchedResource();\n\t\t\tif (require('elements').is(res, 'element')) {\n\t\t\t\treturn res.name;\n\t\t\t}\n\t\t\t\n\t\t\treturn this._name;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns list of attributes for current node\n\t\t * @returns {Array}\n\t\t */\n\t\tattributeList: function() {\n\t\t\tvar attrs = [];\n\t\t\t\n\t\t\tvar res = this.matchedResource();\n\t\t\tif (require('elements').is(res, 'element') && _.isArray(res.attributes)) {\n\t\t\t\tattrs = attrs.concat(res.attributes);\n\t\t\t}\n\t\t\t\n\t\t\treturn optimizeAttributes(attrs.concat(this._attributes));\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns or sets attribute value\n\t\t * @param {String} name Attribute name\n\t\t * @param {String} value New attribute value\n\t\t * @returns {String}\n\t\t */\n\t\tattribute: function(name, value) {\n\t\t\tif (arguments.length == 2) {\n\t\t\t\t// modifying attribute\n\t\t\t\tvar ix = _.indexOf(_.pluck(this._attributes, 'name'), name.toLowerCase());\n\t\t\t\tif (~ix) {\n\t\t\t\t\tthis._attributes[ix].value = value;\n\t\t\t\t} else {\n\t\t\t\t\tthis._attributes.push({\n\t\t\t\t\t\tname: name,\n\t\t\t\t\t\tvalue: value\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn (_.find(this.attributeList(), function(attr) {\n\t\t\t\treturn attr.name == name;\n\t\t\t}) || {}).value;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns reference to the matched <code>element</code>, if any.\n\t\t * See {@link elements} module for a list of available elements\n\t\t * @returns {Object}\n\t\t */\n\t\tmatchedResource: function() {\n\t\t\treturn this.data('resource');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns index of current node in parent‘s children list\n\t\t * @returns {Number}\n\t\t */\n\t\tindex: function() {\n\t\t\treturn this.parent ? _.indexOf(this.parent.children, this) : -1;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Sets how many times current element should be repeated\n\t\t * @private\n\t\t */\n\t\t_setRepeat: function(count) {\n\t\t\tif (count) {\n\t\t\t\tthis.repeatCount = parseInt(count, 10) || 1;\n\t\t\t} else {\n\t\t\t\tthis.hasImplicitRepeat = true;\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Sets abbreviation that belongs to current node\n\t\t * @param {String} abbr\n\t\t */\n\t\tsetAbbreviation: function(abbr) {\n\t\t\tabbr = abbr || '';\n\t\t\t\n\t\t\tvar that = this;\n\t\t\t\n\t\t\t// find multiplier\n\t\t\tabbr = abbr.replace(/\\*(\\d+)?$/, function(str, repeatCount) {\n\t\t\t\tthat._setRepeat(repeatCount);\n\t\t\t\treturn '';\n\t\t\t});\n\t\t\t\n\t\t\tthis.abbreviation = abbr;\n\t\t\t\n\t\t\tvar abbrText = extractText(abbr);\n\t\t\tif (abbrText) {\n\t\t\t\tabbr = abbrText.element;\n\t\t\t\tthis.content = this._text = abbrText.text;\n\t\t\t}\n\t\t\t\n\t\t\tvar abbrAttrs = parseAttributes(abbr);\n\t\t\tif (abbrAttrs) {\n\t\t\t\tabbr = abbrAttrs.element;\n\t\t\t\tthis._attributes = abbrAttrs.attributes;\n\t\t\t}\n\t\t\t\n\t\t\tthis._name = abbr;\n\t\t\t\n\t\t\t// validate name\n\t\t\tif (this._name && !reValidName.test(this._name)) {\n\t\t\t\tthrow 'Invalid abbreviation';\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns string representation of current node\n\t\t * @return {String}\n\t\t */\n\t\ttoString: function() {\n\t\t\tvar utils = require('utils');\n\t\t\t\n\t\t\tvar start = this.start;\n\t\t\tvar end = this.end;\n\t\t\tvar content = this.content;\n\t\t\t\n\t\t\t// apply output processors\n\t\t\tvar node = this;\n\t\t\t_.each(outputProcessors, function(fn) {\n\t\t\t\tstart = fn(start, node, 'start');\n\t\t\t\tcontent = fn(content, node, 'content');\n\t\t\t\tend = fn(end, node, 'end');\n\t\t\t});\n\t\t\t\n\t\t\t\n\t\t\tvar innerContent = _.map(this.children, function(child) {\n\t\t\t\treturn child.toString();\n\t\t\t}).join('');\n\t\t\t\n\t\t\tcontent = require('abbreviationUtils').insertChildContent(content, innerContent, {\n\t\t\t\tkeepVariable: false\n\t\t\t});\n\t\t\t\n\t\t\treturn start + utils.padString(content, this.padding) + end;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if current node contains children with empty <code>expr</code>\n\t\t * property\n\t\t * @return {Boolean}\n\t\t */\n\t\thasEmptyChildren: function() {\n\t\t\treturn !!_.find(this.children, function(child) {\n\t\t\t\treturn child.isEmpty();\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if current node has implied name that should be resolved\n\t\t * @returns {Boolean}\n\t\t */\n\t\thasImplicitName: function() {\n\t\t\treturn !this._name && !this.isTextNode();\n\t\t},\n\t\t\n\t\t/**\n\t\t * Indicates that current element is a grouping one, e.g. has no \n\t\t * representation but serves as a container for other nodes\n\t\t * @returns {Boolean}\n\t\t */\n\t\tisGroup: function() {\n\t\t\treturn !this.abbreviation;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Indicates empty node (i.e. without abbreviation). It may be a \n\t\t * grouping node and should not be outputted\n\t\t * @return {Boolean}\n\t\t */\n\t\tisEmpty: function() {\n\t\t\treturn !this.abbreviation && !this.children.length;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Indicates that current node should be repeated\n\t\t * @returns {Boolean}\n\t\t */\n\t\tisRepeating: function() {\n\t\t\treturn this.repeatCount > 1 || this.hasImplicitRepeat;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if current node is a text-only node\n\t\t * @return {Boolean}\n\t\t */\n\t\tisTextNode: function() {\n\t\t\treturn !this.name() && !this.attributeList().length;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Indicates whether this node may be used to build elements or snippets\n\t\t * @returns {Boolean}\n\t\t */\n\t\tisElement: function() {\n\t\t\treturn !this.isEmpty() && !this.isTextNode();\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns latest and deepest child of current tree\n\t\t * @returns {AbbreviationNode}\n\t\t */\n\t\tdeepestChild: function() {\n\t\t\tif (!this.children.length)\n\t\t\t\treturn null;\n\t\t\t\t\n\t\t\tvar deepestChild = this;\n\t\t\twhile (deepestChild.children.length) {\n\t\t\t\tdeepestChild = _.last(deepestChild.children);\n\t\t\t}\n\t\t\t\n\t\t\treturn deepestChild;\n\t\t}\n\t};\n\t\n\t/**\n\t * Returns stripped string: a string without first and last character.\n\t * Used for “unquoting” strings\n\t * @param {String} str\n\t * @returns {String}\n\t */\n\tfunction stripped(str) {\n\t\treturn str.substring(1, str.length - 1);\n\t}\n\t\n\tfunction consumeQuotedValue(stream, quote) {\n\t\tvar ch;\n\t\twhile (ch = stream.next()) {\n\t\t\tif (ch === quote)\n\t\t\t\treturn true;\n\t\t\t\n\t\t\tif (ch == '\\\\')\n\t\t\t\tcontinue;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * Parses abbreviation into a tree\n\t * @param {String} abbr\n\t * @returns {AbbreviationNode}\n\t */\n\tfunction parseAbbreviation(abbr) {\n\t\tabbr = require('utils').trim(abbr);\n\t\t\n\t\tvar root = new AbbreviationNode;\n\t\tvar context = root.addChild(), ch;\n\t\t\n\t\t/** @type StringStream */\n\t\tvar stream = require('stringStream').create(abbr);\n\t\tvar loopProtector = 1000, multiplier;\n\t\t\n\t\twhile (!stream.eol() && --loopProtector > 0) {\n\t\t\tch = stream.peek();\n\t\t\t\n\t\t\tswitch (ch) {\n\t\t\t\tcase '(': // abbreviation group\n\t\t\t\t\tstream.start = stream.pos;\n\t\t\t\t\tif (stream.skipToPair('(', ')')) {\n\t\t\t\t\t\tvar inner = parseAbbreviation(stripped(stream.current()));\n\t\t\t\t\t\tif (multiplier = stream.match(/^\\*(\\d+)?/, true)) {\n\t\t\t\t\t\t\tcontext._setRepeat(multiplier[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t_.each(inner.children, function(child) {\n\t\t\t\t\t\t\tcontext.addChild(child);\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow 'Invalid abbreviation: mo matching \")\" found for character at ' + stream.pos;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase '>': // child operator\n\t\t\t\t\tcontext = context.addChild();\n\t\t\t\t\tstream.next();\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase '+': // sibling operator\n\t\t\t\t\tcontext = context.parent.addChild();\n\t\t\t\t\tstream.next();\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase '^': // climb up operator\n\t\t\t\t\tvar parent = context.parent || context;\n\t\t\t\t\tcontext = (parent.parent || parent).addChild();\n\t\t\t\t\tstream.next();\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tdefault: // consume abbreviation\n\t\t\t\t\tstream.start = stream.pos;\n\t\t\t\t\tstream.eatWhile(function(c) {\n\t\t\t\t\t\tif (c == '[' || c == '{') {\n\t\t\t\t\t\t\tif (stream.skipToPair(c, pairs[c])) {\n\t\t\t\t\t\t\t\tstream.backUp(1);\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tthrow 'Invalid abbreviation: mo matching \"' + pairs[c] + '\" found for character at ' + stream.pos;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (c == '+') {\n\t\t\t\t\t\t\t// let's see if this is an expando marker\n\t\t\t\t\t\t\tstream.next();\n\t\t\t\t\t\t\tvar isMarker = stream.eol() ||  ~'+>^*'.indexOf(stream.peek());\n\t\t\t\t\t\t\tstream.backUp(1);\n\t\t\t\t\t\t\treturn isMarker;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\treturn c != '(' && isAllowedChar(c);\n\t\t\t\t\t});\n\t\t\t\t\t\n\t\t\t\t\tcontext.setAbbreviation(stream.current());\n\t\t\t\t\tstream.start = stream.pos;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (loopProtector < 1)\n\t\t\tthrow 'Endless loop detected';\n\t\t\n\t\treturn root;\n\t}\n\t\n\t/**\n\t * Extract attributes and their values from attribute set: \n\t * <code>[attr col=3 title=\"Quoted string\"]</code>\n\t * @param {String} attrSet\n\t * @returns {Array}\n\t */\n\tfunction extractAttributes(attrSet, attrs) {\n\t\tattrSet = require('utils').trim(attrSet);\n\t\tvar result = [];\n\t\t\n\t\t/** @type StringStream */\n\t\tvar stream = require('stringStream').create(attrSet);\n\t\tstream.eatSpace();\n\t\t\n\t\twhile (!stream.eol()) {\n\t\t\tstream.start = stream.pos;\n\t\t\tif (stream.eatWhile(reWord)) {\n\t\t\t\tvar attrName = stream.current();\n\t\t\t\tvar attrValue = '';\n\t\t\t\tif (stream.peek() == '=') {\n\t\t\t\t\tstream.next();\n\t\t\t\t\tstream.start = stream.pos;\n\t\t\t\t\tvar quote = stream.peek();\n\t\t\t\t\t\n\t\t\t\t\tif (quote == '\"' || quote == \"'\") {\n\t\t\t\t\t\tstream.next();\n\t\t\t\t\t\tif (consumeQuotedValue(stream, quote)) {\n\t\t\t\t\t\t\tattrValue = stream.current();\n\t\t\t\t\t\t\t// strip quotes\n\t\t\t\t\t\t\tattrValue = attrValue.substring(1, attrValue.length - 1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow 'Invalid attribute value';\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (stream.eatWhile(/[^\\s\\]]/)) {\n\t\t\t\t\t\tattrValue = stream.current();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow 'Invalid attribute value';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tresult.push({\n\t\t\t\t\tname: attrName, \n\t\t\t\t\tvalue: attrValue\n\t\t\t\t});\n\t\t\t\tstream.eatSpace();\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn result;\n\t}\n\t\n\t/**\n\t * Parses tag attributes extracted from abbreviation. If attributes found, \n\t * returns object with <code>element</code> and <code>attributes</code>\n\t * properties\n\t * @param {String} abbr\n\t * @returns {Object} Returns <code>null</code> if no attributes found in \n\t * abbreviation\n\t */\n\tfunction parseAttributes(abbr) {\n\t\t/*\n\t\t * Example of incoming data:\n\t\t * #header\n\t\t * .some.data\n\t\t * .some.data#header\n\t\t * [attr]\n\t\t * #item[attr=Hello other=\"World\"].class\n\t\t */\n\t\tvar result = [];\n\t\tvar attrMap = {'#': 'id', '.': 'class'};\n\t\tvar nameEnd = null;\n\t\t\n\t\t/** @type StringStream */\n\t\tvar stream = require('stringStream').create(abbr);\n\t\twhile (!stream.eol()) {\n\t\t\tswitch (stream.peek()) {\n\t\t\t\tcase '#': // id\n\t\t\t\tcase '.': // class\n\t\t\t\t\tif (nameEnd === null)\n\t\t\t\t\t\tnameEnd = stream.pos;\n\t\t\t\t\t\n\t\t\t\t\tvar attrName = attrMap[stream.peek()];\n\t\t\t\t\t\n\t\t\t\t\tstream.next();\n\t\t\t\t\tstream.start = stream.pos;\n\t\t\t\t\tstream.eatWhile(reWord);\n\t\t\t\t\tresult.push({\n\t\t\t\t\t\tname: attrName, \n\t\t\t\t\t\tvalue: stream.current()\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\t\t\t\tcase '[': //begin attribute set\n\t\t\t\t\tif (nameEnd === null)\n\t\t\t\t\t\tnameEnd = stream.pos;\n\t\t\t\t\t\n\t\t\t\t\tstream.start = stream.pos;\n\t\t\t\t\tif (!stream.skipToPair('[', ']')) \n\t\t\t\t\t\tthrow 'Invalid attribute set definition';\n\t\t\t\t\t\n\t\t\t\t\tresult = result.concat(\n\t\t\t\t\t\textractAttributes(stripped(stream.current()))\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tstream.next();\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (!result.length)\n\t\t\treturn null;\n\t\t\n\t\treturn {\n\t\t\telement: abbr.substring(0, nameEnd),\n\t\t\tattributes: optimizeAttributes(result)\n\t\t};\n\t}\n\t\n\t/**\n\t * Optimize attribute set: remove duplicates and merge class attributes\n\t * @param attrs\n\t */\n\tfunction optimizeAttributes(attrs) {\n\t\t// clone all attributes to make sure that original objects are \n\t\t// not modified\n\t\tattrs  = _.map(attrs, function(attr) {\n\t\t\treturn _.clone(attr);\n\t\t});\n\t\t\n\t\tvar lookup = {};\n\t\treturn _.filter(attrs, function(attr) {\n\t\t\tif (!(attr.name in lookup)) {\n\t\t\t\treturn lookup[attr.name] = attr;\n\t\t\t}\n\t\t\t\n\t\t\tvar la = lookup[attr.name];\n\t\t\t\n\t\t\tif (attr.name.toLowerCase() == 'class') {\n\t\t\t\tla.value += (la.value.length ? ' ' : '') + attr.value;\n\t\t\t} else {\n\t\t\t\tla.value = attr.value;\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\t\t});\n\t}\n\t\n\t/**\n\t * Extract text data from abbreviation: if <code>a{hello}</code> abbreviation\n\t * is passed, returns object <code>{element: 'a', text: 'hello'}</code>.\n\t * If nothing found, returns <code>null</code>\n\t * @param {String} abbr\n\t * \n\t */\n\tfunction extractText(abbr) {\n\t\tif (!~abbr.indexOf('{'))\n\t\t\treturn null;\n\t\t\n\t\t/** @type StringStream */\n\t\tvar stream = require('stringStream').create(abbr);\n\t\twhile (!stream.eol()) {\n\t\t\tswitch (stream.peek()) {\n\t\t\t\tcase '[':\n\t\t\t\tcase '(':\n\t\t\t\t\tstream.skipToPair(stream.peek(), pairs[stream.peek()]); break;\n\t\t\t\t\t\n\t\t\t\tcase '{':\n\t\t\t\t\tstream.start = stream.pos;\n\t\t\t\t\tstream.skipToPair('{', '}');\n\t\t\t\t\treturn {\n\t\t\t\t\t\telement: abbr.substring(0, stream.start),\n\t\t\t\t\t\ttext: stripped(stream.current())\n\t\t\t\t\t};\n\t\t\t\t\t\n\t\t\t\tdefault:\n\t\t\t\t\tstream.next();\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * “Un-rolls“ contents of current node: recursively replaces all repeating \n\t * children with their repeated clones\n\t * @param {AbbreviationNode} node\n\t * @returns {AbbreviationNode}\n\t */\n\tfunction unroll(node) {\n\t\tfor (var i = node.children.length - 1, j, child, maxCount; i >= 0; i--) {\n\t\t\tchild = node.children[i];\n\t\t\t\n\t\t\tif (child.isRepeating()) {\n\t\t\t\tmaxCount = j = child.repeatCount;\n\t\t\t\tchild.repeatCount = 1;\n\t\t\t\tchild.updateProperty('counter', 1);\n\t\t\t\tchild.updateProperty('maxCount', maxCount);\n\t\t\t\twhile (--j > 0) {\n\t\t\t\t\tchild.parent.addChild(child.clone(), i + 1)\n\t\t\t\t\t\t.updateProperty('counter', j + 1)\n\t\t\t\t\t\t.updateProperty('maxCount', maxCount);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// to keep proper 'counter' property, we need to walk\n\t\t// on children once again\n\t\t_.each(node.children, unroll);\n\t\t\n\t\treturn node;\n\t}\n\t\n\t/**\n\t * Optimizes tree node: replaces empty nodes with their children\n\t * @param {AbbreviationNode} node\n\t * @return {AbbreviationNode}\n\t */\n\tfunction squash(node) {\n\t\tfor (var i = node.children.length - 1; i >= 0; i--) {\n\t\t\t/** @type AbbreviationNode */\n\t\t\tvar n = node.children[i];\n\t\t\tif (n.isGroup()) {\n\t\t\t\tn.replace(squash(n).children);\n\t\t\t} else if (n.isEmpty()) {\n\t\t\t\tn.remove();\n\t\t\t}\n\t\t}\n\t\t\n\t\t_.each(node.children, squash);\n\t\t\n\t\treturn node;\n\t}\n\t\n\tfunction isAllowedChar(ch) {\n\t\tvar charCode = ch.charCodeAt(0);\n\t\tvar specialChars = '#.*:$-_!@|%';\n\t\t\n\t\treturn (charCode > 64 && charCode < 91)       // uppercase letter\n\t\t\t\t|| (charCode > 96 && charCode < 123)  // lowercase letter\n\t\t\t\t|| (charCode > 47 && charCode < 58)   // number\n\t\t\t\t|| specialChars.indexOf(ch) != -1;    // special character\n\t}\n\t\n\t// XXX add counter replacer function as output processor\n\toutputProcessors.push(function(text, node) {\n\t\treturn require('utils').replaceCounter(text, node.counter, node.maxCount);\n\t});\n\t\n\treturn {\n\t\t/**\n\t\t * Parses abbreviation into tree with respect of groups, \n\t\t * text nodes and attributes. Each node of the tree is a single \n\t\t * abbreviation. Tree represents actual structure of the outputted \n\t\t * result\n\t\t * @memberOf abbreviationParser\n\t\t * @param {String} abbr Abbreviation to parse\n\t\t * @param {Object} options Additional options for parser and processors\n\t\t * \n\t\t * @return {AbbreviationNode}\n\t\t */\n\t\tparse: function(abbr, options) {\n\t\t\toptions = options || {};\n\t\t\t\n\t\t\tvar tree = parseAbbreviation(abbr);\n\t\t\t\n\t\t\tif (options.contextNode) {\n\t\t\t\t// add info about context node –\n\t\t\t\t// a parent XHTML node in editor inside which abbreviation is \n\t\t\t\t// expanded\n\t\t\t\ttree._name = options.contextNode.name;\n\t\t\t\tvar attrLookup = {};\n\t\t\t\t_.each(tree._attributes, function(attr) {\n\t\t\t\t\tattrLookup[attr.name] = attr;\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\t_.each(options.contextNode.attributes, function(attr) {\n\t\t\t\t\tif (attr.name in attrLookup) {\n\t\t\t\t\t\tattrLookup[attr.name].value = attr.value;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tattr = _.clone(attr);\n\t\t\t\t\t\ttree._attributes.push(attr);\n\t\t\t\t\t\tattrLookup[attr.name] = attr;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t// apply preprocessors\n\t\t\t_.each(preprocessors, function(fn) {\n\t\t\t\tfn(tree, options);\n\t\t\t});\n\t\t\t\n\t\t\ttree = squash(unroll(tree));\n\t\t\t\n\t\t\t// apply postprocessors\n\t\t\t_.each(postprocessors, function(fn) {\n\t\t\t\tfn(tree, options);\n\t\t\t});\n\t\t\t\n\t\t\treturn tree;\n\t\t},\n\t\t\n\t\tAbbreviationNode: AbbreviationNode,\n\t\t\n\t\t/**\n\t\t * Add new abbreviation preprocessor. <i>Preprocessor</i> is a function\n\t\t * that applies to a parsed abbreviation tree right after it get parsed.\n\t\t * The passed tree is in unoptimized state.\n\t\t * @param {Function} fn Preprocessor function. This function receives\n\t\t * two arguments: parsed abbreviation tree (<code>AbbreviationNode</code>)\n\t\t * and <code>options</code> hash that was passed to <code>parse</code>\n\t\t * method\n\t\t */\n\t\taddPreprocessor: function(fn) {\n\t\t\tif (!_.include(preprocessors, fn))\n\t\t\t\tpreprocessors.push(fn);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Removes registered preprocessor\n\t\t */\n\t\tremoveFilter: function(fn) {\n\t\t\tpreprocessor = _.without(preprocessors, fn);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Adds new abbreviation postprocessor. <i>Postprocessor</i> is a \n\t\t * functinon that applies to <i>optimized</i> parsed abbreviation tree\n\t\t * right before it returns from <code>parse()</code> method\n\t\t * @param {Function} fn Postprocessor function. This function receives\n\t\t * two arguments: parsed abbreviation tree (<code>AbbreviationNode</code>)\n\t\t * and <code>options</code> hash that was passed to <code>parse</code>\n\t\t * method\n\t\t */\n\t\taddPostprocessor: function(fn) {\n\t\t\tif (!_.include(postprocessors, fn))\n\t\t\t\tpostprocessors.push(fn);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Removes registered postprocessor function\n\t\t */\n\t\tremovePostprocessor: function(fn) {\n\t\t\tpostprocessors = _.without(postprocessors, fn);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Registers output postprocessor. <i>Output processor</i> is a \n\t\t * function that applies to output part (<code>start</code>, \n\t\t * <code>end</code> and <code>content</code>) when \n\t\t * <code>AbbreviationNode.toString()</code> method is called\n\t\t */\n\t\taddOutputProcessor: function(fn) {\n\t\t\tif (!_.include(outputProcessors, fn))\n\t\t\t\toutputProcessors.push(fn);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Removes registered output processor\n\t\t */\n\t\tremoveOutputProcessor: function(fn) {\n\t\t\toutputProcessors = _.without(outputProcessors, fn);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if passed symbol is valid symbol for abbreviation expression\n\t\t * @param {String} ch\n\t\t * @return {Boolean}\n\t\t */\n\t\tisAllowedChar: function(ch) {\n\t\t\tch = String(ch); // convert Java object to JS\n\t\t\treturn isAllowedChar(ch) || ~'>+^[](){}'.indexOf(ch);\n\t\t}\n\t};\n});/**\n * Processor function that matches parsed <code>AbbreviationNode</code>\n * against resources defined in <code>resource</code> module\n * @param {Function} require\n * @param {Underscore} _\n */ \nemmet.exec(function(require, _) {\n\t/**\n\t * Finds matched resources for child nodes of passed <code>node</code> \n\t * element. A matched resource is a reference to <i>snippets.json</i> entry\n\t * that describes output of parsed node \n\t * @param {AbbreviationNode} node\n\t * @param {String} syntax\n\t */\n\tfunction matchResources(node, syntax) {\n\t\tvar resources = require('resources');\n\t\tvar elements = require('elements');\n\t\tvar parser = require('abbreviationParser');\n\t\t\n\t\t// do a shallow copy because the children list can be modified during\n\t\t// resource matching\n\t\t_.each(_.clone(node.children), /** @param {AbbreviationNode} child */ function(child) {\n\t\t\tvar r = resources.getMatchedResource(child, syntax);\n\t\t\tif (_.isString(r)) {\n\t\t\t\tchild.data('resource', elements.create('snippet', r));\n\t\t\t} else if (elements.is(r, 'reference')) {\n\t\t\t\t// it’s a reference to another abbreviation:\n\t\t\t\t// parse it and insert instead of current child\n\t\t\t\t/** @type AbbreviationNode */\n\t\t\t\tvar subtree = parser.parse(r.data, {\n\t\t\t\t\tsyntax: syntax\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\t// if context element should be repeated, check if we need to \n\t\t\t\t// transfer repeated element to specific child node\n\t\t\t\tif (child.repeatCount > 1) {\n\t\t\t\t\tvar repeatedChildren = subtree.findAll(function(node) {\n\t\t\t\t\t\treturn node.hasImplicitRepeat;\n\t\t\t\t\t});\n\t\t\t\t\t\n\t\t\t\t\t_.each(repeatedChildren, function(node) {\n\t\t\t\t\t\tnode.repeatCount = child.repeatCount;\n\t\t\t\t\t\tnode.hasImplicitRepeat = false;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// move child‘s children into the deepest child of new subtree\n\t\t\t\tvar deepestChild = subtree.deepestChild();\n\t\t\t\tif (deepestChild) {\n\t\t\t\t\t_.each(child.children, function(c) {\n\t\t\t\t\t\tdeepestChild.addChild(c);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// copy current attributes to children\n\t\t\t\t_.each(subtree.children, function(node) {\n\t\t\t\t\t_.each(child.attributeList(), function(attr) {\n\t\t\t\t\t\tnode.attribute(attr.name, attr.value);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tchild.replace(subtree.children);\n\t\t\t} else {\n\t\t\t\tchild.data('resource', r);\n\t\t\t}\n\t\t\t\n\t\t\tmatchResources(child, syntax);\n\t\t});\n\t}\n\t\n\t// XXX register abbreviation filter that creates references to resources\n\t// on abbreviation nodes\n\t/**\n\t * @param {AbbreviationNode} tree\n\t */\n\trequire('abbreviationParser').addPreprocessor(function(tree, options) {\n\t\tvar syntax = options.syntax || emmet.defaultSyntax();\n\t\tmatchResources(tree, syntax);\n\t});\n\t\n});/**\n * Pasted content abbreviation processor. A pasted content is a content that\n * should be inserted into implicitly repeated abbreviation nodes.\n * This processor powers “Wrap With Abbreviation” action\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\tvar parser = require('abbreviationParser');\n\tvar outputPlaceholder = '$#';\n\t\n\t/**\n\t * Locates output placeholders inside text\n\t * @param {String} text\n\t * @returns {Array} Array of ranges of output placeholder in text\n\t */\n\tfunction locateOutputPlaceholder(text) {\n\t\tvar range = require('range');\n\t\tvar result = [];\n\t\t\n\t\t/** @type StringStream */\n\t\tvar stream = require('stringStream').create(text);\n\t\t\n\t\twhile (!stream.eol()) {\n\t\t\tif (stream.peek() == '\\\\') {\n\t\t\t\tstream.next();\n\t\t\t} else {\n\t\t\t\tstream.start = stream.pos;\n\t\t\t\tif (stream.match(outputPlaceholder, true)) {\n\t\t\t\t\tresult.push(range.create(stream.start, outputPlaceholder));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstream.next();\n\t\t}\n\t\t\n\t\treturn result;\n\t}\n\t\n\t/**\n\t * Replaces output placeholders inside <code>source</code> with \n\t * <code>value</code>\n\t * @param {String} source\n\t * @param {String} value\n\t * @returns {String}\n\t */\n\tfunction replaceOutputPlaceholders(source, value) {\n\t\tvar utils = require('utils');\n\t\tvar ranges = locateOutputPlaceholder(source);\n\t\t\n\t\tranges.reverse();\n\t\t_.each(ranges, function(r) {\n\t\t\tsource = utils.replaceSubstring(source, value, r);\n\t\t});\n\t\t\n\t\treturn source;\n\t}\n\t\n\t/**\n\t * Check if parsed node contains output placeholder – a target where\n\t * pasted content should be inserted\n\t * @param {AbbreviationNode} node\n\t * @returns {Boolean}\n\t */\n\tfunction hasOutputPlaceholder(node) {\n\t\tif (locateOutputPlaceholder(node.content).length)\n\t\t\treturn true;\n\t\t\n\t\t// check if attributes contains placeholder\n\t\treturn !!_.find(node.attributeList(), function(attr) {\n\t\t\treturn !!locateOutputPlaceholder(attr.value).length;\n\t\t});\n\t}\n\t\n\t/**\n\t * Insert pasted content into correct positions of parsed node\n\t * @param {AbbreviationNode} node\n\t * @param {String} content\n\t * @param {Boolean} overwrite Overwrite node content if no value placeholders\n\t * found instead of appending to existing content\n\t */\n\tfunction insertPastedContent(node, content, overwrite) {\n\t\tvar nodesWithPlaceholders = node.findAll(function(item) {\n\t\t\treturn hasOutputPlaceholder(item);\n\t\t});\n\t\t\n\t\tif (hasOutputPlaceholder(node))\n\t\t\tnodesWithPlaceholders.unshift(node);\n\t\t\n\t\tif (nodesWithPlaceholders.length) {\n\t\t\t_.each(nodesWithPlaceholders, function(item) {\n\t\t\t\titem.content = replaceOutputPlaceholders(item.content, content);\n\t\t\t\t_.each(item._attributes, function(attr) {\n\t\t\t\t\tattr.value = replaceOutputPlaceholders(attr.value, content);\n\t\t\t\t});\n\t\t\t});\n\t\t} else {\n\t\t\t// on output placeholders in subtree, insert content in the deepest\n\t\t\t// child node\n\t\t\tvar deepest = node.deepestChild() || node;\n\t\t\tif (overwrite) {\n\t\t\t\tdeepest.content = content;\n\t\t\t} else {\n\t\t\t\tdeepest.content = require('abbreviationUtils').insertChildContent(deepest.content, content);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * @param {AbbreviationNode} tree\n\t * @param {Object} options\n\t */\n\tparser.addPreprocessor(function(tree, options) {\n\t\tif (options.pastedContent) {\n\t\t\tvar utils = require('utils');\n\t\t\tvar lines = _.map(utils.splitByLines(options.pastedContent, true), utils.trim);\n\t\t\t\n\t\t\t// set repeat count for implicitly repeated elements before\n\t\t\t// tree is unrolled\n\t\t\ttree.findAll(function(item) {\n\t\t\t\tif (item.hasImplicitRepeat) {\n\t\t\t\t\titem.data('paste', lines);\n\t\t\t\t\treturn item.repeatCount = lines.length;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t});\n\t\n\t/**\n\t * @param {AbbreviationNode} tree\n\t * @param {Object} options\n\t */\n\tparser.addPostprocessor(function(tree, options) {\n\t\t// for each node with pasted content, update text data\n\t\tvar targets = tree.findAll(function(item) {\n\t\t\tvar pastedContentObj = item.data('paste');\n\t\t\tvar pastedContent = '';\n\t\t\tif (_.isArray(pastedContentObj)) {\n\t\t\t\tpastedContent = pastedContentObj[item.counter - 1];\n\t\t\t} else if (_.isFunction(pastedContentObj)) {\n\t\t\t\tpastedContent = pastedContentObj(item.counter - 1, item.content);\n\t\t\t} else if (pastedContentObj) {\n\t\t\t\tpastedContent = pastedContentObj;\n\t\t\t}\n\t\t\t\n\t\t\tif (pastedContent) {\n\t\t\t\tinsertPastedContent(item, pastedContent, !!item.data('pasteOverwrites'));\n\t\t\t}\n\t\t\t\n\t\t\titem.data('paste', null);\n\t\t\treturn !!pastedContentObj;\n\t\t});\n\t\t\n\t\tif (!targets.length && options.pastedContent) {\n\t\t\t// no implicitly repeated elements, put pasted content in\n\t\t\t// the deepest child\n\t\t\tinsertPastedContent(tree, options.pastedContent);\n\t\t}\n\t});\n});/**\n * Resolves tag names in abbreviations with implied name\n */\nemmet.exec(function(require, _) {\n\t/**\n\t * Resolves implicit node names in parsed tree\n\t * @param {AbbreviationNode} tree\n\t */\n\tfunction resolveNodeNames(tree) {\n\t\tvar tagName = require('tagName');\n\t\t_.each(tree.children, function(node) {\n\t\t\tif (node.hasImplicitName() || node.data('forceNameResolving')) {\n\t\t\t\tnode._name = tagName.resolve(node.parent.name());\n\t\t\t}\n\t\t\tresolveNodeNames(node);\n\t\t});\n\t\t\n\t\treturn tree;\n\t}\n\t\n\trequire('abbreviationParser').addPostprocessor(resolveNodeNames);\n});/**\n * @author Stoyan Stefanov\n * @link https://github.com/stoyan/etc/tree/master/cssex\n */\n\nemmet.define('cssParser', function(require, _) {\nvar walker, tokens = [], isOp, isNameChar, isDigit;\n    \n    // walks around the source\n    walker = {\n        lines: null,\n        total_lines: 0,\n        linenum: -1,\n        line: '',\n        ch: '',\n        chnum: -1,\n        init: function (source) {\n            var me = walker;\n        \n            // source, yumm\n            me.lines = source\n                .replace(/\\r\\n/g, '\\n')\n                .replace(/\\r/g, '\\n')\n                .split('\\n');\n            me.total_lines = me.lines.length;\n        \n            // reset\n            me.chnum = -1;\n            me.linenum = -1;\n            me.ch = '';\n            me.line = '';\n        \n            // advance\n            me.nextLine();\n            me.nextChar();\n        },\n        nextLine: function () {\n            var me = this;\n            me.linenum += 1;\n            if (me.total_lines <= me.linenum) {\n                me.line = false;\n            } else {\n                me.line = me.lines[me.linenum];\n            }\n            if (me.chnum !== -1) {\n                me.chnum = 0;\n            }\n            return me.line;\n        }, \n        nextChar: function () {\n            var me = this;\n            me.chnum += 1;\n            while (me.line.charAt(me.chnum) === '') {\n                if (this.nextLine() === false) {\n                    me.ch = false;\n                    return false; // end of source\n                }\n                me.chnum = -1;\n                me.ch = '\\n';\n                return '\\n';\n            }\n            me.ch = me.line.charAt(me.chnum);\n            return me.ch;\n        },\n        peek: function() {\n            return this.line.charAt(this.chnum + 1);\n        }\n    };\n\n    // utility helpers\n    isNameChar = function (c) {\n    \t// be more tolerate for name tokens: allow & character for LESS syntax\n        return (c == '&' || c === '_' || c === '-' || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'));\n    };\n\n    isDigit = function (ch) {\n        return (ch !== false && ch >= '0' && ch <= '9');\n    };  \n\n    isOp = (function () {\n        var opsa = \"{}[]()+*=.,;:>~|\\\\%$#@^!\".split(''),\n            opsmatcha = \"*^|$~\".split(''),\n            ops = {},\n            opsmatch = {},\n            i = 0;\n        for (; i < opsa.length; i += 1) {\n            ops[opsa[i]] = true;\n        }\n        for (i = 0; i < opsmatcha.length; i += 1) {\n            opsmatch[opsmatcha[i]] = true;\n        }\n        return function (ch, matchattr) {\n            if (matchattr) {\n                return !!opsmatch[ch];\n            }\n            return !!ops[ch];\n        };\n    }());\n    \n    // shorthands\n    function isset(v) {\n        return typeof v !== 'undefined';\n    }\n    function getConf() {\n        return {\n            'char': walker.chnum,\n            line: walker.linenum\n        };\n    }\n\n\n    // creates token objects and pushes them to a list\n    function tokener(value, type, conf) {\n        var w = walker, c = conf || {};\n        tokens.push({\n            charstart: isset(c['char']) ? c['char'] : w.chnum,\n            charend:   isset(c.charend) ? c.charend : w.chnum,\n            linestart: isset(c.line)    ? c.line    : w.linenum,\n            lineend:   isset(c.lineend) ? c.lineend : w.linenum,\n            value:     value,\n            type:      type || value\n        });\n    }\n    \n    // oops\n    function error(m, config) { \n        var w = walker,\n            conf = config || {},\n            c = isset(conf['char']) ? conf['char'] : w.chnum,\n            l = isset(conf.line) ? conf.line : w.linenum;\n        return {\n            name: \"ParseError\",\n            message: m + \" at line \" + (l + 1) + ' char ' + (c + 1),\n            walker: w,\n            tokens: tokens\n        };\n    }\n\n\n    // token handlers follow for:\n    // white space, comment, string, identifier, number, operator\n    function white() {\n    \n        var c = walker.ch,\n            token = '',\n            conf = getConf();\n    \n        while (c === \" \" || c === \"\\t\") {\n            token += c;\n            c = walker.nextChar();\n        }\n    \n        tokener(token, 'white', conf);\n    \n    }\n\n    function comment() {\n    \n        var w = walker,\n            c = w.ch,\n            token = c,\n            cnext,\n            conf = getConf();    \n     \n        cnext = w.nextChar();\n\n        if (cnext === '/') {\n            // inline comment in SCSS and such\n            token += cnext;\n            var pk = w.peek();\n            while (pk && pk !== '\\n') {\n                token += cnext;\n                cnext = w.nextChar();\n                pk = w.peek();\n            }\n        } else if (cnext === '*') {\n            // multiline CSS commment\n            while (!(c === \"*\" && cnext === \"/\")) {\n                token += cnext;\n                c = cnext;\n                cnext = w.nextChar();        \n            }            \n        } else {\n            // oops, not a comment, just a /\n            conf.charend = conf['char'];\n            conf.lineend = conf.line;\n            return tokener(token, token, conf);\n        }\n        \n        token += cnext;\n        w.nextChar();\n        tokener(token, 'comment', conf);\n    }\n\n    function str() {\n        var w = walker,\n            c = w.ch,\n            q = c,\n            token = c,\n            cnext,\n            conf = getConf();\n    \n        c = w.nextChar();\n    \n        while (c !== q) {\n            \n            if (c === '\\n') {\n                cnext = w.nextChar();\n                if (cnext === \"\\\\\") {\n                    token += c + cnext;\n                } else {\n                    // end of line with no \\ escape = bad\n                    throw error(\"Unterminated string\", conf);\n                }\n            } else {\n                if (c === \"\\\\\") {\n                    token += c + w.nextChar();\n                } else {\n                    token += c;\n                }\n            }\n        \n            c = w.nextChar();\n        \n        }\n        token += c;\n        w.nextChar();\n        tokener(token, 'string', conf);\n    }\n    \n    function brace() {\n        var w = walker,\n            c = w.ch,\n            depth = 0,\n            token = c,\n            conf = getConf();\n    \n        c = w.nextChar();\n    \n        while (c !== ')' && !depth) {\n        \tif (c === '(') {\n        \t\tdepth++;\n        \t} else if (c === ')') {\n        \t\tdepth--;\n        \t} else if (c === false) {\n        \t\tthrow error(\"Unterminated brace\", conf);\n        \t}\n        \t\n        \ttoken += c;\n            c = w.nextChar();\n        }\n        \n        token += c;\n        w.nextChar();\n        tokener(token, 'brace', conf);\n    }\n\n    function identifier(pre) {\n        var w = walker,\n            c = w.ch,\n            conf = getConf(),\n            token = (pre) ? pre + c : c;\n            \n        c = w.nextChar();\n    \n        if (pre) { // adjust token position\n        \tconf['char'] -= pre.length;\n        }\n        \n        while (isNameChar(c) || isDigit(c)) {\n            token += c;\n            c = w.nextChar();\n        }\n    \n        tokener(token, 'identifier', conf);    \n    }\n\n    function num() {\n        var w = walker,\n            c = w.ch,\n            conf = getConf(),\n            token = c,\n            point = token === '.',\n            nondigit;\n        \n        c = w.nextChar();\n        nondigit = !isDigit(c);\n    \n        // .2px or .classname?\n        if (point && nondigit) {\n            // meh, NaN, could be a class name, so it's an operator for now\n            conf.charend = conf['char'];\n            conf.lineend = conf.line;\n            return tokener(token, '.', conf);    \n        }\n        \n        // -2px or -moz-something\n        if (token === '-' && nondigit) {\n            return identifier('-');\n        }\n    \n        while (c !== false && (isDigit(c) || (!point && c === '.'))) { // not end of source && digit or first instance of .\n            if (c === '.') {\n                point = true;\n            }\n            token += c;\n            c = w.nextChar();\n        }\n\n        tokener(token, 'number', conf);    \n    \n    }\n\n    function op() {\n        var w = walker,\n            c = w.ch,\n            conf = getConf(),\n            token = c,\n            next = w.nextChar();\n            \n        if (next === \"=\" && isOp(token, true)) {\n            token += next;\n            tokener(token, 'match', conf);\n            w.nextChar();\n            return;\n        } \n        \n        conf.charend = conf['char'] + 1;\n        conf.lineend = conf.line;    \n        tokener(token, token, conf);\n    }\n\n\n    // call the appropriate handler based on the first character in a token suspect\n    function tokenize() {\n\n        var ch = walker.ch;\n    \n        if (ch === \" \" || ch === \"\\t\") {\n            return white();\n        }\n\n        if (ch === '/') {\n            return comment();\n        } \n\n        if (ch === '\"' || ch === \"'\") {\n            return str();\n        }\n        \n        if (ch === '(') {\n            return brace();\n        }\n    \n        if (ch === '-' || ch === '.' || isDigit(ch)) { // tricky - char: minus (-1px) or dash (-moz-stuff)\n            return num();\n        }\n    \n        if (isNameChar(ch)) {\n            return identifier();\n        }\n\n        if (isOp(ch)) {\n            return op();\n        }\n        \n        if (ch === \"\\n\") {\n            tokener(\"line\");\n            walker.nextChar();\n            return;\n        }\n        \n        throw error(\"Unrecognized character\");\n    }\n    \n    /**\n\t * Returns newline character at specified position in content\n\t * @param {String} content\n\t * @param {Number} pos\n\t * @return {String}\n\t */\n\tfunction getNewline(content, pos) {\n\t\treturn content.charAt(pos) == '\\r' && content.charAt(pos + 1) == '\\n' \n\t\t\t? '\\r\\n' \n\t\t\t: content.charAt(pos);\n\t}\n\n    return {\n    \t/**\n    \t * @param source\n    \t * @returns\n    \t * @memberOf emmet.cssParser\n    \t */\n        lex: function (source) {\n            walker.init(source);\n            tokens = [];\n            while (walker.ch !== false) {\n                tokenize();            \n            }\n            return tokens;\n        },\n        \n        /**\n         * Tokenizes CSS source\n         * @param {String} source\n         * @returns {Array}\n         */\n        parse: function(source) {\n        \t// transform tokens\n\t \t\tvar pos = 0;\n\t \t\treturn _.map(this.lex(source), function(token) {\n\t \t\t\tif (token.type == 'line') {\n\t \t\t\t\ttoken.value = getNewline(source, pos);\n\t \t\t\t}\n\t \t\t\t\n\t \t\t\treturn {\n\t \t\t\t\ttype: token.type,\n\t \t\t\t\tstart: pos,\n\t \t\t\t\tend: (pos += token.value.length)\n\t \t\t\t};\n\t\t\t});\n\t\t},\n        \n        toSource: function (toks) {\n            var i = 0, max = toks.length, t, src = '';\n            for (; i < max; i += 1) {\n                t = toks[i];\n                if (t.type === 'line') {\n                    src += '\\n';\n                } else {\n                    src += t.value;\n                }\n            }\n            return src;\n        }\n    };\n});/**\n * HTML tokenizer by Marijn Haverbeke\n * http://codemirror.net/\n * @constructor\n * @memberOf __xmlParseDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.define('xmlParser', function(require, _) {\n\tvar Kludges = {\n\t\tautoSelfClosers : {},\n\t\timplicitlyClosed : {},\n\t\tcontextGrabbers : {},\n\t\tdoNotIndent : {},\n\t\tallowUnquoted : true,\n\t\tallowMissing : true\n\t};\n\n\t// Return variables for tokenizers\n\tvar tagName = null, type = null;\n\n\tfunction inText(stream, state) {\n\t\tfunction chain(parser) {\n\t\t\tstate.tokenize = parser;\n\t\t\treturn parser(stream, state);\n\t\t}\n\n\t\tvar ch = stream.next();\n\t\tif (ch == \"<\") {\n\t\t\tif (stream.eat(\"!\")) {\n\t\t\t\tif (stream.eat(\"[\")) {\n\t\t\t\t\tif (stream.match(\"CDATA[\"))\n\t\t\t\t\t\treturn chain(inBlock(\"atom\", \"]]>\"));\n\t\t\t\t\telse\n\t\t\t\t\t\treturn null;\n\t\t\t\t} else if (stream.match(\"--\"))\n\t\t\t\t\treturn chain(inBlock(\"comment\", \"-->\"));\n\t\t\t\telse if (stream.match(\"DOCTYPE\", true, true)) {\n\t\t\t\t\tstream.eatWhile(/[\\w\\._\\-]/);\n\t\t\t\t\treturn chain(doctype(1));\n\t\t\t\t} else\n\t\t\t\t\treturn null;\n\t\t\t} else if (stream.eat(\"?\")) {\n\t\t\t\tstream.eatWhile(/[\\w\\._\\-]/);\n\t\t\t\tstate.tokenize = inBlock(\"meta\", \"?>\");\n\t\t\t\treturn \"meta\";\n\t\t\t} else {\n\t\t\t\ttype = stream.eat(\"/\") ? \"closeTag\" : \"openTag\";\n\t\t\t\tstream.eatSpace();\n\t\t\t\ttagName = \"\";\n\t\t\t\tvar c;\n\t\t\t\twhile ((c = stream.eat(/[^\\s\\u00a0=<>\\\"\\'\\/?]/)))\n\t\t\t\t\ttagName += c;\n\t\t\t\tstate.tokenize = inTag;\n\t\t\t\treturn \"tag\";\n\t\t\t}\n\t\t} else if (ch == \"&\") {\n\t\t\tvar ok;\n\t\t\tif (stream.eat(\"#\")) {\n\t\t\t\tif (stream.eat(\"x\")) {\n\t\t\t\t\tok = stream.eatWhile(/[a-fA-F\\d]/) && stream.eat(\";\");\n\t\t\t\t} else {\n\t\t\t\t\tok = stream.eatWhile(/[\\d]/) && stream.eat(\";\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tok = stream.eatWhile(/[\\w\\.\\-:]/) && stream.eat(\";\");\n\t\t\t}\n\t\t\treturn ok ? \"atom\" : \"error\";\n\t\t} else {\n\t\t\tstream.eatWhile(/[^&<]/);\n\t\t\treturn \"text\";\n\t\t}\n\t}\n\n\tfunction inTag(stream, state) {\n\t\tvar ch = stream.next();\n\t\tif (ch == \">\" || (ch == \"/\" && stream.eat(\">\"))) {\n\t\t\tstate.tokenize = inText;\n\t\t\ttype = ch == \">\" ? \"endTag\" : \"selfcloseTag\";\n\t\t\treturn \"tag\";\n\t\t} else if (ch == \"=\") {\n\t\t\ttype = \"equals\";\n\t\t\treturn null;\n\t\t} else if (/[\\'\\\"]/.test(ch)) {\n\t\t\tstate.tokenize = inAttribute(ch);\n\t\t\treturn state.tokenize(stream, state);\n\t\t} else {\n\t\t\tstream.eatWhile(/[^\\s\\u00a0=<>\\\"\\'\\/?]/);\n\t\t\treturn \"word\";\n\t\t}\n\t}\n\n\tfunction inAttribute(quote) {\n\t\treturn function(stream, state) {\n\t\t\twhile (!stream.eol()) {\n\t\t\t\tif (stream.next() == quote) {\n\t\t\t\t\tstate.tokenize = inTag;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn \"string\";\n\t\t};\n\t}\n\n\tfunction inBlock(style, terminator) {\n\t\treturn function(stream, state) {\n\t\t\twhile (!stream.eol()) {\n\t\t\t\tif (stream.match(terminator)) {\n\t\t\t\t\tstate.tokenize = inText;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstream.next();\n\t\t\t}\n\t\t\treturn style;\n\t\t};\n\t}\n\t\n\tfunction doctype(depth) {\n\t\treturn function(stream, state) {\n\t\t\tvar ch;\n\t\t\twhile ((ch = stream.next()) != null) {\n\t\t\t\tif (ch == \"<\") {\n\t\t\t\t\tstate.tokenize = doctype(depth + 1);\n\t\t\t\t\treturn state.tokenize(stream, state);\n\t\t\t\t} else if (ch == \">\") {\n\t\t\t\t\tif (depth == 1) {\n\t\t\t\t\t\tstate.tokenize = inText;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstate.tokenize = doctype(depth - 1);\n\t\t\t\t\t\treturn state.tokenize(stream, state);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn \"meta\";\n\t\t};\n\t}\n\n\tvar curState = null, setStyle;\n\tfunction pass() {\n\t\tfor (var i = arguments.length - 1; i >= 0; i--)\n\t\t\tcurState.cc.push(arguments[i]);\n\t}\n\t\n\tfunction cont() {\n\t\tpass.apply(null, arguments);\n\t\treturn true;\n\t}\n\n\tfunction pushContext(tagName, startOfLine) {\n\t\tvar noIndent = Kludges.doNotIndent.hasOwnProperty(tagName) \n\t\t\t|| (curState.context && curState.context.noIndent);\n\t\tcurState.context = {\n\t\t\tprev : curState.context,\n\t\t\ttagName : tagName,\n\t\t\tindent : curState.indented,\n\t\t\tstartOfLine : startOfLine,\n\t\t\tnoIndent : noIndent\n\t\t};\n\t}\n\t\n\tfunction popContext() {\n\t\tif (curState.context)\n\t\t\tcurState.context = curState.context.prev;\n\t}\n\n\tfunction element(type) {\n\t\tif (type == \"openTag\") {\n\t\t\tcurState.tagName = tagName;\n\t\t\treturn cont(attributes, endtag(curState.startOfLine));\n\t\t} else if (type == \"closeTag\") {\n\t\t\tvar err = false;\n\t\t\tif (curState.context) {\n\t\t\t\tif (curState.context.tagName != tagName) {\n\t\t\t\t\tif (Kludges.implicitlyClosed.hasOwnProperty(curState.context.tagName.toLowerCase())) {\n\t\t\t\t\t\tpopContext();\n\t\t\t\t\t}\n\t\t\t\t\terr = !curState.context || curState.context.tagName != tagName;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\terr = true;\n\t\t\t}\n\t\t\t\n\t\t\tif (err)\n\t\t\t\tsetStyle = \"error\";\n\t\t\treturn cont(endclosetag(err));\n\t\t}\n\t\treturn cont();\n\t}\n\t\n\tfunction endtag(startOfLine) {\n\t\treturn function(type) {\n\t\t\tif (type == \"selfcloseTag\"\n\t\t\t\t\t|| (type == \"endTag\" && Kludges.autoSelfClosers\n\t\t\t\t\t\t\t.hasOwnProperty(curState.tagName\n\t\t\t\t\t\t\t\t\t.toLowerCase()))) {\n\t\t\t\tmaybePopContext(curState.tagName.toLowerCase());\n\t\t\t\treturn cont();\n\t\t\t}\n\t\t\tif (type == \"endTag\") {\n\t\t\t\tmaybePopContext(curState.tagName.toLowerCase());\n\t\t\t\tpushContext(curState.tagName, startOfLine);\n\t\t\t\treturn cont();\n\t\t\t}\n\t\t\treturn cont();\n\t\t};\n\t}\n\t\n\tfunction endclosetag(err) {\n\t\treturn function(type) {\n\t\t\tif (err)\n\t\t\t\tsetStyle = \"error\";\n\t\t\tif (type == \"endTag\") {\n\t\t\t\tpopContext();\n\t\t\t\treturn cont();\n\t\t\t}\n\t\t\tsetStyle = \"error\";\n\t\t\treturn cont(arguments.callee);\n\t\t};\n\t}\n\t\n\tfunction maybePopContext(nextTagName) {\n\t\tvar parentTagName;\n\t\twhile (true) {\n\t\t\tif (!curState.context) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tparentTagName = curState.context.tagName.toLowerCase();\n\t\t\tif (!Kludges.contextGrabbers.hasOwnProperty(parentTagName)\n\t\t\t\t\t|| !Kludges.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tpopContext();\n\t\t}\n\t}\n\n\tfunction attributes(type) {\n\t\tif (type == \"word\") {\n\t\t\tsetStyle = \"attribute\";\n\t\t\treturn cont(attribute, attributes);\n\t\t}\n\t\tif (type == \"endTag\" || type == \"selfcloseTag\")\n\t\t\treturn pass();\n\t\tsetStyle = \"error\";\n\t\treturn cont(attributes);\n\t}\n\t\n\tfunction attribute(type) {\n\t\tif (type == \"equals\")\n\t\t\treturn cont(attvalue, attributes);\n\t\tif (!Kludges.allowMissing)\n\t\t\tsetStyle = \"error\";\n\t\treturn (type == \"endTag\" || type == \"selfcloseTag\") ? pass()\n\t\t\t\t: cont();\n\t}\n\t\n\tfunction attvalue(type) {\n\t\tif (type == \"string\")\n\t\t\treturn cont(attvaluemaybe);\n\t\tif (type == \"word\" && Kludges.allowUnquoted) {\n\t\t\tsetStyle = \"string\";\n\t\t\treturn cont();\n\t\t}\n\t\tsetStyle = \"error\";\n\t\treturn (type == \"endTag\" || type == \"selfCloseTag\") ? pass()\n\t\t\t\t: cont();\n\t}\n\t\n\tfunction attvaluemaybe(type) {\n\t\tif (type == \"string\")\n\t\t\treturn cont(attvaluemaybe);\n\t\telse\n\t\t\treturn pass();\n\t}\n\t\n\tfunction startState() {\n\t\treturn {\n\t\t\ttokenize : inText,\n\t\t\tcc : [],\n\t\t\tindented : 0,\n\t\t\tstartOfLine : true,\n\t\t\ttagName : null,\n\t\t\tcontext : null\n\t\t};\n\t}\n\t\n\tfunction token(stream, state) {\n\t\tif (stream.sol()) {\n\t\t\tstate.startOfLine = true;\n\t\t\tstate.indented = 0;\n\t\t}\n\t\t\n\t\tif (stream.eatSpace())\n\t\t\treturn null;\n\n\t\tsetStyle = type = tagName = null;\n\t\tvar style = state.tokenize(stream, state);\n\t\tstate.type = type;\n\t\tif ((style || type) && style != \"comment\") {\n\t\t\tcurState = state;\n\t\t\twhile (true) {\n\t\t\t\tvar comb = state.cc.pop() || element;\n\t\t\t\tif (comb(type || style))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tstate.startOfLine = false;\n\t\treturn setStyle || style;\n\t}\n\n\treturn {\n\t\t/**\n\t\t * @memberOf emmet.xmlParser\n\t\t * @returns\n\t\t */\n\t\tparse: function(data, offset) {\n\t\t\toffset = offset || 0;\n\t\t\tvar state = startState();\n\t\t\tvar stream = require('stringStream').create(data);\n\t\t\tvar tokens = [];\n\t\t\twhile (!stream.eol()) {\n\t\t\t\ttokens.push({\n\t\t\t\t\ttype: token(stream, state),\n\t\t\t\t\tstart: stream.start + offset,\n\t\t\t\t\tend: stream.pos + offset\n\t\t\t\t});\n\t\t\t\tstream.start = stream.pos;\n\t\t\t}\n\t\t\t\n\t\t\treturn tokens;\n\t\t}\t\t\n\t};\n});\n/*!\n * string_score.js: String Scoring Algorithm 0.1.10 \n *\n * http://joshaven.com/string_score\n * https://github.com/joshaven/string_score\n *\n * Copyright (C) 2009-2011 Joshaven Potter <yourtech@gmail.com>\n * Special thanks to all of the contributors listed here https://github.com/joshaven/string_score\n * MIT license: http://www.opensource.org/licenses/mit-license.php\n *\n * Date: Tue Mar 1 2011\n*/\n\n/**\n * Scores a string against another string.\n *  'Hello World'.score('he');     //=> 0.5931818181818181\n *  'Hello World'.score('Hello');  //=> 0.7318181818181818\n */\nemmet.define('string-score', function(require, _) {\n\treturn {\n\t\tscore: function(string, abbreviation, fuzziness) {\n\t\t\t// If the string is equal to the abbreviation, perfect match.\n\t\t\t  if (string == abbreviation) {return 1;}\n\t\t\t  //if it's not a perfect match and is empty return 0\n\t\t\t  if(abbreviation == \"\") {return 0;}\n\n\t\t\t  var total_character_score = 0,\n\t\t\t      abbreviation_length = abbreviation.length,\n\t\t\t      string_length = string.length,\n\t\t\t      start_of_string_bonus,\n\t\t\t      abbreviation_score,\n\t\t\t      fuzzies=1,\n\t\t\t      final_score;\n\t\t\t  \n\t\t\t  // Walk through abbreviation and add up scores.\n\t\t\t  for (var i = 0,\n\t\t\t         character_score/* = 0*/,\n\t\t\t         index_in_string/* = 0*/,\n\t\t\t         c/* = ''*/,\n\t\t\t         index_c_lowercase/* = 0*/,\n\t\t\t         index_c_uppercase/* = 0*/,\n\t\t\t         min_index/* = 0*/;\n\t\t\t     i < abbreviation_length;\n\t\t\t     ++i) {\n\t\t\t    \n\t\t\t    // Find the first case-insensitive match of a character.\n\t\t\t    c = abbreviation.charAt(i);\n\t\t\t    \n\t\t\t    index_c_lowercase = string.indexOf(c.toLowerCase());\n\t\t\t    index_c_uppercase = string.indexOf(c.toUpperCase());\n\t\t\t    min_index = Math.min(index_c_lowercase, index_c_uppercase);\n\t\t\t    index_in_string = (min_index > -1) ? min_index : Math.max(index_c_lowercase, index_c_uppercase);\n\t\t\t    \n\t\t\t    if (index_in_string === -1) { \n\t\t\t      if (fuzziness) {\n\t\t\t        fuzzies += 1-fuzziness;\n\t\t\t        continue;\n\t\t\t      } else {\n\t\t\t        return 0;\n\t\t\t      }\n\t\t\t    } else {\n\t\t\t      character_score = 0.1;\n\t\t\t    }\n\t\t\t    \n\t\t\t    // Set base score for matching 'c'.\n\t\t\t    \n\t\t\t    // Same case bonus.\n\t\t\t    if (string[index_in_string] === c) { \n\t\t\t      character_score += 0.1; \n\t\t\t    }\n\t\t\t    \n\t\t\t    // Consecutive letter & start-of-string Bonus\n\t\t\t    if (index_in_string === 0) {\n\t\t\t      // Increase the score when matching first character of the remainder of the string\n\t\t\t      character_score += 0.6;\n\t\t\t      if (i === 0) {\n\t\t\t        // If match is the first character of the string\n\t\t\t        // & the first character of abbreviation, add a\n\t\t\t        // start-of-string match bonus.\n\t\t\t        start_of_string_bonus = 1; //true;\n\t\t\t      }\n\t\t\t    }\n\t\t\t    else {\n\t\t\t  // Acronym Bonus\n\t\t\t  // Weighing Logic: Typing the first character of an acronym is as if you\n\t\t\t  // preceded it with two perfect character matches.\n\t\t\t  if (string.charAt(index_in_string - 1) === ' ') {\n\t\t\t    character_score += 0.8; // * Math.min(index_in_string, 5); // Cap bonus at 0.4 * 5\n\t\t\t  }\n\t\t\t    }\n\t\t\t    \n\t\t\t    // Left trim the already matched part of the string\n\t\t\t    // (forces sequential matching).\n\t\t\t    string = string.substring(index_in_string + 1, string_length);\n\t\t\t    \n\t\t\t    total_character_score += character_score;\n\t\t\t  } // end of for loop\n\t\t\t  \n\t\t\t  // Uncomment to weigh smaller words higher.\n\t\t\t  // return total_character_score / string_length;\n\t\t\t  \n\t\t\t  abbreviation_score = total_character_score / abbreviation_length;\n\t\t\t  //percentage_of_matched_string = abbreviation_length / string_length;\n\t\t\t  //word_score = abbreviation_score * percentage_of_matched_string;\n\t\t\t  \n\t\t\t  // Reduce penalty for longer strings.\n\t\t\t  //final_score = (word_score + abbreviation_score) / 2;\n\t\t\t  final_score = ((abbreviation_score * (abbreviation_length / string_length)) + abbreviation_score) / 2;\n\t\t\t  \n\t\t\t  final_score = final_score / fuzzies;\n\t\t\t  \n\t\t\t  if (start_of_string_bonus && (final_score + 0.15 < 1)) {\n\t\t\t    final_score += 0.15;\n\t\t\t  }\n\t\t\t  \n\t\t\t  return final_score;\n\t\t}\n\t};\n});/**\n * Utility module for Emmet\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.define('utils', function(require, _) {\n\t/** \n\t * Special token used as a placeholder for caret positions inside \n\t * generated output \n\t */\n\tvar caretPlaceholder = '${0}';\n\t\n\t/**\n\t * A simple string builder, optimized for faster text concatenation\n\t * @param {String} value Initial value\n\t */\n\tfunction StringBuilder(value) {\n\t\tthis._data = [];\n\t\tthis.length = 0;\n\t\t\n\t\tif (value)\n\t\t\tthis.append(value);\n\t}\n\t\n\tStringBuilder.prototype = {\n\t\t/**\n\t\t * Append string\n\t\t * @param {String} text\n\t\t */\n\t\tappend: function(text) {\n\t\t\tthis._data.push(text);\n\t\t\tthis.length += text.length;\n\t\t},\n\t\t\n\t\t/**\n\t\t * @returns {String}\n\t\t */\n\t\ttoString: function() {\n\t\t\treturn this._data.join('');\n\t\t},\n\t\t\n\t\t/**\n\t\t * @returns {String}\n\t\t */\n\t\tvalueOf: function() {\n\t\t\treturn this.toString();\n\t\t}\n\t};\n\t\n\treturn {\n\t\t/** @memberOf utils */\n\t\treTag: /<\\/?[\\w:\\-]+(?:\\s+[\\w\\-:]+(?:\\s*=\\s*(?:(?:\"[^\"]*\")|(?:'[^']*')|[^>\\s]+))?)*\\s*(\\/?)>$/,\n\t\t\n\t\t/**\n\t\t * Test if passed string ends with XHTML tag. This method is used for testing\n\t\t * '>' character: it belongs to tag or it's a part of abbreviation? \n\t\t * @param {String} str\n\t\t * @return {Boolean}\n\t\t */\n\t\tendsWithTag: function(str) {\n\t\t\treturn this.reTag.test(str);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if passed symbol is a number\n\t\t * @param {String} ch\n\t\t * @returns {Boolean}\n\t\t */\n\t\tisNumeric: function(ch) {\n\t\t\tif (typeof(ch) == 'string')\n\t\t\t\tch = ch.charCodeAt(0);\n\t\t\t\t\n\t\t\treturn (ch && ch > 47 && ch < 58);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Trim whitespace from string\n\t\t * @param {String} text\n\t\t * @return {String}\n\t\t */\n\t\ttrim: function(text) {\n\t\t\treturn (text || \"\").replace(/^\\s+|\\s+$/g, \"\");\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns newline character\n\t\t * @returns {String}\n\t\t */\n\t\tgetNewline: function() {\n\t\t\tvar res = require('resources');\n\t\t\tif (!res) {\n\t\t\t\treturn '\\n';\n\t\t\t}\n\t\t\t\n\t\t\tvar nl = res.getVariable('newline');\n\t\t\treturn _.isString(nl) ? nl : '\\n';\n\t\t},\n\t\t\n\t\t/**\n\t\t * Sets new newline character that will be used in output\n\t\t * @param {String} str\n\t\t */\n\t\tsetNewline: function(str) {\n\t\t\tvar res = require('resources');\n\t\t\tres.setVariable('newline', str);\n\t\t\tres.setVariable('nl', str);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Split text into lines. Set <code>remove_empty</code> to true to filter\n\t\t * empty lines\n\t\t * @param {String} text Text to split\n\t\t * @param {Boolean} removeEmpty Remove empty lines from result\n\t\t * @return {Array}\n\t\t */\n\t\tsplitByLines: function(text, removeEmpty) {\n\t\t\t// IE fails to split string by regexp, \n\t\t\t// need to normalize newlines first\n\t\t\t// Also, Mozilla's Rhiho JS engine has a weird newline bug\n\t\t\tvar nl = this.getNewline();\n\t\t\tvar lines = (text || '')\n\t\t\t\t.replace(/\\r\\n/g, '\\n')\n\t\t\t\t.replace(/\\n\\r/g, '\\n')\n\t\t\t\t.replace(/\\r/g, '\\n')\n\t\t\t\t.replace(/\\n/g, nl)\n\t\t\t\t.split(nl);\n\t\t\t\n\t\t\tif (removeEmpty) {\n\t\t\t\tlines = _.filter(lines, function(line) {\n\t\t\t\t\treturn line.length && !!this.trim(line);\n\t\t\t\t}, this);\n\t\t\t}\n\t\t\t\n\t\t\treturn lines;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Normalizes newline character: replaces newlines in <code>text</code> \n\t\t * with newline defined in preferences\n\t\t * @param {String} text\n\t\t * @returns {String}\n\t\t */\n\t\tnormalizeNewline: function(text) {\n\t\t\treturn this.splitByLines(text).join(this.getNewline());\n\t\t},\n\t\t\n\t\t/**\n\t\t * Repeats string <code>howMany</code> times\n\t\t * @param {String} str\n\t\t * @param {Number} how_many\n\t\t * @return {String}\n\t\t */\n\t\trepeatString: function(str, howMany) {\n\t\t\tvar result = [];\n\t\t\t\n\t\t\tfor (var i = 0; i < howMany; i++) \n\t\t\t\tresult.push(str);\n\t\t\t\t\n\t\t\treturn result.join('');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns list of paddings that should be used to align passed string\n\t\t * @param {Array} strings\n\t\t * @returns {Array}\n\t\t */\n\t\tgetStringsPads: function(strings) {\n\t\t\tvar lengths = _.map(strings, function(s) {\n\t\t\t\treturn _.isString(s) ? s.length : +s;\n\t\t\t});\n\t\t\t\n\t\t\tvar max = _.max(lengths);\n\t\t\treturn _.map(lengths, function(l) {\n\t\t\t\tvar pad = max - l;\n\t\t\t\treturn pad ? this.repeatString(' ', pad) : '';\n\t\t\t}, this);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Indents text with padding\n\t\t * @param {String} text Text to indent\n\t\t * @param {String} pad Padding size (number) or padding itself (string)\n\t\t * @return {String}\n\t\t */\n\t\tpadString: function(text, pad) {\n\t\t\tvar padStr = (_.isNumber(pad)) \n\t\t\t\t? this.repeatString(require('resources').getVariable('indentation') || '\\t', pad) \n\t\t\t\t: pad;\n\t\t\t\t\n\t\t\tvar result = [];\n\t\t\t\n\t\t\tvar lines = this.splitByLines(text);\n\t\t\tvar nl = this.getNewline();\n\t\t\t\t\n\t\t\tresult.push(lines[0]);\n\t\t\tfor (var j = 1; j < lines.length; j++) \n\t\t\t\tresult.push(nl + padStr + lines[j]);\n\t\t\t\t\n\t\t\treturn result.join('');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Pad string with zeroes\n\t\t * @param {String} str String to pad\n\t\t * @param {Number} pad Desired string length\n\t\t * @return {String}\n\t\t */\n\t\tzeroPadString: function(str, pad) {\n\t\t\tvar padding = '';\n\t\t\tvar il = str.length;\n\t\t\t\t\n\t\t\twhile (pad > il++) padding += '0';\n\t\t\treturn padding + str; \n\t\t},\n\t\t\n\t\t/**\n\t\t * Removes padding at the beginning of each text's line\n\t\t * @param {String} text\n\t\t * @param {String} pad\n\t\t */\n\t\tunindentString: function(text, pad) {\n\t\t\tvar lines = this.splitByLines(text);\n\t\t\tfor (var i = 0; i < lines.length; i++) {\n\t\t\t\tif (lines[i].search(pad) == 0)\n\t\t\t\t\tlines[i] = lines[i].substr(pad.length);\n\t\t\t}\n\t\t\t\n\t\t\treturn lines.join(this.getNewline());\n\t\t},\n\t\t\n\t\t/**\n\t\t * Replaces unescaped symbols in <code>str</code>. For example, the '$' symbol\n\t\t * will be replaced in 'item$count', but not in 'item\\$count'.\n\t\t * @param {String} str Original string\n\t\t * @param {String} symbol Symbol to replace\n\t\t * @param {String} replace Symbol replacement. Might be a function that \n\t\t * returns new value\n\t\t * @return {String}\n\t\t */\n\t\treplaceUnescapedSymbol: function(str, symbol, replace) {\n\t\t\tvar i = 0;\n\t\t\tvar il = str.length;\n\t\t\tvar sl = symbol.length;\n\t\t\tvar matchCount = 0;\n\t\t\t\t\n\t\t\twhile (i < il) {\n\t\t\t\tif (str.charAt(i) == '\\\\') {\n\t\t\t\t\t// escaped symbol, skip next character\n\t\t\t\t\ti += sl + 1;\n\t\t\t\t} else if (str.substr(i, sl) == symbol) {\n\t\t\t\t\t// have match\n\t\t\t\t\tvar curSl = sl;\n\t\t\t\t\tmatchCount++;\n\t\t\t\t\tvar newValue = replace;\n\t\t\t\t\tif (_.isFunction(replace)) {\n\t\t\t\t\t\tvar replaceData = replace(str, symbol, i, matchCount);\n\t\t\t\t\t\tif (replaceData) {\n\t\t\t\t\t\t\tcurSl = replaceData[0].length;\n\t\t\t\t\t\t\tnewValue = replaceData[1];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnewValue = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (newValue === false) { // skip replacement\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tstr = str.substring(0, i) + newValue + str.substring(i + curSl);\n\t\t\t\t\t// adjust indexes\n\t\t\t\t\til = str.length;\n\t\t\t\t\ti += newValue.length;\n\t\t\t\t} else {\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn str;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Replace variables like ${var} in string\n\t\t * @param {String} str\n\t\t * @param {Object} vars Variable set (defaults to variables defined in \n\t\t * <code>snippets.json</code>) or variable resolver (<code>Function</code>)\n\t\t * @return {String}\n\t\t */\n\t\treplaceVariables: function(str, vars) {\n\t\t\tvars = vars || {};\n\t\t\tvar resolver = _.isFunction(vars) ? vars : function(str, p1) {\n\t\t\t\treturn p1 in vars ? vars[p1] : null;\n\t\t\t};\n\t\t\t\n\t\t\tvar res = require('resources');\n\t\t\treturn require('tabStops').processText(str, {\n\t\t\t\tvariable: function(data) {\n\t\t\t\t\tvar newValue = resolver(data.token, data.name, data);\n\t\t\t\t\tif (newValue === null) {\n\t\t\t\t\t\t// try to find variable in resources\n\t\t\t\t\t\tnewValue = res.getVariable(data.name);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (newValue === null || _.isUndefined(newValue))\n\t\t\t\t\t\t// nothing found, return token itself\n\t\t\t\t\t\tnewValue = data.token;\n\t\t\t\t\treturn newValue;\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Replaces '$' character in string assuming it might be escaped with '\\'\n\t\t * @param {String} str String where character should be replaced\n\t\t * @param {String} value New value\n\t\t * @return {String}\n\t\t */\n\t\treplaceCounter: function(str, value, total) {\n\t\t\tvar symbol = '$';\n\t\t\t// in case we received strings from Java, convert the to native strings\n\t\t\tstr = String(str);\n\t\t\tvalue = String(value);\n\t\t\t\n\t\t\tif (/^\\-?\\d+$/.test(value)) {\n\t\t\t\tvalue = +value;\n\t\t\t}\n\t\t\t\n\t\t\tvar that = this;\n\t\t\t\n\t\t\treturn this.replaceUnescapedSymbol(str, symbol, function(str, symbol, pos, matchNum){\n\t\t\t\tif (str.charAt(pos + 1) == '{' || that.isNumeric(str.charAt(pos + 1)) ) {\n\t\t\t\t\t// it's a variable, skip it\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// replace sequense of $ symbols with padded number  \n\t\t\t\tvar j = pos + 1;\n\t\t\t\twhile(str.charAt(j) == '$' && str.charAt(j + 1) != '{') j++;\n\t\t\t\tvar pad = j - pos;\n\t\t\t\t\n\t\t\t\t// get counter base\n\t\t\t\tvar base = 0, decrement = false, m;\n\t\t\t\tif (m = str.substr(j).match(/^@(\\-?)(\\d*)/)) {\n\t\t\t\t\tj += m[0].length;\n\t\t\t\t\t\n\t\t\t\t\tif (m[1]) {\n\t\t\t\t\t\tdecrement = true;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tbase = parseInt(m[2] || 1) - 1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (decrement && total && _.isNumber(value)) {\n\t\t\t\t\tvalue = total - value + 1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvalue += base;\n\t\t\t\t\n\t\t\t\treturn [str.substring(pos, j), that.zeroPadString(value + '', pad)];\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if string matches against <code>reTag</code> regexp. This \n\t\t * function may be used to test if provided string contains HTML tags\n\t\t * @param {String} str\n\t\t * @returns {Boolean}\n\t\t */\n\t\tmatchesTag: function(str) {\n\t\t\treturn this.reTag.test(str || '');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Escapes special characters used in Emmet, like '$', '|', etc.\n\t\t * Use this method before passing to actions like \"Wrap with Abbreviation\"\n\t\t * to make sure that existing special characters won't be altered\n\t\t * @param {String} text\n\t\t * @return {String}\n\t\t */\n\t\tescapeText: function(text) {\n\t\t\treturn text.replace(/([\\$\\\\])/g, '\\\\$1');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Unescapes special characters used in Emmet, like '$', '|', etc.\n\t\t * @param {String} text\n\t\t * @return {String}\n\t\t */\n\t\tunescapeText: function(text) {\n\t\t\treturn text.replace(/\\\\(.)/g, '$1');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns caret placeholder\n\t\t * @returns {String}\n\t\t */\n\t\tgetCaretPlaceholder: function() {\n\t\t\treturn _.isFunction(caretPlaceholder) \n\t\t\t\t? caretPlaceholder.apply(this, arguments)\n\t\t\t\t: caretPlaceholder;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Sets new representation for carets in generated output\n\t\t * @param {String} value New caret placeholder. Might be a \n\t\t * <code>Function</code>\n\t\t */\n\t\tsetCaretPlaceholder: function(value) {\n\t\t\tcaretPlaceholder = value;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns line padding\n\t\t * @param {String} line\n\t\t * @return {String}\n\t\t */\n\t\tgetLinePadding: function(line) {\n\t\t\treturn (line.match(/^(\\s+)/) || [''])[0];\n\t\t},\n\t\t\n\t\t/**\n\t\t * Helper function that returns padding of line of <code>pos</code>\n\t\t * position in <code>content</code>\n\t\t * @param {String} content\n\t\t * @param {Number} pos\n\t\t * @returns {String}\n\t\t */\n\t\tgetLinePaddingFromPosition: function(content, pos) {\n\t\t\tvar lineRange = this.findNewlineBounds(content, pos);\n\t\t\treturn this.getLinePadding(lineRange.substring(content));\n\t\t},\n\t\t\n\t\t/**\n\t\t * Escape special regexp chars in string, making it usable for creating dynamic\n\t\t * regular expressions\n\t\t * @param {String} str\n\t\t * @return {String}\n\t\t */\n\t\tescapeForRegexp: function(str) {\n\t\t\tvar specials = new RegExp(\"[.*+?|()\\\\[\\\\]{}\\\\\\\\]\", \"g\"); // .*+?|()[]{}\\\n\t\t\treturn str.replace(specials, \"\\\\$&\");\n\t\t},\n\t\t\n\t\t/**\n\t\t * Make decimal number look good: convert it to fixed precision end remove\n\t\t * traling zeroes \n\t\t * @param {Number} num\n\t\t * @param {Number} fracion Fraction numbers (default is 2)\n\t\t * @return {String}\n\t\t */\n\t\tprettifyNumber: function(num, fraction) {\n\t\t\treturn num.toFixed(typeof fraction == 'undefined' ? 2 : fraction).replace(/\\.?0+$/, '');\n\t\t},\n\t\t\n\t\t/**\n\t\t * A simple mutable string shim, optimized for faster text concatenation\n\t\t * @param {String} value Initial value\n\t\t * @returns {StringBuilder}\n\t\t */\n\t\tstringBuilder: function(value) {\n\t\t\treturn new StringBuilder(value);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Replace substring of <code>str</code> with <code>value</code>\n\t\t * @param {String} str String where to replace substring\n\t\t * @param {String} value New substring value\n\t\t * @param {Number} start Start index of substring to replace. May also\n\t\t * be a <code>Range</code> object: in this case, the <code>end</code>\n\t\t * argument is not required\n\t\t * @param {Number} end End index of substring to replace. If ommited, \n\t\t * <code>start</code> argument is used\n\t\t */\n\t\treplaceSubstring: function(str, value, start, end) {\n\t\t\tif (_.isObject(start) && 'end' in start) {\n\t\t\t\tend = start.end;\n\t\t\t\tstart = start.start;\n\t\t\t}\n\t\t\t\n\t\t\tif (_.isString(end))\n\t\t\t\tend = start + end.length;\n\t\t\t\n\t\t\tif (_.isUndefined(end))\n\t\t\t\tend = start;\n\t\t\t\n\t\t\tif (start < 0 || start > str.length)\n\t\t\t\treturn str;\n\t\t\t\n\t\t\treturn str.substring(0, start) + value + str.substring(end);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Narrows down text range, adjusting selection to non-space characters\n\t\t * @param {String} text\n\t\t * @param {Number} start Starting range in <code>text</code> where \n\t\t * slection should be adjusted. Can also be any object that is accepted\n\t\t * by <code>Range</code> class\n\t\t * @return {Range}\n\t\t */\n\t\tnarrowToNonSpace: function(text, start, end) {\n\t\t\tvar range = require('range').create(start, end);\n\t\t\t\n\t\t\tvar reSpace = /[\\s\\n\\r\\u00a0]/;\n\t\t\t// narrow down selection until first non-space character\n\t\t\twhile (range.start < range.end) {\n\t\t\t\tif (!reSpace.test(text.charAt(range.start)))\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\trange.start++;\n\t\t\t}\n\t\t\t\n\t\t\twhile (range.end > range.start) {\n\t\t\t\trange.end--;\n\t\t\t\tif (!reSpace.test(text.charAt(range.end))) {\n\t\t\t\t\trange.end++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn range;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Find start and end index of text line for <code>from</code> index\n\t\t * @param {String} text \n\t\t * @param {Number} from\n\t\t */\n\t\tfindNewlineBounds: function(text, from) {\n\t\t\tvar len = text.length,\n\t\t\t\tstart = 0,\n\t\t\t\tend = len - 1;\n\t\t\t\n\t\t\t// search left\n\t\t\tfor (var i = from - 1; i > 0; i--) {\n\t\t\t\tvar ch = text.charAt(i);\n\t\t\t\tif (ch == '\\n' || ch == '\\r') {\n\t\t\t\t\tstart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// search right\n\t\t\tfor (var j = from; j < len; j++) {\n\t\t\t\tvar ch = text.charAt(j);\n\t\t\t\tif (ch == '\\n' || ch == '\\r') {\n\t\t\t\t\tend = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn require('range').create(start, end - start);\n\t\t},\n\n\t\t/**\n\t\t * Deep merge of two or more objects. Taken from jQuery.extend()\n\t\t */\n\t\tdeepMerge: function() {\n\t\t\tvar options, name, src, copy, copyIsArray, clone,\n\t\t\t\ttarget = arguments[0] || {},\n\t\t\t\ti = 1,\n\t\t\t\tlength = arguments.length;\n\n\n\t\t\t// Handle case when target is a string or something (possible in deep copy)\n\t\t\tif (!_.isObject(target) && !_.isFunction(target)) {\n\t\t\t\ttarget = {};\n\t\t\t}\n\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t// Only deal with non-null/undefined values\n\t\t\t\tif ( (options = arguments[ i ]) != null ) {\n\t\t\t\t\t// Extend the base object\n\t\t\t\t\tfor ( name in options ) {\n\t\t\t\t\t\tsrc = target[ name ];\n\t\t\t\t\t\tcopy = options[ name ];\n\n\t\t\t\t\t\t// Prevent never-ending loop\n\t\t\t\t\t\tif ( target === copy ) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\t\t\tif ( copy && ( _.isObject(copy) || (copyIsArray = _.isArray(copy)) ) ) {\n\t\t\t\t\t\t\tif ( copyIsArray ) {\n\t\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\t\tclone = src && _.isArray(src) ? src : [];\n\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tclone = src && _.isObject(src) ? src : {};\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\t\ttarget[ name ] = this.deepMerge(clone, copy );\n\n\t\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Return the modified object\n\t\t\treturn target;\n\t\t}\n\t};\n});\n/**\n * Helper module to work with ranges\n * @constructor\n * @memberOf __rangeDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.define('range', function(require, _) {\n\tfunction cmp(a, b, op) {\n\t\tswitch (op) {\n\t\t\tcase 'eq':\n\t\t\tcase '==':\n\t\t\t\treturn a === b;\n\t\t\tcase 'lt':\n\t\t\tcase '<':\n\t\t\t\treturn a < b;\n\t\t\tcase 'lte':\n\t\t\tcase '<=':\n\t\t\t\treturn a <= b;\n\t\t\tcase 'gt':\n\t\t\tcase '>':\n\t\t\t\treturn a > b;\n\t\t\tcase 'gte':\n\t\t\tcase '>=':\n\t\t\t\treturn a >= b;\n\t\t}\n\t}\n\t\n\t\n\t/**\n\t * @type Range\n\t * @constructor\n\t * @param {Object} start\n\t * @param {Number} len\n\t */\n\tfunction Range(start, len) {\n\t\tif (_.isObject(start) && 'start' in start) {\n\t\t\t// create range from object stub\n\t\t\tthis.start = Math.min(start.start, start.end);\n\t\t\tthis.end = Math.max(start.start, start.end);\n\t\t} else if (_.isArray(start)) {\n\t\t\tthis.start = start[0];\n\t\t\tthis.end = start[1];\n\t\t} else {\n\t\t\tlen = _.isString(len) ? len.length : +len;\n\t\t\tthis.start = start;\n\t\t\tthis.end = start + len;\n\t\t}\n\t}\n\t\n\tRange.prototype = {\n\t\tlength: function() {\n\t\t\treturn Math.abs(this.end - this.start);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns <code>true</code> if passed range is equals to current one\n\t\t * @param {Range} range\n\t\t * @returns {Boolean}\n\t\t */\n\t\tequal: function(range) {\n\t\t\treturn this.cmp(range, 'eq', 'eq');\n//\t\t\treturn this.start === range.start && this.end === range.end;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Shifts indexes position with passed <code>delat</code>\n\t\t * @param {Number} delta\n\t\t * @returns {Range} range itself\n\t\t */\n\t\tshift: function(delta) {\n\t\t\tthis.start += delta;\n\t\t\tthis.end += delta;\n\t\t\treturn this;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if two ranges are overlapped\n\t\t * @param {Range} range\n\t\t * @returns {Boolean}\n\t\t */\n\t\toverlap: function(range) {\n\t\t\treturn range.start <= this.end && range.end >= this.start;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Finds intersection of two ranges\n\t\t * @param {Range} range\n\t\t * @returns {Range} <code>null</code> if ranges does not overlap\n\t\t */\n\t\tintersection: function(range) {\n\t\t\tif (this.overlap(range)) {\n\t\t\t\tvar start = Math.max(range.start, this.start);\n\t\t\t\tvar end = Math.min(range.end, this.end);\n\t\t\t\treturn new Range(start, end - start);\n\t\t\t}\n\t\t\t\n\t\t\treturn null;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns the union of the thow ranges.\n\t\t * @param {Range} range\n\t\t * @returns {Range} <code>null</code> if ranges are not overlapped\n\t\t */\n\t\tunion: function(range) {\n\t\t\tif (this.overlap(range)) {\n\t\t\t\tvar start = Math.min(range.start, this.start);\n\t\t\t\tvar end = Math.max(range.end, this.end);\n\t\t\t\treturn new Range(start, end - start);\n\t\t\t}\n\t\t\t\n\t\t\treturn null;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns a Boolean value that indicates whether a specified position \n\t\t * is in a given range.\n\t\t * @param {Number} loc\n\t\t */\n\t\tinside: function(loc) {\n\t\t\treturn this.cmp(loc, 'lte', 'gt');\n//\t\t\treturn this.start <= loc && this.end > loc;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns a Boolean value that indicates whether a specified position \n\t\t * is in a given range, but not equals bounds.\n\t\t * @param {Number} loc\n\t\t */\n\t\tcontains: function(loc) {\n\t\t\treturn this.cmp(loc, 'lt', 'gt');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if current range completely includes specified one\n\t\t * @param {Range} r\n\t\t * @returns {Boolean} \n\t\t */\n\t\tinclude: function(r) {\n\t\t\treturn this.cmp(loc, 'lte', 'gte');\n//\t\t\treturn this.start <= r.start && this.end >= r.end;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Low-level comparision method\n\t\t * @param {Number} loc\n\t\t * @param {String} left Left comparison operator\n\t\t * @param {String} right Right comaprison operator\n\t\t */\n\t\tcmp: function(loc, left, right) {\n\t\t\tvar a, b;\n\t\t\tif (loc instanceof Range) {\n\t\t\t\ta = loc.start;\n\t\t\t\tb = loc.end;\n\t\t\t} else {\n\t\t\t\ta = b = loc;\n\t\t\t}\n\t\t\t\n\t\t\treturn cmp(this.start, a, left || '<=') && cmp(this.end, b, right || '>');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns substring of specified <code>str</code> for current range\n\t\t * @param {String} str\n\t\t * @returns {String}\n\t\t */\n\t\tsubstring: function(str) {\n\t\t\treturn this.length() > 0 \n\t\t\t\t? str.substring(this.start, this.end) \n\t\t\t\t: '';\n\t\t},\n\t\t\n\t\t/**\n\t\t * Creates copy of current range\n\t\t * @returns {Range}\n\t\t */\n\t\tclone: function() {\n\t\t\treturn new Range(this.start, this.length());\n\t\t},\n\t\t\n\t\t/**\n\t\t * @returns {Array}\n\t\t */\n\t\ttoArray: function() {\n\t\t\treturn [this.start, this.end];\n\t\t},\n\t\t\n\t\ttoString: function() {\n\t\t\treturn '{' + this.start + ', ' + this.length() + '}';\n\t\t}\n\t};\n\t\n\treturn {\n\t\t/**\n\t\t * Creates new range object instance\n\t\t * @param {Object} start Range start or array with 'start' and 'end'\n\t\t * as two first indexes or object with 'start' and 'end' properties\n\t\t * @param {Number} len Range length or string to produce range from\n\t\t * @returns {Range}\n\t\t * @memberOf emmet.range\n\t\t */\n\t\tcreate: function(start, len) {\n\t\t\tif (_.isUndefined(start) || start === null)\n\t\t\t\treturn null;\n\t\t\t\n\t\t\tif (start instanceof Range)\n\t\t\t\treturn start;\n\t\t\t\n\t\t\tif (_.isObject(start) && 'start' in start && 'end' in start) {\n\t\t\t\tlen = start.end - start.start;\n\t\t\t\tstart = start.start;\n\t\t\t}\n\t\t\t\t\n\t\t\treturn new Range(start, len);\n\t\t},\n\t\t\n\t\t/**\n\t\t * <code>Range</code> object factory, the same as <code>this.create()</code>\n\t\t * but last argument represents end of range, not length\n\t\t * @returns {Range}\n\t\t */\n\t\tcreate2: function(start, end) {\n\t\t\tif (_.isNumber(start) && _.isNumber(end)) {\n\t\t\t\tend -= start;\n\t\t\t}\n\t\t\t\n\t\t\treturn this.create(start, end);\n\t\t}\n\t};\n});/**\n * Utility module that provides ordered storage of function handlers. \n * Many Emmet modules' functionality can be extended/overridden by custom\n * function. This modules provides unified storage of handler functions, their \n * management and execution\n * \n * @constructor\n * @memberOf __handlerListDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.define('handlerList', function(require, _) {\n\t/**\n\t * @type HandlerList\n\t * @constructor\n\t */\n\tfunction HandlerList() {\n\t\tthis._list = [];\n\t}\n\t\n\tHandlerList.prototype = {\n\t\t/**\n\t\t * Adds function handler\n\t\t * @param {Function} fn Handler\n\t\t * @param {Object} options Handler options. Possible values are:<br><br>\n\t\t * <b>order</b> : (<code>Number</code>) – order in handler list. Handlers\n\t\t * with higher order value will be executed earlier.\n\t\t */\n\t\tadd: function(fn, options) {\n\t\t\tthis._list.push(_.extend({order: 0}, options || {}, {fn: fn}));\n\t\t},\n\t\t\n\t\t/**\n\t\t * Removes handler from list\n\t\t * @param {Function} fn\n\t\t */\n\t\tremove: function(fn) {\n\t\t\tthis._list = _.without(this._list, _.find(this._list, function(item) {\n\t\t\t\treturn item.fn === fn;\n\t\t\t}));\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns ordered list of handlers. By default, handlers \n\t\t * with the same <code>order</code> option returned in reverse order, \n\t\t * i.e. the latter function was added into the handlers list, the higher \n\t\t * it will be in the returned array \n\t\t * @returns {Array}\n\t\t */\n\t\tlist: function() {\n\t\t\treturn _.sortBy(this._list, 'order').reverse();\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns ordered list of handler functions\n\t\t * @returns {Array}\n\t\t */\n\t\tlistFn: function() {\n\t\t\treturn _.pluck(this.list(), 'fn');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Executes handler functions in their designated order. If function\n\t\t * returns <code>skipVal</code>, meaning that function was unable to \n\t\t * handle passed <code>args</code>, the next function will be executed\n\t\t * and so on.\n\t\t * @param {Object} skipValue If function returns this value, execute \n\t\t * next handler.\n\t\t * @param {Array} args Arguments to pass to handler function\n\t\t * @returns {Boolean} Whether any of registered handlers performed\n\t\t * successfully  \n\t\t */\n\t\texec: function(skipValue, args) {\n\t\t\targs = args || [];\n\t\t\tvar result = null;\n\t\t\t_.find(this.list(), function(h) {\n\t\t\t\tresult = h.fn.apply(h, args);\n\t\t\t\tif (result !== skipValue)\n\t\t\t\t\treturn true;\n\t\t\t});\n\t\t\t\n\t\t\treturn result;\n\t\t}\n\t};\n\t\n\treturn {\n\t\t/**\n\t\t * Factory method that produces <code>HandlerList</code> instance\n\t\t * @returns {HandlerList}\n\t\t * @memberOf handlerList\n\t\t */\n\t\tcreate: function() {\n\t\t\treturn new HandlerList();\n\t\t}\n\t};\n});/**\n * Helper class for convenient token iteration\n */\nemmet.define('tokenIterator', function(require, _) {\n\t/**\n\t * @type TokenIterator\n\t * @param {Array} tokens\n\t * @type TokenIterator\n\t * @constructor\n\t */\n\tfunction TokenIterator(tokens) {\n\t\t/** @type Array */\n\t\tthis.tokens = tokens;\n\t\tthis._position = 0;\n\t\tthis.reset();\n\t}\n\t\n\tTokenIterator.prototype = {\n\t\tnext: function() {\n\t\t\tif (this.hasNext()) {\n\t\t\t\tvar token = this.tokens[++this._i];\n\t\t\t\tthis._position = token.start;\n\t\t\t\treturn token;\n\t\t\t}\n\t\t\t\n\t\t\treturn null;\n\t\t},\n\t\t\n\t\tcurrent: function() {\n\t\t\treturn this.tokens[this._i];\n\t\t},\n\t\t\n\t\tposition: function() {\n\t\t\treturn this._position;\n\t\t},\n\t\t\n\t\thasNext: function() {\n\t\t\treturn this._i < this._il - 1;\n\t\t},\n\t\t\n\t\treset: function() {\n\t\t\tthis._i = -1;\n\t\t\tthis._il = this.tokens.length;\n\t\t},\n\t\t\n\t\titem: function() {\n\t\t\treturn this.tokens[this._i];\n\t\t},\n\t\t\n\t\titemNext: function() {\n\t\t\treturn this.tokens[this._i + 1];\n\t\t},\n\t\t\n\t\titemPrev: function() {\n\t\t\treturn this.tokens[this._i - 1];\n\t\t},\n\t\t\n\t\tnextUntil: function(type, callback) {\n\t\t\tvar token;\n\t\t\tvar test = _.isString(type) \n\t\t\t\t? function(t){return t.type == type;} \n\t\t\t\t: type;\n\t\t\t\n\t\t\twhile (token = this.next()) {\n\t\t\t\tif (callback)\n\t\t\t\t\tcallback.call(this, token);\n\t\t\t\tif (test.call(this, token))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t};\n\t\n\treturn {\n\t\tcreate: function(tokens) {\n\t\t\treturn new TokenIterator(tokens);\n\t\t}\n\t};\n});/**\n * A trimmed version of CodeMirror's StringStream module for string parsing\n */\nemmet.define('stringStream', function(require, _) {\n\t/**\n\t * @type StringStream\n\t * @constructor\n\t * @param {String} string\n\t */\n\tfunction StringStream(string) {\n\t\tthis.pos = this.start = 0;\n\t\tthis.string = string;\n\t}\n\t\n\tStringStream.prototype = {\n\t\t/**\n\t\t * Returns true only if the stream is at the end of the line.\n\t\t * @returns {Boolean}\n\t\t */\n\t\teol: function() {\n\t\t\treturn this.pos >= this.string.length;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns true only if the stream is at the start of the line\n\t\t * @returns {Boolean}\n\t\t */\n\t\tsol: function() {\n\t\t\treturn this.pos == 0;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns the next character in the stream without advancing it. \n\t\t * Will return <code>undefined</code> at the end of the line.\n\t\t * @returns {String}\n\t\t */\n\t\tpeek: function() {\n\t\t\treturn this.string.charAt(this.pos);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns the next character in the stream and advances it.\n\t\t * Also returns <code>undefined</code> when no more characters are available.\n\t\t * @returns {String}\n\t\t */\n\t\tnext: function() {\n\t\t\tif (this.pos < this.string.length)\n\t\t\t\treturn this.string.charAt(this.pos++);\n\t\t},\n\t\t\n\t\t/**\n\t\t * match can be a character, a regular expression, or a function that\n\t\t * takes a character and returns a boolean. If the next character in the\n\t\t * stream 'matches' the given argument, it is consumed and returned.\n\t\t * Otherwise, undefined is returned.\n\t\t * @param {Object} match\n\t\t * @returns {String}\n\t\t */\n\t\teat: function(match) {\n\t\t\tvar ch = this.string.charAt(this.pos), ok;\n\t\t\tif (typeof match == \"string\")\n\t\t\t\tok = ch == match;\n\t\t\telse\n\t\t\t\tok = ch && (match.test ? match.test(ch) : match(ch));\n\t\t\t\n\t\t\tif (ok) {\n\t\t\t\t++this.pos;\n\t\t\t\treturn ch;\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Repeatedly calls <code>eat</code> with the given argument, until it\n\t\t * fails. Returns <code>true</code> if any characters were eaten.\n\t\t * @param {Object} match\n\t\t * @returns {Boolean}\n\t\t */\n\t\teatWhile: function(match) {\n\t\t\tvar start = this.pos;\n\t\t\twhile (this.eat(match)) {}\n\t\t\treturn this.pos > start;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Shortcut for <code>eatWhile</code> when matching white-space.\n\t\t * @returns {Boolean}\n\t\t */\n\t\teatSpace: function() {\n\t\t\tvar start = this.pos;\n\t\t\twhile (/[\\s\\u00a0]/.test(this.string.charAt(this.pos)))\n\t\t\t\t++this.pos;\n\t\t\treturn this.pos > start;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Moves the position to the end of the line.\n\t\t */\n\t\tskipToEnd: function() {\n\t\t\tthis.pos = this.string.length;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Skips to the next occurrence of the given character, if found on the\n\t\t * current line (doesn't advance the stream if the character does not\n\t\t * occur on the line). Returns true if the character was found.\n\t\t * @param {String} ch\n\t\t * @returns {Boolean}\n\t\t */\n\t\tskipTo: function(ch) {\n\t\t\tvar found = this.string.indexOf(ch, this.pos);\n\t\t\tif (found > -1) {\n\t\t\t\tthis.pos = found;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Skips to <code>close</code> character which is pair to <code>open</code>\n\t\t * character, considering possible pair nesting. This function is used\n\t\t * to consume pair of characters, like opening and closing braces\n\t\t * @param {String} open\n\t\t * @param {String} close\n\t\t * @returns {Boolean} Returns <code>true</code> if pair was successfully\n\t\t * consumed\n\t\t */\n\t\tskipToPair: function(open, close) {\n\t\t\tvar braceCount = 0, ch;\n\t\t\tvar pos = this.pos, len = this.string.length;\n\t\t\twhile (pos < len) {\n\t\t\t\tch = this.string.charAt(pos++);\n\t\t\t\tif (ch == open) {\n\t\t\t\t\tbraceCount++;\n\t\t\t\t} else if (ch == close) {\n\t\t\t\t\tbraceCount--;\n\t\t\t\t\tif (braceCount < 1) {\n\t\t\t\t\t\tthis.pos = pos;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Backs up the stream n characters. Backing it up further than the\n\t\t * start of the current token will cause things to break, so be careful.\n\t\t * @param {Number} n\n\t\t */\n\t\tbackUp : function(n) {\n\t\t\tthis.pos -= n;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Act like a multi-character <code>eat</code>—if <code>consume</code> is true or\n\t\t * not given—or a look-ahead that doesn't update the stream position—if\n\t\t * it is false. <code>pattern</code> can be either a string or a\n\t\t * regular expression starting with ^. When it is a string,\n\t\t * <code>caseInsensitive</code> can be set to true to make the match\n\t\t * case-insensitive. When successfully matching a regular expression,\n\t\t * the returned value will be the array returned by <code>match</code>,\n\t\t * in case you need to extract matched groups.\n\t\t * \n\t\t * @param {RegExp} pattern\n\t\t * @param {Boolean} consume\n\t\t * @param {Boolean} caseInsensitive\n\t\t * @returns\n\t\t */\n\t\tmatch: function(pattern, consume, caseInsensitive) {\n\t\t\tif (typeof pattern == \"string\") {\n\t\t\t\tvar cased = caseInsensitive\n\t\t\t\t\t? function(str) {return str.toLowerCase();}\n\t\t\t\t\t: function(str) {return str;};\n\t\t\t\t\n\t\t\t\tif (cased(this.string).indexOf(cased(pattern), this.pos) == this.pos) {\n\t\t\t\t\tif (consume !== false)\n\t\t\t\t\t\tthis.pos += pattern.length;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar match = this.string.slice(this.pos).match(pattern);\n\t\t\t\tif (match && consume !== false)\n\t\t\t\t\tthis.pos += match[0].length;\n\t\t\t\treturn match;\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Get the string between the start of the current token and the \n\t\t * current stream position.\n\t\t * @returns {String}\n\t\t */\n\t\tcurrent: function() {\n\t\t\treturn this.string.slice(this.start, this.pos);\n\t\t}\n\t};\n\t\n\treturn {\n\t\tcreate: function(string) {\n\t\t\treturn new StringStream(string);\n\t\t}\n\t};\n});/**\n * Parsed resources (snippets, abbreviations, variables, etc.) for Emmet.\n * Contains convenient method to get access for snippets with respect of \n * inheritance. Also provides ability to store data in different vocabularies\n * ('system' and 'user') for fast and safe resource update\n * @author Sergey Chikuyonok (serge.che@gmail.com)\n * @link http://chikuyonok.ru\n * \n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.define('resources', function(require, _) {\n\tvar VOC_SYSTEM = 'system';\n\tvar VOC_USER = 'user';\n\t\n\tvar cache = {};\n\t\t\n\t/** Regular expression for XML tag matching */\n\tvar reTag = /^<(\\w+\\:?[\\w\\-]*)((?:\\s+[\\w\\:\\-]+\\s*=\\s*(['\"]).*?\\3)*)\\s*(\\/?)>/;\n\t\t\n\tvar systemSettings = {};\n\tvar userSettings = {};\n\t\n\t/** @type HandlerList List of registered abbreviation resolvers */\n\tvar resolvers = require('handlerList').create();\n\t\n\t/**\n\t * Normalizes caret plceholder in passed text: replaces | character with\n\t * default caret placeholder\n\t * @param {String} text\n\t * @returns {String}\n\t */\n\tfunction normalizeCaretPlaceholder(text) {\n\t\tvar utils = require('utils');\n\t\treturn utils.replaceUnescapedSymbol(text, '|', utils.getCaretPlaceholder());\n\t}\n\t\n\tfunction parseItem(name, value, type) {\n\t\tvalue = normalizeCaretPlaceholder(value);\n\t\t\n\t\tif (type == 'snippets') {\n\t\t\treturn require('elements').create('snippet', value);\n\t\t}\n\t\t\n\t\tif (type == 'abbreviations') {\n\t\t\treturn parseAbbreviation(name, value);\n\t\t}\n\t}\n\t\n\t/**\n\t * Parses single abbreviation\n\t * @param {String} key Abbreviation name\n\t * @param {String} value Abbreviation value\n\t * @return {Object}\n\t */\n\tfunction parseAbbreviation(key, value) {\n\t\tkey = require('utils').trim(key);\n\t\tvar elements = require('elements');\n\t\tvar m;\n\t\tif (m = reTag.exec(value)) {\n\t\t\treturn elements.create('element', m[1], m[2], m[4] == '/');\n\t\t} else {\n\t\t\t// assume it's reference to another abbreviation\n\t\t\treturn elements.create('reference', value);\n\t\t}\n\t}\n\t\n\t/**\n\t * Normalizes snippet key name for better fuzzy search\n\t * @param {String} str\n\t * @returns {String}\n\t */\n\tfunction normalizeName(str) {\n\t\treturn str.replace(/:$/, '').replace(/:/g, '-');\n\t}\n\t\n\treturn {\n\t\t/**\n\t\t * Sets new unparsed data for specified settings vocabulary\n\t\t * @param {Object} data\n\t\t * @param {String} type Vocabulary type ('system' or 'user')\n\t\t * @memberOf resources\n\t\t */\n\t\tsetVocabulary: function(data, type) {\n\t\t\tcache = {};\n\t\t\tif (type == VOC_SYSTEM)\n\t\t\t\tsystemSettings = data;\n\t\t\telse\n\t\t\t\tuserSettings = data;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns resource vocabulary by its name\n\t\t * @param {String} name Vocabulary name ('system' or 'user')\n\t\t * @return {Object}\n\t\t */\n\t\tgetVocabulary: function(name) {\n\t\t\treturn name == VOC_SYSTEM ? systemSettings : userSettings;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns resource (abbreviation, snippet, etc.) matched for passed \n\t\t * abbreviation\n\t\t * @param {AbbreviationNode} node\n\t\t * @param {String} syntax\n\t\t * @returns {Object}\n\t\t */\n\t\tgetMatchedResource: function(node, syntax) {\n\t\t\treturn resolvers.exec(null, _.toArray(arguments)) \n\t\t\t\t|| this.findSnippet(syntax, node.name());\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns variable value\n\t\t * @return {String}\n\t\t */\n\t\tgetVariable: function(name) {\n\t\t\treturn (this.getSection('variables') || {})[name];\n\t\t},\n\t\t\n\t\t/**\n\t\t * Store runtime variable in user storage\n\t\t * @param {String} name Variable name\n\t\t * @param {String} value Variable value\n\t\t */\n\t\tsetVariable: function(name, value){\n\t\t\tvar voc = this.getVocabulary('user') || {};\n\t\t\tif (!('variables' in voc))\n\t\t\t\tvoc.variables = {};\n\t\t\t\t\n\t\t\tvoc.variables[name] = value;\n\t\t\tthis.setVocabulary(voc, 'user');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if there are resources for specified syntax\n\t\t * @param {String} syntax\n\t\t * @return {Boolean}\n\t\t */\n\t\thasSyntax: function(syntax) {\n\t\t\treturn syntax in this.getVocabulary(VOC_USER) \n\t\t\t\t|| syntax in this.getVocabulary(VOC_SYSTEM);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Registers new abbreviation resolver.\n\t\t * @param {Function} fn Abbreviation resolver which will receive \n\t\t * abbreviation as first argument and should return parsed abbreviation\n\t\t * object if abbreviation has handled successfully, <code>null</code>\n\t\t * otherwise\n\t\t * @param {Object} options Options list as described in \n\t\t * {@link HandlerList#add()} method\n\t\t */\n\t\taddResolver: function(fn, options) {\n\t\t\tresolvers.add(fn, options);\n\t\t},\n\t\t\n\t\tremoveResolver: function(fn) {\n\t\t\tresolvers.remove(fn);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns actual section data, merged from both\n\t\t * system and user data\n\t\t * @param {String} name Section name (syntax)\n\t\t * @param {String} ...args Subsections\n\t\t * @returns\n\t\t */\n\t\tgetSection: function(name) {\n\t\t\tif (!name)\n\t\t\t\treturn null;\n\t\t\t\n\t\t\tif (!(name in cache)) {\n\t\t\t\tcache[name] = require('utils').deepMerge({}, systemSettings[name], userSettings[name]);\n\t\t\t}\n\t\t\t\n\t\t\tvar data = cache[name], subsections = _.rest(arguments), key;\n\t\t\twhile (data && (key = subsections.shift())) {\n\t\t\t\tif (key in data) {\n\t\t\t\t\tdata = data[key];\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn data;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Recursively searches for a item inside top level sections (syntaxes)\n\t\t * with respect of `extends` attribute\n\t\t * @param {String} topSection Top section name (syntax)\n\t\t * @param {String} subsection Inner section name\n\t\t * @returns {Object}\n\t\t */\n\t\tfindItem: function(topSection, subsection) {\n\t\t\tvar data = this.getSection(topSection);\n\t\t\twhile (data) {\n\t\t\t\tif (subsection in data)\n\t\t\t\t\treturn data[subsection];\n\t\t\t\t\n\t\t\t\tdata = this.getSection(data['extends']);\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Recursively searches for a snippet definition inside syntax section.\n\t\t * Definition is searched inside `snippets` and `abbreviations` \n\t\t * subsections  \n\t\t * @param {String} syntax Top-level section name (syntax)\n\t\t * @param {String} name Snippet name\n\t\t * @returns {Object}\n\t\t */\n\t\tfindSnippet: function(syntax, name, memo) {\n\t\t\tif (!syntax || !name)\n\t\t\t\treturn null;\n\t\t\t\n\t\t\tmemo = memo || [];\n\t\t\t\n\t\t\tvar names = [name];\n\t\t\t// create automatic aliases to properties with colons,\n\t\t\t// e.g. pos-a == pos:a\n\t\t\tif (~name.indexOf('-'))\n\t\t\t\tnames.push(name.replace(/\\-/g, ':'));\n\t\t\t\n\t\t\tvar data = this.getSection(syntax), matchedItem = null;\n\t\t\t_.find(['snippets', 'abbreviations'], function(sectionName) {\n\t\t\t\tvar data = this.getSection(syntax, sectionName);\n\t\t\t\tif (data) {\n\t\t\t\t\treturn _.find(names, function(n) {\n\t\t\t\t\t\tif (data[n])\n\t\t\t\t\t\t\treturn matchedItem = parseItem(n, data[n], sectionName);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}, this);\n\t\t\t\n\t\t\tmemo.push(syntax);\n\t\t\tif (!matchedItem && data['extends'] && !_.include(memo, data['extends'])) {\n\t\t\t\t// try to find item in parent syntax section\n\t\t\t\treturn this.findSnippet(data['extends'], name, memo);\n\t\t\t}\n\t\t\t\n\t\t\treturn matchedItem;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Performs fuzzy search of snippet definition\n\t\t * @param {String} syntax Top-level section name (syntax)\n\t\t * @param {String} name Snippet name\n\t\t * @returns\n\t\t */\n\t\tfuzzyFindSnippet: function(syntax, name, minScore) {\n\t\t\tminScore = minScore || 0.3;\n\t\t\t\n\t\t\tvar payload = this.getAllSnippets(syntax);\n\t\t\tvar sc = require('string-score');\n\t\t\t\n\t\t\tname = normalizeName(name);\n\t\t\tvar scores = _.map(payload, function(value, key) {\n\t\t\t\treturn {\n\t\t\t\t\tkey: key,\n\t\t\t\t\tscore: sc.score(value.nk, name, 0.1)\n\t\t\t\t};\n\t\t\t});\n\t\t\t\n\t\t\tvar result = _.last(_.sortBy(scores, 'score'));\n\t\t\tif (result && result.score >= minScore) {\n\t\t\t\tvar k = result.key;\n\t\t\t\treturn payload[k].parsedValue;\n//\t\t\t\treturn parseItem(k, payload[k].value, payload[k].type);\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns plain dictionary of all available abbreviations and snippets\n\t\t * for specified syntax with respect of inheritance\n\t\t * @param {String} syntax\n\t\t * @returns {Object}\n\t\t */\n\t\tgetAllSnippets: function(syntax) {\n\t\t\tvar cacheKey = 'all-' + syntax;\n\t\t\tif (!cache[cacheKey]) {\n\t\t\t\tvar stack = [], sectionKey = syntax;\n\t\t\t\tvar memo = [];\n\t\t\t\t\n\t\t\t\tdo {\n\t\t\t\t\tvar section = this.getSection(sectionKey);\n\t\t\t\t\tif (!section)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\t_.each(['snippets', 'abbreviations'], function(sectionName) {\n\t\t\t\t\t\tvar stackItem = {};\n\t\t\t\t\t\t_.each(section[sectionName] || null, function(v, k) {\n\t\t\t\t\t\t\tstackItem[k] = {\n\t\t\t\t\t\t\t\tnk: normalizeName(k),\n\t\t\t\t\t\t\t\tvalue: v,\n\t\t\t\t\t\t\t\tparsedValue: parseItem(k, v, sectionName),\n\t\t\t\t\t\t\t\ttype: sectionName\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t});\n\t\t\t\t\t\t\n\t\t\t\t\t\tstack.push(stackItem);\n\t\t\t\t\t});\n\t\t\t\t\t\n\t\t\t\t\tmemo.push(sectionKey);\n\t\t\t\t\tsectionKey = section['extends'];\n\t\t\t\t} while (sectionKey && !_.include(memo, sectionKey));\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tcache[cacheKey] = _.extend.apply(_, stack.reverse());\n\t\t\t}\n\t\t\t\n\t\t\treturn cache[cacheKey];\n\t\t}\n\t};\n});/**\n * Module describes and performs Emmet actions. The actions themselves are\n * defined in <i>actions</i> folder\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.define('actions', function(require, _, zc) {\n\tvar actions = {};\n\t\n\t/**\n\t * “Humanizes” action name, makes it more readable for people\n\t * @param {String} name Action name (like 'expand_abbreviation')\n\t * @return Humanized name (like 'Expand Abbreviation')\n\t */\n\tfunction humanizeActionName(name) {\n\t\treturn require('utils').trim(name.charAt(0).toUpperCase() \n\t\t\t+ name.substring(1).replace(/_[a-z]/g, function(str) {\n\t\t\t\treturn ' ' + str.charAt(1).toUpperCase();\n\t\t\t}));\n\t}\n\t\n\treturn {\n\t\t/**\n\t\t * Registers new action\n\t\t * @param {String} name Action name\n\t\t * @param {Function} fn Action function\n\t\t * @param {Object} options Custom action options:<br>\n\t\t * <b>label</b> : (<code>String</code>) – Human-readable action name. \n\t\t * May contain '/' symbols as submenu separators<br>\n\t\t * <b>hidden</b> : (<code>Boolean</code>) – Indicates whether action\n\t\t * should be displayed in menu (<code>getMenu()</code> method)\n\t\t * \n\t\t * @memberOf actions\n\t\t */\n\t\tadd: function(name, fn, options) {\n\t\t\tname = name.toLowerCase();\n\t\t\toptions = options || {};\n\t\t\tif (!options.label) {\n\t\t\t\toptions.label = humanizeActionName(name);\n\t\t\t}\n\t\t\t\n\t\t\tactions[name] = {\n\t\t\t\tname: name,\n\t\t\t\tfn: fn,\n\t\t\t\toptions: options\n\t\t\t};\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns action object\n\t\t * @param {String} name Action name\n\t\t * @returns {Object}\n\t\t */\n\t\tget: function(name) {\n\t\t\treturn actions[name.toLowerCase()];\n\t\t},\n\t\t\n\t\t/**\n\t\t * Runs Emmet action. For list of available actions and their\n\t\t * arguments see <i>actions</i> folder.\n\t\t * @param {String} name Action name \n\t\t * @param {Array} args Additional arguments. It may be array of arguments\n\t\t * or inline arguments. The first argument should be <code>IEmmetEditor</code> instance\n\t\t * @returns {Boolean} Status of performed operation, <code>true</code>\n\t\t * means action was performed successfully.\n\t\t * @example\n\t\t * emmet.require('actions').run('expand_abbreviation', editor);  \n\t\t * emmet.require('actions').run('wrap_with_abbreviation', [editor, 'div']);  \n\t\t */\n\t\trun: function(name, args) {\n\t\t\tif (!_.isArray(args)) {\n\t\t\t\targs = _.rest(arguments);\n\t\t\t}\n\t\t\t\n\t\t\tvar action = this.get(name);\n\t\t\tif (action) {\n\t\t\t\treturn action.fn.apply(emmet, args);\n\t\t\t} else {\n\t\t\t\temmet.log('Action \"%s\" is not defined', name);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns all registered actions as object\n\t\t * @returns {Object}\n\t\t */\n\t\tgetAll: function() {\n\t\t\treturn actions;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns all registered actions as array\n\t\t * @returns {Array}\n\t\t */\n\t\tgetList: function() {\n\t\t\treturn _.values(this.getAll());\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns actions list as structured menu. If action has <i>label</i>,\n\t\t * it will be splitted by '/' symbol into submenus (for example: \n\t\t * CSS/Reflect Value) and grouped with other items\n\t\t * @param {Array} skipActions List of action identifiers that should be \n\t\t * skipped from menu\n\t\t * @returns {Array}\n\t\t */\n\t\tgetMenu: function(skipActions) {\n\t\t\tvar result = [];\n\t\t\tskipActions = skipActions || [];\n\t\t\t_.each(this.getList(), function(action) {\n\t\t\t\tif (action.options.hidden || _.include(skipActions, action.name))\n\t\t\t\t\treturn;\n\t\t\t\t\n\t\t\t\tvar actionName = humanizeActionName(action.name);\n\t\t\t\tvar ctx = result;\n\t\t\t\tif (action.options.label) {\n\t\t\t\t\tvar parts = action.options.label.split('/');\n\t\t\t\t\tactionName = parts.pop();\n\t\t\t\t\t\n\t\t\t\t\t// create submenus, if needed\n\t\t\t\t\tvar menuName, submenu;\n\t\t\t\t\twhile (menuName = parts.shift()) {\n\t\t\t\t\t\tsubmenu = _.find(ctx, function(item) {\n\t\t\t\t\t\t\treturn item.type == 'submenu' && item.name == menuName;\n\t\t\t\t\t\t});\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (!submenu) {\n\t\t\t\t\t\t\tsubmenu = {\n\t\t\t\t\t\t\t\tname: menuName,\n\t\t\t\t\t\t\t\ttype: 'submenu',\n\t\t\t\t\t\t\t\titems: []\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tctx.push(submenu);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tctx = submenu.items;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tctx.push({\n\t\t\t\t\ttype: 'action',\n\t\t\t\t\tname: action.name,\n\t\t\t\t\tlabel: actionName\n\t\t\t\t});\n\t\t\t});\n\t\t\t\n\t\t\treturn result;\n\t\t},\n\n\t\t/**\n\t\t * Returns action name associated with menu item title\n\t\t * @param {String} title\n\t\t * @returns {String}\n\t\t */\n\t\tgetActionNameForMenuTitle: function(title, menu) {\n\t\t\tvar item = null;\n\t\t\t_.find(menu || this.getMenu(), function(val) {\n\t\t\t\tif (val.type == 'action') {\n\t\t\t\t\tif (val.label == title || val.name == title) {\n\t\t\t\t\t\treturn item = val.name;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn item = this.getActionNameForMenuTitle(title, val.items);\n\t\t\t\t}\n\t\t\t}, this);\n\t\t\t\n\t\t\treturn item || null;\n\t\t}\n\t};\n});/**\n * Output profile module.\n * Profile defines how XHTML output data should look like\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.define('profile', function(require, _) {\n\tvar profiles = {};\n\t\n\tvar defaultProfile = {\n\t\ttag_case: 'asis',\n\t\tattr_case: 'asis',\n\t\tattr_quotes: 'double',\n\t\t\n\t\t// each tag on new line\n\t\ttag_nl: 'decide',\n\t\t\n\t\t// with tag_nl === true, defines if leaf node (e.g. node with no children)\n\t\t// should have formatted line breaks\n\t\ttag_nl_leaf: false,\n\t\t\n\t\tplace_cursor: true,\n\t\t\n\t\t// indent tags\n\t\tindent: true,\n\t\t\n\t\t// how many inline elements should be to force line break \n\t\t// (set to 0 to disable)\n\t\tinline_break: 3,\n\t\t\n\t\t// use self-closing style for writing empty elements, e.g. <br /> or <br>\n\t\tself_closing_tag: 'xhtml',\n\t\t\n\t\t// Profile-level output filters, re-defines syntax filters \n\t\tfilters: '',\n\t\t\n\t\t// Additional filters applied to abbreviation.\n\t\t// Unlike \"filters\", this preference doesn't override default filters\n\t\t// but add the instead every time given profile is chosen\n\t\textraFilters: ''\n\t};\n\t\n\t/**\n\t * @constructor\n\t * @type OutputProfile\n\t * @param {Object} options\n\t */\n\tfunction OutputProfile(options) {\n\t\t_.extend(this, defaultProfile, options);\n\t}\n\t\n\tOutputProfile.prototype = {\n\t\t/**\n\t\t * Transforms tag name case depending on current profile settings\n\t\t * @param {String} name String to transform\n\t\t * @returns {String}\n\t\t */\n\t\ttagName: function(name) {\n\t\t\treturn stringCase(name, this.tag_case);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Transforms attribute name case depending on current profile settings \n\t\t * @param {String} name String to transform\n\t\t * @returns {String}\n\t\t */\n\t\tattributeName: function(name) {\n\t\t\treturn stringCase(name, this.attr_case);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns quote character for current profile\n\t\t * @returns {String}\n\t\t */\n\t\tattributeQuote: function() {\n\t\t\treturn this.attr_quotes == 'single' ? \"'\" : '\"';\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns self-closing tag symbol for current profile\n\t\t * @param {String} param\n\t\t * @returns {String}\n\t\t */\n\t\tselfClosing: function(param) {\n\t\t\tif (this.self_closing_tag == 'xhtml')\n\t\t\t\treturn ' /';\n\t\t\t\n\t\t\tif (this.self_closing_tag === true)\n\t\t\t\treturn '/';\n\t\t\t\n\t\t\treturn '';\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns cursor token based on current profile settings\n\t\t * @returns {String}\n\t\t */\n\t\tcursor: function() {\n\t\t\treturn this.place_cursor ? require('utils').getCaretPlaceholder() : '';\n\t\t}\n\t};\n\t\n\t/**\n\t * Helper function that converts string case depending on \n\t * <code>caseValue</code> \n\t * @param {String} str String to transform\n\t * @param {String} caseValue Case value: can be <i>lower</i>, \n\t * <i>upper</i> and <i>leave</i>\n\t * @returns {String}\n\t */\n\tfunction stringCase(str, caseValue) {\n\t\tswitch (String(caseValue || '').toLowerCase()) {\n\t\t\tcase 'lower':\n\t\t\t\treturn str.toLowerCase();\n\t\t\tcase 'upper':\n\t\t\t\treturn str.toUpperCase();\n\t\t}\n\t\t\n\t\treturn str;\n\t}\n\t\n\t/**\n\t * Creates new output profile\n\t * @param {String} name Profile name\n\t * @param {Object} options Profile options\n\t */\n\tfunction createProfile(name, options) {\n\t\treturn profiles[name.toLowerCase()] = new OutputProfile(options);\n\t}\n\t\n\tfunction createDefaultProfiles() {\n\t\tcreateProfile('xhtml');\n\t\tcreateProfile('html', {self_closing_tag: false});\n\t\tcreateProfile('xml', {self_closing_tag: true, tag_nl: true});\n\t\tcreateProfile('plain', {tag_nl: false, indent: false, place_cursor: false});\n\t\tcreateProfile('line', {tag_nl: false, indent: false, extraFilters: 's'});\n\t}\n\t\n\tcreateDefaultProfiles();\n\t\n\treturn  {\n\t\t/**\n\t\t * Creates new output profile and adds it into internal dictionary\n\t\t * @param {String} name Profile name\n\t\t * @param {Object} options Profile options\n\t\t * @memberOf emmet.profile\n\t\t * @returns {Object} New profile\n\t\t */\n\t\tcreate: function(name, options) {\n\t\t\tif (arguments.length == 2)\n\t\t\t\treturn createProfile(name, options);\n\t\t\telse\n\t\t\t\t// create profile object only\n\t\t\t\treturn new OutputProfile(_.defaults(name || {}, defaultProfile));\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns profile by its name. If profile wasn't found, returns\n\t\t * 'plain' profile\n\t\t * @param {String} name Profile name. Might be profile itself\n\t\t * @param {String} syntax. Optional. Current editor syntax. If defined,\n\t\t * profile is searched in resources first, then in predefined profiles\n\t\t * @returns {Object}\n\t\t */\n\t\tget: function(name, syntax) {\n\t\t\tif (!name && syntax) {\n\t\t\t\t// search in user resources first\n\t\t\t\tvar profile = require('resources').findItem(syntax, 'profile');\n\t\t\t\tif (profile) {\n\t\t\t\t\tname = profile;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (!name) {\n\t\t\t\treturn profiles.plain;\n\t\t\t}\n\t\t\t\n\t\t\tif (name instanceof OutputProfile) {\n\t\t\t\treturn name;\n\t\t\t}\n\t\t\t\n\t\t\tif (_.isString(name) && name.toLowerCase() in profiles) {\n\t\t\t\treturn profiles[name.toLowerCase()];\n\t\t\t}\n\t\t\t\n\t\t\treturn this.create(name);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Deletes profile with specified name\n\t\t * @param {String} name Profile name\n\t\t */\n\t\tremove: function(name) {\n\t\t\tname = (name || '').toLowerCase();\n\t\t\tif (name in profiles)\n\t\t\t\tdelete profiles[name];\n\t\t},\n\t\t\n\t\t/**\n\t\t * Resets all user-defined profiles\n\t\t */\n\t\treset: function() {\n\t\t\tprofiles = {};\n\t\t\tcreateDefaultProfiles();\n\t\t},\n\t\t\n\t\t/**\n\t\t * Helper function that converts string case depending on \n\t\t * <code>caseValue</code> \n\t\t * @param {String} str String to transform\n\t\t * @param {String} caseValue Case value: can be <i>lower</i>, \n\t\t * <i>upper</i> and <i>leave</i>\n\t\t * @returns {String}\n\t\t */\n\t\tstringCase: stringCase\n\t};\n});/**\n * Utility module used to prepare text for pasting into back-end editor\n * @param {Function} require\n * @param {Underscore} _\n * @author Sergey Chikuyonok (serge.che@gmail.com) <http://chikuyonok.ru>\n */\nemmet.define('editorUtils', function(require, _) {\n\treturn  {\n\t\t/**\n\t\t * Check if cursor is placed inside XHTML tag\n\t\t * @param {String} html Contents of the document\n\t\t * @param {Number} caretPos Current caret position inside tag\n\t\t * @return {Boolean}\n\t\t */\n\t\tisInsideTag: function(html, caretPos) {\n\t\t\tvar reTag = /^<\\/?\\w[\\w\\:\\-]*.*?>/;\n\t\t\t\n\t\t\t// search left to find opening brace\n\t\t\tvar pos = caretPos;\n\t\t\twhile (pos > -1) {\n\t\t\t\tif (html.charAt(pos) == '<') \n\t\t\t\t\tbreak;\n\t\t\t\tpos--;\n\t\t\t}\n\t\t\t\n\t\t\tif (pos != -1) {\n\t\t\t\tvar m = reTag.exec(html.substring(pos));\n\t\t\t\tif (m && caretPos > pos && caretPos < pos + m[0].length)\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Sanitizes incoming editor data and provides default values for\n\t\t * output-specific info\n\t\t * @param {IEmmetEditor} editor\n\t\t * @param {String} syntax\n\t\t * @param {String} profile\n\t\t */\n\t\toutputInfo: function(editor, syntax, profile) {\n\t\t\t// most of this code makes sense for Java/Rhino environment\n\t\t\t// because string that comes from Java are not actually JS string\n\t\t\t// but Java String object so the have to be explicitly converted\n\t\t\t// to native string\n\t\t\tprofile = profile || editor.getProfileName();\n\t\t\treturn  {\n\t\t\t\t/** @memberOf outputInfo */\n\t\t\t\tsyntax: String(syntax || editor.getSyntax()),\n\t\t\t\tprofile: profile || null,\n\t\t\t\tcontent: String(editor.getContent())\n\t\t\t};\n\t\t},\n\t\t\n\t\t/**\n\t\t * Unindent content, thus preparing text for tag wrapping\n\t\t * @param {IEmmetEditor} editor Editor instance\n\t\t * @param {String} text\n\t\t * @return {String}\n\t\t */\n\t\tunindent: function(editor, text) {\n\t\t\treturn require('utils').unindentString(text, this.getCurrentLinePadding(editor));\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns padding of current editor's line\n\t\t * @param {IEmmetEditor} Editor instance\n\t\t * @return {String}\n\t\t */\n\t\tgetCurrentLinePadding: function(editor) {\n\t\t\treturn require('utils').getLinePadding(editor.getCurrentLine());\n\t\t}\n\t};\n});\n/**\n * Utility methods for Emmet actions\n * @param {Function} require\n * @param {Underscore} _\n * @author Sergey Chikuyonok (serge.che@gmail.com) <http://chikuyonok.ru>\n */\nemmet.define('actionUtils', function(require, _) {\n\treturn {\n\t\tmimeTypes: {\n\t\t\t'gif' : 'image/gif',\n\t\t\t'png' : 'image/png',\n\t\t\t'jpg' : 'image/jpeg',\n\t\t\t'jpeg': 'image/jpeg',\n\t\t\t'svg' : 'image/svg+xml',\n\t\t\t'html': 'text/html',\n\t\t\t'htm' : 'text/html'\n\t\t},\n\t\t\n\t\t/**\n\t\t * Extracts abbreviations from text stream, starting from the end\n\t\t * @param {String} str\n\t\t * @return {String} Abbreviation or empty string\n\t\t * @memberOf emmet.actionUtils\n\t\t */\n\t\textractAbbreviation: function(str) {\n\t\t\tvar curOffset = str.length;\n\t\t\tvar startIndex = -1;\n\t\t\tvar groupCount = 0;\n\t\t\tvar braceCount = 0;\n\t\t\tvar textCount = 0;\n\t\t\t\n\t\t\tvar utils = require('utils');\n\t\t\tvar parser = require('abbreviationParser');\n\t\t\t\n\t\t\twhile (true) {\n\t\t\t\tcurOffset--;\n\t\t\t\tif (curOffset < 0) {\n\t\t\t\t\t// moved to the beginning of the line\n\t\t\t\t\tstartIndex = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar ch = str.charAt(curOffset);\n\t\t\t\t\n\t\t\t\tif (ch == ']') {\n\t\t\t\t\tbraceCount++;\n\t\t\t\t} else if (ch == '[') {\n\t\t\t\t\tif (!braceCount) { // unexpected brace\n\t\t\t\t\t\tstartIndex = curOffset + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbraceCount--;\n\t\t\t\t} else if (ch == '}') {\n\t\t\t\t\ttextCount++;\n\t\t\t\t} else if (ch == '{') {\n\t\t\t\t\tif (!textCount) { // unexpected brace\n\t\t\t\t\t\tstartIndex = curOffset + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ttextCount--;\n\t\t\t\t} else if (ch == ')') {\n\t\t\t\t\tgroupCount++;\n\t\t\t\t} else if (ch == '(') {\n\t\t\t\t\tif (!groupCount) { // unexpected brace\n\t\t\t\t\t\tstartIndex = curOffset + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tgroupCount--;\n\t\t\t\t} else {\n\t\t\t\t\tif (braceCount || textCount) \n\t\t\t\t\t\t// respect all characters inside attribute sets or text nodes\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse if (!parser.isAllowedChar(ch) || (ch == '>' && utils.endsWithTag(str.substring(0, curOffset + 1)))) {\n\t\t\t\t\t\t// found stop symbol\n\t\t\t\t\t\tstartIndex = curOffset + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (startIndex != -1 && !textCount && !braceCount && !groupCount) \n\t\t\t\t// found something, remove some invalid symbols from the \n\t\t\t\t// beginning and return abbreviation\n\t\t\t\treturn str.substring(startIndex).replace(/^[\\*\\+\\>\\^]+/, '');\n\t\t\telse\n\t\t\t\treturn '';\n\t\t},\n\t\t\n\t\t/**\n\t\t * Gets image size from image byte stream.\n\t\t * @author http://romeda.org/rePublish/\n\t\t * @param {String} stream Image byte stream (use <code>IEmmetFile.read()</code>)\n\t\t * @return {Object} Object with <code>width</code> and <code>height</code> properties\n\t\t */\n\t\tgetImageSize: function(stream) {\n\t\t\tvar pngMagicNum = \"\\211PNG\\r\\n\\032\\n\",\n\t\t\t\tjpgMagicNum = \"\\377\\330\",\n\t\t\t\tgifMagicNum = \"GIF8\",\n\t\t\t\tnextByte = function() {\n\t\t\t\t\treturn stream.charCodeAt(pos++);\n\t\t\t\t};\n\t\t\n\t\t\tif (stream.substr(0, 8) === pngMagicNum) {\n\t\t\t\t// PNG. Easy peasy.\n\t\t\t\tvar pos = stream.indexOf('IHDR') + 4;\n\t\t\t\n\t\t\t\treturn { width:  (nextByte() << 24) | (nextByte() << 16) |\n\t\t\t\t\t\t\t\t (nextByte() <<  8) | nextByte(),\n\t\t\t\t\t\t height: (nextByte() << 24) | (nextByte() << 16) |\n\t\t\t\t\t\t\t\t (nextByte() <<  8) | nextByte() };\n\t\t\t\n\t\t\t} else if (stream.substr(0, 4) === gifMagicNum) {\n\t\t\t\tpos = 6;\n\t\t\t\n\t\t\t\treturn {\n\t\t\t\t\twidth:  nextByte() | (nextByte() << 8),\n\t\t\t\t\theight: nextByte() | (nextByte() << 8)\n\t\t\t\t};\n\t\t\t\n\t\t\t} else if (stream.substr(0, 2) === jpgMagicNum) {\n\t\t\t\tpos = 2;\n\t\t\t\n\t\t\t\tvar l = stream.length;\n\t\t\t\twhile (pos < l) {\n\t\t\t\t\tif (nextByte() != 0xFF) return;\n\t\t\t\t\n\t\t\t\t\tvar marker = nextByte();\n\t\t\t\t\tif (marker == 0xDA) break;\n\t\t\t\t\n\t\t\t\t\tvar size = (nextByte() << 8) | nextByte();\n\t\t\t\t\n\t\t\t\t\tif (marker >= 0xC0 && marker <= 0xCF && !(marker & 0x4) && !(marker & 0x8)) {\n\t\t\t\t\t\tpos += 1;\n\t\t\t\t\t\treturn { height:  (nextByte() << 8) | nextByte(),\n\t\t\t\t\t\t\t\t width: (nextByte() << 8) | nextByte() };\n\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpos += size - 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Captures context XHTML element from editor under current caret position.\n\t\t * This node can be used as a helper for abbreviation extraction\n\t\t * @param {IEmmetEditor} editor\n\t\t * @returns {Object}\n\t\t */\n\t\tcaptureContext: function(editor) {\n\t\t\tvar allowedSyntaxes = {'html': 1, 'xml': 1, 'xsl': 1};\n\t\t\tvar syntax = String(editor.getSyntax());\n\t\t\tif (syntax in allowedSyntaxes) {\n\t\t\t\tvar content = String(editor.getContent());\n\t\t\t\tvar tag = require('htmlMatcher').find(content, editor.getCaretPos());\n\t\t\t\t\n\t\t\t\tif (tag && tag.type == 'tag') {\n\t\t\t\t\tvar startTag = tag.open;\n\t\t\t\t\tvar contextNode = {\n\t\t\t\t\t\tname: startTag.name,\n\t\t\t\t\t\tattributes: []\n\t\t\t\t\t};\n\t\t\t\t\t\n\t\t\t\t\t// parse attributes\n\t\t\t\t\tvar tagTree = require('xmlEditTree').parse(startTag.range.substring(content));\n\t\t\t\t\tif (tagTree) {\n\t\t\t\t\t\tcontextNode.attributes = _.map(tagTree.getAll(), function(item) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tname: item.name(),\n\t\t\t\t\t\t\t\tvalue: item.value()\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\treturn contextNode;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn null;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Find expression bounds in current editor at caret position. \n\t\t * On each character a <code>fn</code> function will be called and must \n\t\t * return <code>true</code> if current character meets requirements, \n\t\t * <code>false</code> otherwise\n\t\t * @param {IEmmetEditor} editor\n\t\t * @param {Function} fn Function to test each character of expression\n\t\t * @return {Range}\n\t\t */\n\t\tfindExpressionBounds: function(editor, fn) {\n\t\t\tvar content = String(editor.getContent());\n\t\t\tvar il = content.length;\n\t\t\tvar exprStart = editor.getCaretPos() - 1;\n\t\t\tvar exprEnd = exprStart + 1;\n\t\t\t\t\n\t\t\t// start by searching left\n\t\t\twhile (exprStart >= 0 && fn(content.charAt(exprStart), exprStart, content)) exprStart--;\n\t\t\t\n\t\t\t// then search right\n\t\t\twhile (exprEnd < il && fn(content.charAt(exprEnd), exprEnd, content)) exprEnd++;\n\t\t\t\n\t\t\tif (exprEnd > exprStart) {\n\t\t\t\treturn require('range').create([++exprStart, exprEnd]);\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * @param {IEmmetEditor} editor\n\t\t * @param {Object} data\n\t\t * @returns {Boolean}\n\t\t */\n\t\tcompoundUpdate: function(editor, data) {\n\t\t\tif (data) {\n\t\t\t\tvar sel = editor.getSelectionRange();\n\t\t\t\teditor.replaceContent(data.data, data.start, data.end, true);\n\t\t\t\teditor.createSelection(data.caret, data.caret + sel.end - sel.start);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Common syntax detection method for editors that doesn’t provide any\n\t\t * info about current syntax scope. \n\t\t * @param {IEmmetEditor} editor Current editor\n\t\t * @param {String} hint Any syntax hint that editor can provide \n\t\t * for syntax detection. Default is 'html'\n\t\t * @returns {String} \n\t\t */\n\t\tdetectSyntax: function(editor, hint) {\n\t\t\tvar syntax = hint || 'html';\n\t\t\t\n\t\t\tif (!require('resources').hasSyntax(syntax)) {\n\t\t\t\tsyntax = 'html';\n\t\t\t}\n\t\t\t\n\t\t\tif (syntax == 'html' && (this.isStyle(editor) || this.isInlineCSS(editor))) {\n\t\t\t\tsyntax = 'css';\n\t\t\t}\n\t\t\t\n\t\t\treturn syntax;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Common method for detecting output profile\n\t\t * @param {IEmmetEditor} editor\n\t\t * @returns {String}\n\t\t */\n\t\tdetectProfile: function(editor) {\n\t\t\tvar syntax = editor.getSyntax();\n\t\t\t\n\t\t\t// get profile from syntax definition\n\t\t\tvar profile = require('resources').findItem(syntax, 'profile');\n\t\t\tif (profile) {\n\t\t\t\treturn profile;\n\t\t\t}\n\t\t\t\n\t\t\tswitch(syntax) {\n\t\t\t\tcase 'xml':\n\t\t\t\tcase 'xsl':\n\t\t\t\t\treturn 'xml';\n\t\t\t\tcase 'css':\n\t\t\t\t\tif (this.isInlineCSS(editor)) {\n\t\t\t\t\t\treturn 'line';\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'html':\n\t\t\t\t\tvar profile = require('resources').getVariable('profile');\n\t\t\t\t\tif (!profile) { // no forced profile, guess from content\n\t\t\t\t\t\t// html or xhtml?\n\t\t\t\t\t\tprofile = this.isXHTML(editor) ? 'xhtml': 'html';\n\t\t\t\t\t}\n\n\t\t\t\t\treturn profile;\n\t\t\t}\n\n\t\t\treturn 'xhtml';\n\t\t},\n\t\t\n\t\t/**\n\t\t * Tries to detect if current document is XHTML one.\n\t\t * @param {IEmmetEditor} editor\n\t\t * @returns {Boolean}\n\t\t */\n\t\tisXHTML: function(editor) {\n\t\t\treturn editor.getContent().search(/<!DOCTYPE[^>]+XHTML/i) != -1;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if current caret position is inside &lt;style&gt; tag\n\t\t * @param {IEmmetEditor} editor\n\t\t * @returns\n\t\t */\n\t\tisStyle: function(editor) {\n\t\t\tvar content = String(editor.getContent());\n\t\t\tvar caretPos = editor.getCaretPos();\n\t\t\tvar tag = require('htmlMatcher').tag(content, caretPos);\n\t\t\treturn tag && tag.open.name.toLowerCase() == 'style' \n\t\t\t\t&& tag.innerRange.cmp(caretPos, 'lte', 'gte');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if current caret position is inside \"style\" attribute of HTML\n\t\t * element\n\t\t * @param {IEmmetEditor} editor\n\t\t * @returns {Boolean}\n\t\t */\n\t\tisInlineCSS: function(editor) {\n\t\t\tvar content = String(editor.getContent());\n\t\t\tvar caretPos = editor.getCaretPos();\n\t\t\tvar tree = require('xmlEditTree').parseFromPosition(content, caretPos, true);\n            if (tree) {\n                var attr = tree.itemFromPosition(caretPos, true);\n                return attr && attr.name().toLowerCase() == 'style' \n                \t&& attr.valueRange(true).cmp(caretPos, 'lte', 'gte');\n            }\n            \n            return false;\n\t\t}\n\t};\n});/**\n * Utility functions to work with <code>AbbreviationNode</code> as HTML element\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.define('abbreviationUtils', function(require, _) {\n\treturn {\n\t\t/**\n\t\t * Check if passed abbreviation node has matched snippet resource\n\t\t * @param {AbbreviationNode} node\n\t\t * @returns {Boolean}\n\t\t * @memberOf abbreviationUtils\n\t\t */\n\t\tisSnippet: function(node) {\n\t\t\treturn require('elements').is(node.matchedResource(), 'snippet');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Test if passed node is unary (no closing tag)\n\t\t * @param {AbbreviationNode} node\n\t\t * @return {Boolean}\n\t\t */\n\t\tisUnary: function(node) {\n\t\t\tif (node.children.length || node._text || this.isSnippet(node)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tvar r = node.matchedResource();\n\t\t\treturn r && r.is_empty;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Test if passed node is inline-level (like &lt;strong&gt;, &lt;img&gt;)\n\t\t * @param {AbbreviationNode} node\n\t\t * @return {Boolean}\n\t\t */\n\t\tisInline: function(node) {\n\t\t\treturn node.isTextNode() \n\t\t\t\t|| !node.name() \n\t\t\t\t|| require('tagName').isInlineLevel(node.name());\n\t\t},\n\t\t\n\t\t/**\n\t\t * Test if passed node is block-level\n\t\t * @param {AbbreviationNode} node\n\t\t * @return {Boolean}\n\t\t */\n\t\tisBlock: function(node) {\n\t\t\treturn this.isSnippet(node) || !this.isInline(node);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Test if given node is a snippet\n\t\t * @param {AbbreviationNode} node\n\t\t * @return {Boolean}\n\t\t */\n\t\tisSnippet: function(node) {\n\t\t\treturn require('elements').is(node.matchedResource(), 'snippet');\n\t\t},\n\t\t\n\t\t/**\n\t\t * This function tests if passed node content contains HTML tags. \n\t\t * This function is mostly used for output formatting\n\t\t * @param {AbbreviationNode} node\n\t\t * @returns {Boolean}\n\t\t */\n\t\thasTagsInContent: function(node) {\n\t\t\treturn require('utils').matchesTag(node.content);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Test if current element contains block-level children\n\t\t * @param {AbbreviationNode} node\n\t\t * @return {Boolean}\n\t\t */\n\t\thasBlockChildren: function(node) {\n\t\t\treturn (this.hasTagsInContent(node) && this.isBlock(node)) \n\t\t\t\t|| _.any(node.children, function(child) {\n\t\t\t\t\treturn this.isBlock(child);\n\t\t\t\t}, this);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Utility function that inserts content instead of <code>${child}</code>\n\t\t * variables on <code>text</code>\n\t\t * @param {String} text Text where child content should be inserted\n\t\t * @param {String} childContent Content to insert\n\t\t * @param {Object} options\n\t\t * @returns {String\n\t\t */\n\t\tinsertChildContent: function(text, childContent, options) {\n\t\t\toptions = _.extend({\n\t\t\t\tkeepVariable: true,\n\t\t\t\tappendIfNoChild: true\n\t\t\t}, options || {});\n\t\t\t\n\t\t\tvar childVariableReplaced = false;\n\t\t\tvar utils = require('utils');\n\t\t\ttext = utils.replaceVariables(text, function(variable, name, data) {\n\t\t\t\tvar output = variable;\n\t\t\t\tif (name == 'child') {\n\t\t\t\t\t// add correct indentation\n\t\t\t\t\toutput = utils.padString(childContent, utils.getLinePaddingFromPosition(text, data.start));\n\t\t\t\t\tchildVariableReplaced = true;\n\t\t\t\t\tif (options.keepVariable)\n\t\t\t\t\t\toutput += variable;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn output;\n\t\t\t});\n\t\t\t\n\t\t\tif (!childVariableReplaced && options.appendIfNoChild) {\n\t\t\t\ttext += childContent;\n\t\t\t}\n\t\t\t\n\t\t\treturn text;\n\t\t}\n\t};\n});/**\n * @author Sergey Chikuyonok (serge.che@gmail.com)\n * @link http://chikuyonok.ru\n */\nemmet.define('base64', function(require, _) {\n\tvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\t\n\treturn {\n\t\t/**\n\t\t * Encodes data using base64 algorithm\n\t\t * @author Tyler Akins (http://rumkin.com)\n\t\t * @param {String} input\n\t\t * @returns {String}\n\t\t * @memberOf emmet.base64\n\t\t */\n\t\tencode : function(input) {\n\t\t\tvar output = [];\n\t\t\tvar chr1, chr2, chr3, enc1, enc2, enc3, enc4, cdp1, cdp2, cdp3;\n\t\t\tvar i = 0, il = input.length, b64 = chars;\n\n\t\t\twhile (i < il) {\n\n\t\t\t\tcdp1 = input.charCodeAt(i++);\n\t\t\t\tcdp2 = input.charCodeAt(i++);\n\t\t\t\tcdp3 = input.charCodeAt(i++);\n\n\t\t\t\tchr1 = cdp1 & 0xff;\n\t\t\t\tchr2 = cdp2 & 0xff;\n\t\t\t\tchr3 = cdp3 & 0xff;\n\n\t\t\t\tenc1 = chr1 >> 2;\n\t\t\t\tenc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\n\t\t\t\tenc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\n\t\t\t\tenc4 = chr3 & 63;\n\n\t\t\t\tif (isNaN(cdp2)) {\n\t\t\t\t\tenc3 = enc4 = 64;\n\t\t\t\t} else if (isNaN(cdp3)) {\n\t\t\t\t\tenc4 = 64;\n\t\t\t\t}\n\n\t\t\t\toutput.push(b64.charAt(enc1) + b64.charAt(enc2) + b64.charAt(enc3) + b64.charAt(enc4));\n\t\t\t}\n\n\t\t\treturn output.join('');\n\t\t},\n\n\t\t/**\n\t\t * Decodes string using MIME base64 algorithm\n\t\t * \n\t\t * @author Tyler Akins (http://rumkin.com)\n\t\t * @param {String} data\n\t\t * @return {String}\n\t\t */\n\t\tdecode : function(data) {\n\t\t\tvar o1, o2, o3, h1, h2, h3, h4, bits, i = 0, ac = 0, tmpArr = [];\n\t\t\tvar b64 = chars, il = data.length;\n\n\t\t\tif (!data) {\n\t\t\t\treturn data;\n\t\t\t}\n\n\t\t\tdata += '';\n\n\t\t\tdo { // unpack four hexets into three octets using index points in b64\n\t\t\t\th1 = b64.indexOf(data.charAt(i++));\n\t\t\t\th2 = b64.indexOf(data.charAt(i++));\n\t\t\t\th3 = b64.indexOf(data.charAt(i++));\n\t\t\t\th4 = b64.indexOf(data.charAt(i++));\n\n\t\t\t\tbits = h1 << 18 | h2 << 12 | h3 << 6 | h4;\n\n\t\t\t\to1 = bits >> 16 & 0xff;\n\t\t\t\to2 = bits >> 8 & 0xff;\n\t\t\t\to3 = bits & 0xff;\n\n\t\t\t\tif (h3 == 64) {\n\t\t\t\t\ttmpArr[ac++] = String.fromCharCode(o1);\n\t\t\t\t} else if (h4 == 64) {\n\t\t\t\t\ttmpArr[ac++] = String.fromCharCode(o1, o2);\n\t\t\t\t} else {\n\t\t\t\t\ttmpArr[ac++] = String.fromCharCode(o1, o2, o3);\n\t\t\t\t}\n\t\t\t} while (i < il);\n\n\t\t\treturn tmpArr.join('');\n\t\t}\n\t};\n});/**\n * HTML matcher: takes string and searches for HTML tag pairs for given position \n * \n * Unlike “classic” matchers, it parses content from the specified \n * position, not from the start, so it may work even outside HTML documents\n * (for example, inside strings of programming languages like JavaScript, Python \n * etc.)\n * @constructor\n * @memberOf __htmlMatcherDefine\n */\nemmet.define('htmlMatcher', function(require, _) {\n\t// Regular Expressions for parsing tags and attributes\n\tvar reOpenTag = /^<([\\w\\:\\-]+)((?:\\s+[\\w\\-:]+(?:\\s*=\\s*(?:(?:\"[^\"]*\")|(?:'[^']*')|[^>\\s]+))?)*)\\s*(\\/?)>/;\n\tvar reCloseTag = /^<\\/([\\w\\:\\-]+)[^>]*>/;\n\t\n\tfunction openTag(i, match) {\n\t\treturn {\n\t\t\tname: match[1],\n\t\t\tselfClose: !!match[3],\n\t\t\t/** @type Range */\n\t\t\trange: require('range').create(i, match[0]),\n\t\t\ttype: 'open'\n\t\t};\n\t}\n\t\n\tfunction closeTag(i, match) {\n\t\treturn {\n\t\t\tname: match[1],\n\t\t\t/** @type Range */\n\t\t\trange: require('range').create(i, match[0]),\n\t\t\ttype: 'close'\n\t\t};\n\t}\n\t\n\tfunction comment(i, match) {\n\t\treturn {\n\t\t\t/** @type Range */\n\t\t\trange: require('range').create(i, _.isNumber(match) ? match - i : match[0]),\n\t\t\ttype: 'comment'\n\t\t};\n\t}\n\t\n\t/**\n\t * Creates new tag matcher session\n\t * @param {String} text\n\t */\n\tfunction createMatcher(text) {\n\t\tvar memo = {}, m;\n\t\treturn {\n\t\t\t/**\n\t\t\t * Test if given position matches opening tag\n\t\t\t * @param {Number} i\n\t\t\t * @returns {Object} Matched tag object\n\t\t\t */\n\t\t\topen: function(i) {\n\t\t\t\tvar m = this.matches(i);\n\t\t\t\treturn m && m.type == 'open' ? m : null;\n\t\t\t},\n\t\t\t\n\t\t\t/**\n\t\t\t * Test if given position matches closing tag\n\t\t\t * @param {Number} i\n\t\t\t * @returns {Object} Matched tag object\n\t\t\t */\n\t\t\tclose: function(i) {\n\t\t\t\tvar m = this.matches(i);\n\t\t\t\treturn m && m.type == 'close' ? m : null;\n\t\t\t},\n\t\t\t\n\t\t\t/**\n\t\t\t * Matches either opening or closing tag for given position\n\t\t\t * @param i\n\t\t\t * @returns\n\t\t\t */\n\t\t\tmatches: function(i) {\n\t\t\t\tvar key = 'p' + i;\n\t\t\t\t\n\t\t\t\tif (!(key in memo)) {\n\t\t\t\t\tif (text.charAt(i) == '<') {\n\t\t\t\t\t\tvar substr = text.slice(i);\n\t\t\t\t\t\tif (m = substr.match(reOpenTag)) {\n\t\t\t\t\t\t\tmemo[key] = openTag(i, m);\n\t\t\t\t\t\t} else if (m = substr.match(reCloseTag)) {\n\t\t\t\t\t\t\tmemo[key] = closeTag(i, m);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// remember that given position contains no valid tag\n\t\t\t\t\t\t\tmemo[key] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn memo[key];\n\t\t\t},\n\t\t\t\n\t\t\t/**\n\t\t\t * Returns original text\n\t\t\t * @returns {String}\n\t\t\t */\n\t\t\ttext: function() {\n\t\t\t\treturn text;\n\t\t\t}\n\t\t};\n\t}\n\t\n\tfunction matches(text, pos, pattern) {\n\t\treturn text.substring(pos, pos + pattern.length) == pattern;\n\t}\n\t\n\t/**\n\t * Search for closing pair of opening tag\n\t * @param {Object} open Open tag instance\n\t * @param {Object} matcher Matcher instance\n\t */\n\tfunction findClosingPair(open, matcher) {\n\t\tvar stack = [], tag = null;\n\t\tvar text = matcher.text();\n\t\t\n\t\tfor (var pos = open.range.end, len = text.length; pos < len; pos++) {\n\t\t\tif (matches(text, pos, '<!--')) {\n\t\t\t\t// skip to end of comment\n\t\t\t\tfor (var j = pos; j < len; j++) {\n\t\t\t\t\tif (matches(text, j, '-->')) {\n\t\t\t\t\t\tpos = j + 3;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (tag = matcher.matches(pos)) {\n\t\t\t\tif (tag.type == 'open' && !tag.selfClose) {\n\t\t\t\t\tstack.push(tag.name);\n\t\t\t\t} else if (tag.type == 'close') {\n\t\t\t\t\tif (!stack.length) { // found valid pair?\n\t\t\t\t\t\treturn tag.name == open.name ? tag : null;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// check if current closing tag matches previously opened one\n\t\t\t\t\tif (_.last(stack) == tag.name) {\n\t\t\t\t\t\tstack.pop();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar found = false;\n\t\t\t\t\t\twhile (stack.length && !found) {\n\t\t\t\t\t\t\tvar last = stack.pop();\n\t\t\t\t\t\t\tif (last == tag.name) {\n\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (!stack.length && !found) {\n\t\t\t\t\t\t\treturn tag.name == open.name ? tag : null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t\n\treturn {\n\t\t/**\n\t\t * Main function: search for tag pair in <code>text</code> for given \n\t\t * position\n\t\t * @memberOf htmlMatcher\n\t\t * @param {String} text \n\t\t * @param {Number} pos\n\t\t * @returns {Object}\n\t\t */\n\t\tfind: function(text, pos) {\n\t\t\tvar range = require('range');\n\t\t\tvar matcher = createMatcher(text); \n\t\t\tvar open = null, close = null;\n\t\t\t\n\t\t\tfor (var i = pos; i >= 0; i--) {\n\t\t\t\tif (open = matcher.open(i)) {\n\t\t\t\t\t// found opening tag\n\t\t\t\t\tif (open.selfClose) {\n\t\t\t\t\t\tif (open.range.cmp(pos, 'lt', 'gt')) {\n\t\t\t\t\t\t\t// inside self-closing tag, found match\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// outside self-closing tag, continue\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tclose = findClosingPair(open, matcher);\n\t\t\t\t\tif (close) {\n\t\t\t\t\t\t// found closing tag.\n\t\t\t\t\t\tvar r = range.create2(open.range.start, close.range.end);\n\t\t\t\t\t\tif (r.contains(pos)) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (open.range.contains(pos)) {\n\t\t\t\t\t\t// we inside empty HTML tag like <br>\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\topen = null;\n\t\t\t\t} else if (matches(text, i, '-->')) {\n\t\t\t\t\t// skip back to comment start\n\t\t\t\t\tfor (var j = i - 1; j >= 0; j--) {\n\t\t\t\t\t\tif (matches(text, j, '-->')) {\n\t\t\t\t\t\t\t// found another comment end, do nothing\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if (matches(text, j, '<!--')) {\n\t\t\t\t\t\t\ti = j;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (matches(text, i, '<!--')) {\n\t\t\t\t\t// we're inside comment, match it\n\t\t\t\t\tvar j = i + 4, jl = text.length;\n\t\t\t\t\tfor (; j < jl; j++) {\n\t\t\t\t\t\tif (matches(text, j, '-->')) {\n\t\t\t\t\t\t\tj += 3;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\topen = comment(i, j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (open) {\n\t\t\t\tvar outerRange = null;\n\t\t\t\tvar innerRange = null;\n\t\t\t\t\n\t\t\t\tif (close) {\n\t\t\t\t\touterRange = range.create2(open.range.start, close.range.end);\n\t\t\t\t\tinnerRange = range.create2(open.range.end, close.range.start);\n\t\t\t\t} else {\n\t\t\t\t\touterRange = innerRange = range.create2(open.range.start, open.range.end);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (open.type == 'comment') {\n\t\t\t\t\t// adjust positions of inner range for comment\n\t\t\t\t\tvar _c = outerRange.substring(text);\n\t\t\t\t\tinnerRange.start += _c.length - _c.replace(/^<\\!--\\s*/, '').length;\n\t\t\t\t\tinnerRange.end -= _c.length - _c.replace(/\\s*-->$/, '').length;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn {\n\t\t\t\t\topen: open,\n\t\t\t\t\tclose: close,\n\t\t\t\t\ttype: open.type == 'comment' ? 'comment' : 'tag',\n\t\t\t\t\tinnerRange: innerRange,\n\t\t\t\t\tinnerContent: function() {\n\t\t\t\t\t\treturn this.innerRange.substring(text);\n\t\t\t\t\t},\n\t\t\t\t\touterRange: outerRange,\n\t\t\t\t\touterContent: function() {\n\t\t\t\t\t\treturn this.outerRange.substring(text);\n\t\t\t\t\t},\n\t\t\t\t\trange: !innerRange.length() || !innerRange.cmp(pos, 'lte', 'gte') ? outerRange : innerRange,\n\t\t\t\t\tcontent: function() {\n\t\t\t\t\t\treturn this.range.substring(text);\n\t\t\t\t\t},\n\t\t\t\t\tsource: text\n\t\t\t\t};\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * The same as <code>find()</code> method, but restricts matched result \n\t\t * to <code>tag</code> type\n\t\t * @param {String} text \n\t\t * @param {Number} pos\n\t\t * @returns {Object}\n\t\t */\n\t\ttag: function(text, pos) {\n\t\t\tvar result = this.find(text, pos);\n\t\t\tif (result && result.type == 'tag') {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t};\n});/**\n * Utility module for handling tabstops tokens generated by Emmet's \n * \"Expand Abbreviation\" action. The main <code>extract</code> method will take\n * raw text (for example: <i>${0} some ${1:text}</i>), find all tabstops \n * occurrences, replace them with tokens suitable for your editor of choice and \n * return object with processed text and list of found tabstops and their ranges.\n * For sake of portability (Objective-C/Java) the tabstops list is a plain \n * sorted array with plain objects.\n * \n * Placeholders with the same are meant to be <i>linked</i> in your editor.\n * @param {Function} require\n * @param {Underscore} _  \n */\nemmet.define('tabStops', function(require, _) {\n\t/**\n\t * Global placeholder value, automatically incremented by \n\t * <code>variablesResolver()</code> function\n\t */\n\tvar startPlaceholderNum = 100;\n\t\n\tvar tabstopIndex = 0;\n\t\n\tvar defaultOptions = {\n\t\treplaceCarets: false,\n\t\tescape: function(ch) {\n\t\t\treturn '\\\\' + ch;\n\t\t},\n\t\ttabstop: function(data) {\n\t\t\treturn data.token;\n\t\t},\n\t\tvariable: function(data) {\n\t\t\treturn data.token;\n\t\t}\n\t};\n\t\n\t// XXX register output processor that will upgrade tabstops of parsed node\n\t// in order to prevent tabstop index conflicts\n\trequire('abbreviationParser').addOutputProcessor(function(text, node, type) {\n\t\tvar maxNum = 0;\n\t\tvar tabstops = require('tabStops');\n\t\tvar utils = require('utils');\n\t\t\n\t\tvar tsOptions = {\n\t\t\ttabstop: function(data) {\n\t\t\t\tvar group = parseInt(data.group);\n\t\t\t\tif (group == 0)\n\t\t\t\t\treturn '${0}';\n\t\t\t\t\n\t\t\t\tif (group > maxNum) maxNum = group;\n\t\t\t\tif (data.placeholder) {\n\t\t\t\t\t// respect nested placeholders\n\t\t\t\t\tvar ix = group + tabstopIndex;\n\t\t\t\t\tvar placeholder = tabstops.processText(data.placeholder, tsOptions);\n\t\t\t\t\treturn '${' + ix + ':' + placeholder + '}';\n\t\t\t\t} else {\n\t\t\t\t\treturn '${' + (group + tabstopIndex) + '}';\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\t\n\t\t// upgrade tabstops\n\t\ttext = tabstops.processText(text, tsOptions);\n\t\t\n\t\t// resolve variables\n\t\ttext = utils.replaceVariables(text, tabstops.variablesResolver(node));\n\t\t\n\t\ttabstopIndex += maxNum + 1;\n\t\treturn text;\n\t});\n\t\n\treturn {\n\t\t/**\n\t\t * Main function that looks for a tabstops in provided <code>text</code>\n\t\t * and returns a processed version of <code>text</code> with expanded \n\t\t * placeholders and list of tabstops found.\n\t\t * @param {String} text Text to process\n\t\t * @param {Object} options List of processor options:<br>\n\t\t * \n\t\t * <b>replaceCarets</b> : <code>Boolean</code> — replace all default\n\t\t * caret placeholders (like <i>{%::emmet-caret::%}</i>) with <i>${0:caret}</i><br>\n\t\t * \n\t\t * <b>escape</b> : <code>Function</code> — function that handle escaped\n\t\t * characters (mostly '$'). By default, it returns the character itself \n\t\t * to be displayed as is in output, but sometimes you will use \n\t\t * <code>extract</code> method as intermediate solution for further \n\t\t * processing and want to keep character escaped. Thus, you should override\n\t\t * <code>escape</code> method to return escaped symbol (e.g. '\\\\$')<br>\n\t\t * \n\t\t * <b>tabstop</b> : <code>Function</code> – a tabstop handler. Receives \n\t\t * a single argument – an object describing token: its position, number \n\t\t * group, placeholder and token itself. Should return a replacement \n\t\t * string that will appear in final output\n\t\t * \n\t\t * <b>variable</b> : <code>Function</code> – variable handler. Receives \n\t\t * a single argument – an object describing token: its position, name \n\t\t * and original token itself. Should return a replacement \n\t\t * string that will appear in final output\n\t\t * \n\t\t * @returns {Object} Object with processed <code>text</code> property\n\t\t * and array of <code>tabstops</code> found\n\t\t * @memberOf tabStops\n\t\t */\n\t\textract: function(text, options) {\n\t\t\t// prepare defaults\n\t\t\tvar utils = require('utils');\n\t\t\tvar placeholders = {carets: ''};\n\t\t\tvar marks = [];\n\t\t\t\n\t\t\toptions = _.extend({}, defaultOptions, options, {\n\t\t\t\ttabstop: function(data) {\n\t\t\t\t\tvar token = data.token;\n\t\t\t\t\tvar ret = '';\n\t\t\t\t\tif (data.placeholder == 'cursor') {\n\t\t\t\t\t\tmarks.push({\n\t\t\t\t\t\t\tstart: data.start,\n\t\t\t\t\t\t\tend: data.start + token.length,\n\t\t\t\t\t\t\tgroup: 'carets',\n\t\t\t\t\t\t\tvalue: ''\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// unify placeholder value for single group\n\t\t\t\t\t\tif ('placeholder' in data)\n\t\t\t\t\t\t\tplaceholders[data.group] = data.placeholder;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (data.group in placeholders)\n\t\t\t\t\t\t\tret = placeholders[data.group];\n\t\t\t\t\t\t\n\t\t\t\t\t\tmarks.push({\n\t\t\t\t\t\t\tstart: data.start,\n\t\t\t\t\t\t\tend: data.start + token.length,\n\t\t\t\t\t\t\tgroup: data.group,\n\t\t\t\t\t\t\tvalue: ret\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\treturn token;\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\tif (options.replaceCarets) {\n\t\t\t\ttext = text.replace(new RegExp( utils.escapeForRegexp( utils.getCaretPlaceholder() ), 'g'), '${0:cursor}');\n\t\t\t}\n\t\t\t\n\t\t\t// locate tabstops and unify group's placeholders\n\t\t\ttext = this.processText(text, options);\n\t\t\t\n\t\t\t// now, replace all tabstops with placeholders\n\t\t\tvar buf = utils.stringBuilder(), lastIx = 0;\n\t\t\tvar tabStops = _.map(marks, function(mark) {\n\t\t\t\tbuf.append(text.substring(lastIx, mark.start));\n\t\t\t\t\n\t\t\t\tvar pos = buf.length;\n\t\t\t\tvar ph = placeholders[mark.group] || '';\n\t\t\t\t\n\t\t\t\tbuf.append(ph);\n\t\t\t\tlastIx = mark.end;\n\t\t\t\t\n\t\t\t\treturn {\n\t\t\t\t\tgroup: mark.group,\n\t\t\t\t\tstart: pos,\n\t\t\t\t\tend:  pos + ph.length\n\t\t\t\t};\n\t\t\t});\n\t\t\t\n\t\t\tbuf.append(text.substring(lastIx));\n\t\t\t\n\t\t\treturn {\n\t\t\t\ttext: buf.toString(),\n\t\t\t\ttabstops: _.sortBy(tabStops, 'start')\n\t\t\t};\n\t\t},\n\t\t\n\t\t/**\n\t\t * Text processing routine. Locates escaped characters and tabstops and\n\t\t * replaces them with values returned by handlers defined in \n\t\t * <code>options</code>\n\t\t * @param {String} text\n\t\t * @param {Object} options See <code>extract</code> method options \n\t\t * description\n\t\t * @returns {String}\n\t\t */\n\t\tprocessText: function(text, options) {\n\t\t\toptions = _.extend({}, defaultOptions, options);\n\t\t\t\n\t\t\tvar buf = require('utils').stringBuilder();\n\t\t\t/** @type StringStream */\n\t\t\tvar stream = require('stringStream').create(text);\n\t\t\tvar ch, m, a;\n\t\t\t\n\t\t\twhile (ch = stream.next()) {\n\t\t\t\tif (ch == '\\\\' && !stream.eol()) {\n\t\t\t\t\t// handle escaped character\n\t\t\t\t\tbuf.append(options.escape(stream.next()));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ta = ch;\n\t\t\t\t\n\t\t\t\tif (ch == '$') {\n\t\t\t\t\t// looks like a tabstop\n\t\t\t\t\tstream.start = stream.pos - 1;\n\t\t\t\t\t\n\t\t\t\t\tif (m = stream.match(/^[0-9]+/)) {\n\t\t\t\t\t\t// it's $N\n\t\t\t\t\t\ta = options.tabstop({\n\t\t\t\t\t\t\tstart: buf.length, \n\t\t\t\t\t\t\tgroup: stream.current().substr(1),\n\t\t\t\t\t\t\ttoken: stream.current()\n\t\t\t\t\t\t});\n\t\t\t\t\t} else if (m = stream.match(/^\\{([a-z_\\-][\\w\\-]*)\\}/)) {\n\t\t\t\t\t\t// ${variable}\n\t\t\t\t\t\ta = options.variable({\n\t\t\t\t\t\t\tstart: buf.length, \n\t\t\t\t\t\t\tname: m[1],\n\t\t\t\t\t\t\ttoken: stream.current()\n\t\t\t\t\t\t});\n\t\t\t\t\t} else if (m = stream.match(/^\\{([0-9]+)(:.+?)?\\}/, false)) {\n\t\t\t\t\t\t// ${N:value} or ${N} placeholder\n\t\t\t\t\t\t// parse placeholder, including nested ones\n\t\t\t\t\t\tstream.skipToPair('{', '}');\n\t\t\t\t\t\t\n\t\t\t\t\t\tvar obj = {\n\t\t\t\t\t\t\tstart: buf.length, \n\t\t\t\t\t\t\tgroup: m[1],\n\t\t\t\t\t\t\ttoken: stream.current()\n\t\t\t\t\t\t};\n\t\t\t\t\t\t\n\t\t\t\t\t\tvar placeholder = obj.token.substring(obj.group.length + 2, obj.token.length - 1);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (placeholder) {\n\t\t\t\t\t\t\tobj.placeholder = placeholder.substr(1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\ta = options.tabstop(obj);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbuf.append(a);\n\t\t\t}\n\t\t\t\n\t\t\treturn buf.toString();\n\t\t},\n\t\t\n\t\t/**\n\t\t * Upgrades tabstops in output node in order to prevent naming conflicts\n\t\t * @param {AbbreviationNode} node\n\t\t * @param {Number} offset Tab index offset\n\t\t * @returns {Number} Maximum tabstop index in element\n\t\t */\n\t\tupgrade: function(node, offset) {\n\t\t\tvar maxNum = 0;\n\t\t\tvar options = {\n\t\t\t\ttabstop: function(data) {\n\t\t\t\t\tvar group = parseInt(data.group);\n\t\t\t\t\tif (group > maxNum) maxNum = group;\n\t\t\t\t\t\t\n\t\t\t\t\tif (data.placeholder)\n\t\t\t\t\t\treturn '${' + (group + offset) + ':' + data.placeholder + '}';\n\t\t\t\t\telse\n\t\t\t\t\t\treturn '${' + (group + offset) + '}';\n\t\t\t\t}\n\t\t\t};\n\t\t\t\n\t\t\t_.each(['start', 'end', 'content'], function(p) {\n\t\t\t\tnode[p] = this.processText(node[p], options);\n\t\t\t}, this);\n\t\t\t\n\t\t\treturn maxNum;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Helper function that produces a callback function for \n\t\t * <code>replaceVariables()</code> method from {@link utils}\n\t\t * module. This callback will replace variable definitions (like \n\t\t * ${var_name}) with their value defined in <i>resource</i> module,\n\t\t * or outputs tabstop with variable name otherwise.\n\t\t * @param {AbbreviationNode} node Context node\n\t\t * @returns {Function}\n\t\t */\n\t\tvariablesResolver: function(node) {\n\t\t\tvar placeholderMemo = {};\n\t\t\tvar res = require('resources');\n\t\t\treturn function(str, varName) {\n\t\t\t\t// do not mark `child` variable as placeholder – it‘s a reserved\n\t\t\t\t// variable name\n\t\t\t\tif (varName == 'child')\n\t\t\t\t\treturn str;\n\t\t\t\t\n\t\t\t\tif (varName == 'cursor')\n\t\t\t\t\treturn require('utils').getCaretPlaceholder();\n\t\t\t\t\n\t\t\t\tvar attr = node.attribute(varName);\n\t\t\t\tif (!_.isUndefined(attr) && attr !== str) {\n\t\t\t\t\treturn attr;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar varValue = res.getVariable(varName);\n\t\t\t\tif (varValue)\n\t\t\t\t\treturn varValue;\n\t\t\t\t\n\t\t\t\t// output as placeholder\n\t\t\t\tif (!placeholderMemo[varName])\n\t\t\t\t\tplaceholderMemo[varName] = startPlaceholderNum++;\n\t\t\t\t\t\n\t\t\t\treturn '${' + placeholderMemo[varName] + ':' + varName + '}';\n\t\t\t};\n\t\t},\n\t\t\n\t\t/**\n\t\t * Resets global tabstop index. When parsed tree is converted to output\n\t\t * string (<code>AbbreviationNode.toString()</code>), all tabstops \n\t\t * defined in snippets and elements are upgraded in order to prevent\n\t\t * naming conflicts of nested. For example, <code>${1}</code> of a node\n\t\t * should not be linked with the same placehilder of the child node.\n\t\t * By default, <code>AbbreviationNode.toString()</code> automatically\n\t\t * upgrades tabstops of the same index for each node and writes maximum\n\t\t * tabstop index into the <code>tabstopIndex</code> variable. To keep\n\t\t * this variable at reasonable value, it is recommended to call \n\t\t * <code>resetTabstopIndex()</code> method each time you expand variable \n\t\t * @returns\n\t\t */\n\t\tresetTabstopIndex: function() {\n\t\t\ttabstopIndex = 0;\n\t\t\tstartPlaceholderNum = 100;\n\t\t}\n\t};\n});/**\n * Common module's preferences storage. This module \n * provides general storage for all module preferences, their description and\n * default values.<br><br>\n * \n * This module can also be used to list all available properties to create \n * UI for updating properties\n * \n * @memberOf __preferencesDefine\n * @constructor\n * @param {Function} require\n * @param {Underscore} _ \n */\nemmet.define('preferences', function(require, _) {\n\tvar preferences = {};\n\tvar defaults = {};\n\tvar _dbgDefaults = null;\n\tvar _dbgPreferences = null;\n\n\tfunction toBoolean(val) {\n\t\tif (_.isString(val)) {\n\t\t\tval = val.toLowerCase();\n\t\t\treturn val == 'yes' || val == 'true' || val == '1';\n\t\t}\n\n\t\treturn !!val;\n\t}\n\t\n\tfunction isValueObj(obj) {\n\t\treturn _.isObject(obj) \n\t\t\t&& 'value' in obj \n\t\t\t&& _.keys(obj).length < 3;\n\t}\n\t\n\treturn {\n\t\t/**\n\t\t * Creates new preference item with default value\n\t\t * @param {String} name Preference name. You can also pass object\n\t\t * with many options\n\t\t * @param {Object} value Preference default value\n\t\t * @param {String} description Item textual description\n\t\t * @memberOf preferences\n\t\t */\n\t\tdefine: function(name, value, description) {\n\t\t\tvar prefs = name;\n\t\t\tif (_.isString(name)) {\n\t\t\t\tprefs = {};\n\t\t\t\tprefs[name] = {\n\t\t\t\t\tvalue: value,\n\t\t\t\t\tdescription: description\n\t\t\t\t};\n\t\t\t}\n\t\t\t\n\t\t\t_.each(prefs, function(v, k) {\n\t\t\t\tdefaults[k] = isValueObj(v) ? v : {value: v};\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Updates preference item value. Preference value should be defined\n\t\t * first with <code>define</code> method.\n\t\t * @param {String} name Preference name. You can also pass object\n\t\t * with many options\n\t\t * @param {Object} value Preference default value\n\t\t * @memberOf preferences\n\t\t */\n\t\tset: function(name, value) {\n\t\t\tvar prefs = name;\n\t\t\tif (_.isString(name)) {\n\t\t\t\tprefs = {};\n\t\t\t\tprefs[name] = value;\n\t\t\t}\n\t\t\t\n\t\t\t_.each(prefs, function(v, k) {\n\t\t\t\tif (!(k in defaults)) {\n\t\t\t\t\tthrow 'Property \"' + k + '\" is not defined. You should define it first with `define` method of current module';\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// do not set value if it equals to default value\n\t\t\t\tif (v !== defaults[k].value) {\n\t\t\t\t\t// make sure we have value of correct type\n\t\t\t\t\tswitch (typeof defaults[k].value) {\n\t\t\t\t\t\tcase 'boolean':\n\t\t\t\t\t\t\tv = toBoolean(v);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'number':\n\t\t\t\t\t\t\tv = parseInt(v + '', 10) || 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault: // convert to string\n\t\t\t\t\t\t\tif (v !== null) {\n\t\t\t\t\t\t\t\tv += '';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tpreferences[k] = v;\n\t\t\t\t} else if  (k in preferences) {\n\t\t\t\t\tdelete preferences[k];\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns preference value\n\t\t * @param {String} name\n\t\t * @returns {String} Returns <code>undefined</code> if preference is \n\t\t * not defined\n\t\t */\n\t\tget: function(name) {\n\t\t\tif (name in preferences)\n\t\t\t\treturn preferences[name];\n\t\t\t\n\t\t\tif (name in defaults)\n\t\t\t\treturn defaults[name].value;\n\t\t\t\n\t\t\treturn void 0;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns comma-separated preference value as array of values\n\t\t * @param {String} name\n\t\t * @returns {Array} Returns <code>undefined</code> if preference is \n\t\t * not defined, <code>null</code> if string cannot be converted to array\n\t\t */\n\t\tgetArray: function(name) {\n\t\t\tvar val = this.get(name);\n\t\t\tif (_.isUndefined(val) || val === null || val === '')  {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tval = _.map(val.split(','), require('utils').trim);\n\t\t\tif (!val.length) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t\n\t\t\treturn val;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns comma and colon-separated preference value as dictionary\n\t\t * @param {String} name\n\t\t * @returns {Object}\n\t\t */\n\t\tgetDict: function(name) {\n\t\t\tvar result = {};\n\t\t\t_.each(this.getArray(name), function(val) {\n\t\t\t\tvar parts = val.split(':');\n\t\t\t\tresult[parts[0]] = parts[1];\n\t\t\t});\n\t\t\t\n\t\t\treturn result;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns description of preference item\n\t\t * @param {String} name Preference name\n\t\t * @returns {Object}\n\t\t */\n\t\tdescription: function(name) {\n\t\t\treturn name in defaults ? defaults[name].description : void 0;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Completely removes specified preference(s)\n\t\t * @param {String} name Preference name (or array of names)\n\t\t */\n\t\tremove: function(name) {\n\t\t\tif (!_.isArray(name))\n\t\t\t\tname = [name];\n\t\t\t\n\t\t\t_.each(name, function(key) {\n\t\t\t\tif (key in preferences)\n\t\t\t\t\tdelete preferences[key];\n\t\t\t\t\n\t\t\t\tif (key in defaults)\n\t\t\t\t\tdelete defaults[key];\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns sorted list of all available properties\n\t\t * @returns {Array}\n\t\t */\n\t\tlist: function() {\n\t\t\treturn _.map(_.keys(defaults).sort(), function(key) {\n\t\t\t\treturn {\n\t\t\t\t\tname: key,\n\t\t\t\t\tvalue: this.get(key),\n\t\t\t\t\ttype: typeof defaults[key].value,\n\t\t\t\t\tdescription: defaults[key].description\n\t\t\t\t};\n\t\t\t}, this);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Loads user-defined preferences from JSON\n\t\t * @param {Object} json\n\t\t * @returns\n\t\t */\n\t\tload: function(json) {\n\t\t\t_.each(json, function(value, key) {\n\t\t\t\tthis.set(key, value);\n\t\t\t}, this);\n\t\t},\n\n\t\t/**\n\t\t * Returns hash of user-modified preferences\n\t\t * @returns {Object}\n\t\t */\n\t\texportModified: function() {\n\t\t\treturn _.clone(preferences);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Reset to defaults\n\t\t * @returns\n\t\t */\n\t\treset: function() {\n\t\t\tpreferences = {};\n\t\t},\n\t\t\n\t\t/**\n\t\t * For unit testing: use empty storage\n\t\t */\n\t\t_startTest: function() {\n\t\t\t_dbgDefaults = defaults;\n\t\t\t_dbgPreferences = preferences;\n\t\t\tdefaults = {};\n\t\t\tpreferences = {};\n\t\t},\n\t\t\n\t\t/**\n\t\t * For unit testing: restore original storage\n\t\t */\n\t\t_stopTest: function() {\n\t\t\tdefaults = _dbgDefaults;\n\t\t\tpreferences = _dbgPreferences;\n\t\t}\n\t};\n});/**\n * Module for handling filters\n * @param {Function} require\n * @param {Underscore} _\n * @author Sergey Chikuyonok (serge.che@gmail.com) <http://chikuyonok.ru>\n */\nemmet.define('filters', function(require, _) {\n\t/** List of registered filters */\n\tvar registeredFilters = {};\n\t\n\t/** Filters that will be applied for unknown syntax */\n\tvar basicFilters = 'html';\n\t\n\tfunction list(filters) {\n\t\tif (!filters)\n\t\t\treturn [];\n\t\t\n\t\tif (_.isString(filters))\n\t\t\treturn filters.split(/[\\|,]/g);\n\t\t\n\t\treturn filters;\n\t}\n\t\n\treturn  {\n\t\t/**\n\t\t * Register new filter\n\t\t * @param {String} name Filter name\n\t\t * @param {Function} fn Filter function\n\t\t */\n\t\tadd: function(name, fn) {\n\t\t\tregisteredFilters[name] = fn;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Apply filters for final output tree\n\t\t * @param {AbbreviationNode} tree Output tree\n\t\t * @param {Array} filters List of filters to apply. Might be a \n\t\t * <code>String</code>\n\t\t * @param {Object} profile Output profile, defined in <i>profile</i> \n\t\t * module. Filters defined it profile are not used, <code>profile</code>\n\t\t * is passed to filter function\n\t\t * @memberOf emmet.filters\n\t\t * @returns {AbbreviationNode}\n\t\t */\n\t\tapply: function(tree, filters, profile) {\n\t\t\tvar utils = require('utils');\n\t\t\tprofile = require('profile').get(profile);\n\t\t\t\n\t\t\t_.each(list(filters), function(filter) {\n\t\t\t\tvar name = utils.trim(filter.toLowerCase());\n\t\t\t\tif (name && name in registeredFilters) {\n\t\t\t\t\ttree = registeredFilters[name](tree, profile);\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\treturn tree;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Composes list of filters that should be applied to a tree, based on \n\t\t * passed data\n\t\t * @param {String} syntax Syntax name ('html', 'css', etc.)\n\t\t * @param {Object} profile Output profile\n\t\t * @param {String} additionalFilters List or pipe-separated\n\t\t * string of additional filters to apply\n\t\t * @returns {Array}\n\t\t */\n\t\tcomposeList: function(syntax, profile, additionalFilters) {\n\t\t\tprofile = require('profile').get(profile);\n\t\t\tvar filters = list(profile.filters || require('resources').findItem(syntax, 'filters') || basicFilters);\n\t\t\t\n\t\t\tif (profile.extraFilters) {\n\t\t\t\tfilters = filters.concat(list(profile.extraFilters));\n\t\t\t}\n\t\t\t\t\n\t\t\tif (additionalFilters) {\n\t\t\t\tfilters = filters.concat(list(additionalFilters));\n\t\t\t}\n\t\t\t\t\n\t\t\tif (!filters || !filters.length) {\n\t\t\t\t// looks like unknown syntax, apply basic filters\n\t\t\t\tfilters = list(basicFilters);\n\t\t\t}\n\t\t\t\t\n\t\t\treturn filters;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Extracts filter list from abbreviation\n\t\t * @param {String} abbr\n\t\t * @returns {Array} Array with cleaned abbreviation and list of \n\t\t * extracted filters\n\t\t */\n\t\textractFromAbbreviation: function(abbr) {\n\t\t\tvar filters = '';\n\t\t\tabbr = abbr.replace(/\\|([\\w\\|\\-]+)$/, function(str, p1){\n\t\t\t\tfilters = p1;\n\t\t\t\treturn '';\n\t\t\t});\n\t\t\t\n\t\t\treturn [abbr, list(filters)];\n\t\t}\n\t};\n});/**\n * Module that contains factories for element types used by Emmet\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.define('elements', function(require, _) {\n\tvar factories = {};\n\tvar reAttrs = /([\\w\\-:]+)\\s*=\\s*(['\"])(.*?)\\2/g;\n\t\n\tvar result = {\n\t\t/**\n\t\t * Create new element factory\n\t\t * @param {String} name Element identifier\n\t\t * @param {Function} factory Function that produces element of specified \n\t\t * type. The object generated by this factory is automatically \n\t\t * augmented with <code>type</code> property pointing to element\n\t\t * <code>name</code>\n\t\t * @memberOf elements\n\t\t */\n\t\tadd: function(name, factory) {\n\t\t\tvar that = this;\n\t\t\tfactories[name] = function() {\n\t\t\t\tvar elem = factory.apply(that, arguments);\n\t\t\t\tif (elem)\n\t\t\t\t\telem.type = name;\n\t\t\t\t\n\t\t\t\treturn elem;\n\t\t\t};\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns factory for specified name\n\t\t * @param {String} name\n\t\t * @returns {Function}\n\t\t */\n\t\tget: function(name) {\n\t\t\treturn factories[name];\n\t\t},\n\t\t\n\t\t/**\n\t\t * Creates new element with specified type\n\t\t * @param {String} name\n\t\t * @returns {Object}\n\t\t */\n\t\tcreate: function(name) {\n\t\t\tvar args = [].slice.call(arguments, 1);\n\t\t\tvar factory = this.get(name);\n\t\t\treturn factory ? factory.apply(this, args) : null;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if passed element is of specified type\n\t\t * @param {Object} elem\n\t\t * @param {String} type\n\t\t * @returns {Boolean}\n\t\t */\n\t\tis: function(elem, type) {\n\t\t\treturn elem && elem.type === type;\n\t\t}\n\t};\n\t\n\t// register resource references\n\tfunction commonFactory(value) {\n\t\treturn {data: value};\n\t}\n\t\n\t/**\n\t * Element factory\n\t * @param {String} elementName Name of output element\n\t * @param {String} attrs Attributes definition. You may also pass\n\t * <code>Array</code> where each contains object with <code>name</code> \n\t * and <code>value</code> properties, or <code>Object</code>\n\t * @param {Boolean} isEmpty Is expanded element should be empty\n\t */\n\tresult.add('element', function(elementName, attrs, isEmpty) {\n\t\tvar ret = {\n\t\t\t/** @memberOf __emmetDataElement */\n\t\t\tname: elementName,\n\t\t\tis_empty: !!isEmpty\n\t\t};\n\t\t\n\t\tif (attrs) {\n\t\t\tret.attributes = [];\n\t\t\tif (_.isArray(attrs)) {\n\t\t\t\tret.attributes = attrs;\n\t\t\t} else if (_.isString(attrs)) {\n\t\t\t\tvar m;\n\t\t\t\twhile (m = reAttrs.exec(attrs)) {\n\t\t\t\t\tret.attributes.push({\n\t\t\t\t\t\tname: m[1],\n\t\t\t\t\t\tvalue: m[3]\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t_.each(attrs, function(value, name) {\n\t\t\t\t\tret.attributes.push({\n\t\t\t\t\t\tname: name, \n\t\t\t\t\t\tvalue: value\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn ret;\n\t});\n\t\n\tresult.add('snippet', commonFactory);\n\tresult.add('reference', commonFactory);\n\tresult.add('empty', function() {\n\t\treturn {};\n\t});\n\t\n\treturn result;\n});/**\n * Abstract implementation of edit tree interface.\n * Edit tree is a named container of editable “name-value” child elements, \n * parsed from <code>source</code>. This container provides convenient methods\n * for editing/adding/removing child elements. All these update actions are\n * instantly reflected in the <code>source</code> code with respect of formatting.\n * <br><br>\n * For example, developer can create an edit tree from CSS rule and add or \n * remove properties from it–all changes will be immediately reflected in the \n * original source.\n * <br><br>\n * All classes defined in this module should be extended the same way as in\n * Backbone framework: using <code>extend</code> method to create new class and \n * <code>initialize</code> method to define custom class constructor.\n * \n * @example\n * <pre><code>\n * var MyClass = require('editTree').EditElement.extend({\n * \tinitialize: function() {\n * \t\t// constructor code here\n * \t}\n * });\n * \n * var elem = new MyClass(); \n * </code></pre>\n * \n * \n * @param {Function} require\n * @param {Underscore} _\n * @constructor\n * @memberOf __editTreeDefine\n */\nemmet.define('editTree', function(require, _, core) {\n\tvar range = require('range').create;\n\t\n\t/**\n\t * Named container of edited source\n\t * @type EditContainer\n\t * @param {String} source\n\t * @param {Object} options\n\t */\n\tfunction EditContainer(source, options) {\n\t\tthis.options = _.extend({offset: 0}, options);\n\t\t/**\n\t\t * Source code of edited structure. All changes in the structure are \n\t\t * immediately reflected into this property\n\t\t */\n\t\tthis.source = source;\n\t\t\n\t\t/** \n\t\t * List of all editable children\n\t\t * @private \n\t\t */\n\t\tthis._children = [];\n\t\t\n\t\t/**\n\t\t * Hash of all positions of container\n\t\t * @private\n\t\t */\n\t\tthis._positions = {\n\t\t\tname: 0\n\t\t};\n\t\t\n\t\tthis.initialize.apply(this, arguments);\n\t}\n\t\n\t/**\n\t * The self-propagating extend function for classes.\n\t * @type Function\n\t */\n\tEditContainer.extend = core.extend;\n\t\n\tEditContainer.prototype = {\n\t\t/**\n\t\t * Child class constructor\n\t\t */\n\t\tinitialize: function() {},\n\t\t\n\t\t/**\n\t\t * Replace substring of tag's source\n\t\t * @param {String} value\n\t\t * @param {Number} start\n\t\t * @param {Number} end\n\t\t * @private\n\t\t */\n\t\t_updateSource: function(value, start, end) {\n\t\t\t// create modification range\n\t\t\tvar r = range(start, _.isUndefined(end) ? 0 : end - start);\n\t\t\tvar delta = value.length - r.length();\n\t\t\t\n\t\t\tvar update = function(obj) {\n\t\t\t\t_.each(obj, function(v, k) {\n\t\t\t\t\tif (v >= r.end)\n\t\t\t\t\t\tobj[k] += delta;\n\t\t\t\t});\n\t\t\t};\n\t\t\t\n\t\t\t// update affected positions of current container\n\t\t\tupdate(this._positions);\n\t\t\t\n\t\t\t// update affected positions of children\n\t\t\t_.each(this.list(), function(item) {\n\t\t\t\tupdate(item._positions);\n\t\t\t});\n\t\t\t\n\t\t\tthis.source = require('utils').replaceSubstring(this.source, value, r);\n\t\t},\n\t\t\t\n\t\t\t\n\t\t/**\n\t\t * Adds new attribute \n\t\t * @param {String} name Property name\n\t\t * @param {String} value Property value\n\t\t * @param {Number} pos Position at which to insert new property. By \n\t\t * default the property is inserted at the end of rule \n\t\t * @returns {EditElement} Newly created element\n\t\t */\n\t\tadd: function(name, value, pos) {\n\t\t\t// this is abstract implementation\n\t\t\tvar item = new EditElement(name, value);\n\t\t\tthis._children.push(item);\n\t\t\treturn item;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns attribute object\n\t\t * @param {String} name Attribute name or its index\n\t\t * @returns {EditElement}\n\t\t */\n\t\tget: function(name) {\n\t\t\tif (_.isNumber(name))\n\t\t\t\treturn this.list()[name];\n\t\t\t\n\t\t\tif (_.isString(name))\n\t\t\t\treturn _.find(this.list(), function(prop) {\n\t\t\t\t\treturn prop.name() === name;\n\t\t\t\t});\n\t\t\t\n\t\t\treturn name;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns all children by name or indexes\n\t\t * @param {Object} name Element name(s) or indexes (<code>String</code>,\n\t\t * <code>Array</code>, <code>Number</code>)\n\t\t * @returns {Array}\n\t\t */\n\t\tgetAll: function(name) {\n\t\t\tif (!_.isArray(name))\n\t\t\t\tname = [name];\n\t\t\t\n\t\t\t// split names and indexes\n\t\t\tvar names = [], indexes = [];\n\t\t\t_.each(name, function(item) {\n\t\t\t\tif (_.isString(item))\n\t\t\t\t\tnames.push(item);\n\t\t\t\telse if (_.isNumber(item))\n\t\t\t\t\tindexes.push(item);\n\t\t\t});\n\t\t\t\n\t\t\treturn _.filter(this.list(), function(attribute, i) {\n\t\t\t\treturn _.include(indexes, i) || _.include(names, attribute.name());\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns or updates element value. If such element doesn't exists,\n\t\t * it will be created automatically and added at the end of child list.\n\t\t * @param {String} name Element name or its index\n\t\t * @param {String} value New element value\n\t\t * @returns {String}\n\t\t */\n\t\tvalue: function(name, value, pos) {\n\t\t\tvar element = this.get(name);\n\t\t\tif (element)\n\t\t\t\treturn element.value(value);\n\t\t\t\n\t\t\tif (!_.isUndefined(value)) {\n\t\t\t\t// no such element — create it\n\t\t\t\treturn this.add(name, value, pos);\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns all values of child elements found by <code>getAll()</code>\n\t\t * method\n\t\t * @param {Object} name Element name(s) or indexes (<code>String</code>,\n\t\t * <code>Array</code>, <code>Number</code>)\n\t\t * @returns {Array}\n\t\t */\n\t\tvalues: function(name) {\n\t\t\treturn _.map(this.getAll(name), function(element) {\n\t\t\t\treturn element.value();\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Remove child element\n\t\t * @param {String} name Property name or its index\n\t\t */\n\t\tremove: function(name) {\n\t\t\tvar element = this.get(name);\n\t\t\tif (element) {\n\t\t\t\tthis._updateSource('', element.fullRange());\n\t\t\t\tthis._children = _.without(this._children, element);\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns list of all editable child elements\n\t\t * @returns {Array}\n\t\t */\n\t\tlist: function() {\n\t\t\treturn this._children;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns index of editble child in list\n\t\t * @param {Object} item\n\t\t * @returns {Number}\n\t\t */\n\t\tindexOf: function(item) {\n\t\t\treturn _.indexOf(this.list(), this.get(item));\n\t\t},\n\t\t\n\t\t/**\n\t\t * Sets or gets container name\n\t\t * @param {String} val New name. If not passed, current \n\t\t * name is returned\n\t\t * @return {String}\n\t\t */\n\t\tname: function(val) {\n\t\t\tif (!_.isUndefined(val) && this._name !== (val = String(val))) {\n\t\t\t\tthis._updateSource(val, this._positions.name, this._positions.name + this._name.length);\n\t\t\t\tthis._name = val;\n\t\t\t}\n\t\t\t\n\t\t\treturn this._name;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns name range object\n\t\t * @param {Boolean} isAbsolute Return absolute range (with respect of \n\t\t * rule offset)\n\t\t * @returns {Range}\n\t\t */\n\t\tnameRange: function(isAbsolute) {\n\t\t\treturn range(this._positions.name + (isAbsolute ? this.options.offset : 0), this.name());\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns range of current source\n\t\t * @param {Boolean} isAbsolute\n\t\t */\n\t\trange: function(isAbsolute) {\n\t\t\treturn range(isAbsolute ? this.options.offset : 0, this.toString());\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns element that belongs to specified position\n\t\t * @param {Number} pos\n\t\t * @param {Boolean} isAbsolute\n\t\t * @returns {EditElement}\n\t\t */\n\t\titemFromPosition: function(pos, isAbsolute) {\n\t\t\treturn _.find(this.list(), function(elem) {\n\t\t\t\treturn elem.range(isAbsolute).inside(pos);\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns source code of current container \n\t\t * @returns {String}\n\t\t */\n\t\ttoString: function() {\n\t\t\treturn this.source;\n\t\t}\n\t};\n\t\n\t/**\n\t * @param {EditContainer} parent\n\t * @param {Object} nameToken\n\t * @param {Object} valueToken\n\t */\n\tfunction EditElement(parent, nameToken, valueToken) {\n\t\t/** @type EditContainer */\n\t\tthis.parent = parent;\n\t\t\n\t\tthis._name = nameToken.value;\n\t\tthis._value = valueToken ? valueToken.value : '';\n\t\t\n\t\tthis._positions = {\n\t\t\tname: nameToken.start,\n\t\t\tvalue: valueToken ? valueToken.start : -1\n\t\t};\n\t\t\n\t\tthis.initialize.apply(this, arguments);\n\t}\n\t\n\t/**\n\t * The self-propagating extend function for classes.\n\t * @type Function\n\t */\n\tEditElement.extend = core.extend;\n\t\n\tEditElement.prototype = {\n\t\t/**\n\t\t * Child class constructor\n\t\t */\n\t\tinitialize: function() {},\n\t\t\n\t\t/**\n\t\t * Make position absolute\n\t\t * @private\n\t\t * @param {Number} num\n\t\t * @param {Boolean} isAbsolute\n\t\t * @returns {Boolean}\n\t\t */\n\t\t_pos: function(num, isAbsolute) {\n\t\t\treturn num + (isAbsolute ? this.parent.options.offset : 0);\n\t\t},\n\t\t\t\n\t\t/**\n\t\t * Sets of gets element value\n\t\t * @param {String} val New element value. If not passed, current \n\t\t * value is returned\n\t\t * @returns {String}\n\t\t */\n\t\tvalue: function(val) {\n\t\t\tif (!_.isUndefined(val) && this._value !== (val = String(val))) {\n\t\t\t\tthis.parent._updateSource(val, this.valueRange());\n\t\t\t\tthis._value = val;\n\t\t\t}\n\t\t\t\n\t\t\treturn this._value;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Sets of gets element name\n\t\t * @param {String} val New element name. If not passed, current \n\t\t * name is returned\n\t\t * @returns {String}\n\t\t */\n\t\tname: function(val) {\n\t\t\tif (!_.isUndefined(val) && this._name !== (val = String(val))) {\n\t\t\t\tthis.parent._updateSource(val, this.nameRange());\n\t\t\t\tthis._name = val;\n\t\t\t}\n\t\t\t\n\t\t\treturn this._name;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns position of element name token\n\t\t * @param {Boolean} isAbsolute Return absolute position\n\t\t * @returns {Number}\n\t\t */\n\t\tnamePosition: function(isAbsolute) {\n\t\t\treturn this._pos(this._positions.name, isAbsolute);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns position of element value token\n\t\t * @param {Boolean} isAbsolute Return absolute position\n\t\t * @returns {Number}\n\t\t */\n\t\tvaluePosition: function(isAbsolute) {\n\t\t\treturn this._pos(this._positions.value, isAbsolute);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns element name\n\t\t * @param {Boolean} isAbsolute Return absolute range \n\t\t * @returns {Range}\n\t\t */\n\t\trange: function(isAbsolute) {\n\t\t\treturn range(this.namePosition(isAbsolute), this.toString());\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns full element range, including possible indentation\n\t\t * @param {Boolean} isAbsolute Return absolute range\n\t\t * @returns {Range}\n\t\t */\n\t\tfullRange: function(isAbsolute) {\n\t\t\treturn this.range(isAbsolute);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns element name range\n\t\t * @param {Boolean} isAbsolute Return absolute range\n\t\t * @returns {Range}\n\t\t */\n\t\tnameRange: function(isAbsolute) {\n\t\t\treturn range(this.namePosition(isAbsolute), this.name());\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns element value range\n\t\t * @param {Boolean} isAbsolute Return absolute range\n\t\t * @returns {Range}\n\t\t */\n\t\tvalueRange: function(isAbsolute) {\n\t\t\treturn range(this.valuePosition(isAbsolute), this.value());\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns current element string representation\n\t\t * @returns {String}\n\t\t */\n\t\ttoString: function() {\n\t\t\treturn this.name() + this.value();\n\t\t},\n\t\t\n\t\tvalueOf: function() {\n\t\t\treturn this.toString();\n\t\t}\n\t};\n\t\n\treturn {\n\t\tEditContainer: EditContainer,\n\t\tEditElement: EditElement,\n\t\t\n\t\t/**\n\t\t * Creates token that can be fed to <code>EditElement</code>\n\t\t * @param {Number} start\n\t\t * @param {String} value\n\t\t * @param {String} type\n\t\t * @returns\n\t\t */\n\t\tcreateToken: function(start, value, type) {\n\t\t\tvar obj = {\n\t\t\t\tstart: start || 0,\n\t\t\t\tvalue: value || '',\n\t\t\t\ttype: type\n\t\t\t};\n\t\t\t\n\t\t\tobj.end = obj.start + obj.value.length;\n\t\t\treturn obj;\n\t\t}\n\t};\n});/**\n * CSS EditTree is a module that can parse a CSS rule into a tree with \n * convenient methods for adding, modifying and removing CSS properties. These \n * changes can be written back to string with respect of code formatting.\n * \n * @memberOf __cssEditTreeDefine\n * @constructor\n * @param {Function} require\n * @param {Underscore} _ \n */\nemmet.define('cssEditTree', function(require, _) {\n\tvar defaultOptions = {\n\t\tstyleBefore: '\\n\\t',\n\t\tstyleSeparator: ': ',\n\t\toffset: 0\n\t};\n\t\n\tvar WHITESPACE_REMOVE_FROM_START = 1;\n\tvar WHITESPACE_REMOVE_FROM_END   = 2;\n\t\n\t/**\n\t * Returns range object\n\t * @param {Number} start\n\t * @param {Number} len \n\t * @returns {Range}\n\t */\n\tfunction range(start, len) {\n\t\treturn require('range').create(start, len);\n\t}\n\t\n\t/**\n\t * Removes whitespace tokens from the array ends\n\t * @param {Array} tokens\n\t * @param {Number} mask Mask indicating from which end whitespace should be \n\t * removed \n\t * @returns {Array}\n\t */\n\tfunction trimWhitespaceTokens(tokens, mask) {\n\t\tmask = mask || (WHITESPACE_REMOVE_FROM_START | WHITESPACE_REMOVE_FROM_END);\n\t\tvar whitespace = ['white', 'line'];\n\t\t\n\t\tif ((mask & WHITESPACE_REMOVE_FROM_END) == WHITESPACE_REMOVE_FROM_END)\n\t\t\twhile (tokens.length && _.include(whitespace, _.last(tokens).type)) {\n\t\t\t\ttokens.pop();\n\t \t\t}\n\t\t\n\t\tif ((mask & WHITESPACE_REMOVE_FROM_START) == WHITESPACE_REMOVE_FROM_START)\n\t\t\twhile (tokens.length && _.include(whitespace, tokens[0].type)) {\n\t\t\t\ttokens.shift();\n\t\t\t}\n\t\t\n\t\treturn tokens;\n\t}\n\t\n\t/**\n\t * Helper function that searches for selector range for <code>CSSEditRule</code>\n\t * @param {TokenIterator} it\n\t * @returns {Range}\n\t */\n\tfunction findSelectorRange(it) {\n\t\tvar tokens = [], token;\n \t\tvar start = it.position(), end;\n \t\t\n \t\twhile (token = it.next()) {\n\t\t\tif (token.type == '{')\n\t\t\t\tbreak;\n\t\t\ttokens.push(token);\n\t\t}\n \t\t\n \t\ttrimWhitespaceTokens(tokens);\n \t\t\n \t\tif (tokens.length) {\n \t\t\tstart = tokens[0].start;\n \t\t\tend = _.last(tokens).end;\n \t\t} else {\n \t\t\tend = start;\n \t\t}\n \t\t\n \t\treturn range(start, end - start);\n\t}\n\t\n\t/**\n\t * Helper function that searches for CSS property value range next to\n\t * iterator's current position  \n\t * @param {TokenIterator} it\n\t * @returns {Range}\n\t */\n\tfunction findValueRange(it) {\n\t\t// find value start position\n\t\tvar skipTokens = ['white', 'line', ':'];\n\t\tvar tokens = [], token, start, end;\n\t\t\n\t\tit.nextUntil(function(tok) {\n\t\t\treturn !_.include(skipTokens, this.itemNext().type);\n\t\t});\n\t\t\n\t\tstart = it.current().end;\n\t\t// consume value\n\t\twhile (token = it.next()) {\n\t\t\tif (token.type == '}' || token.type == ';') {\n\t\t\t\t// found value end\n\t\t\t\ttrimWhitespaceTokens(tokens, WHITESPACE_REMOVE_FROM_START \n\t\t\t\t\t\t| (token.type == '}' ? WHITESPACE_REMOVE_FROM_END : 0));\n\t\t\t\t\n\t\t\t\tif (tokens.length) {\n\t\t\t\t\tstart = tokens[0].start;\n\t\t\t\t\tend = _.last(tokens).end;\n\t\t\t\t} else {\n\t\t\t\t\tend = start;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn range(start, end - start);\n\t\t\t}\n\t\t\t\n\t\t\ttokens.push(token);\n\t\t}\n\t\t\n\t\t// reached the end of tokens list\n\t\tif (tokens.length) {\n\t\t\treturn range(tokens[0].start, _.last(tokens).end - tokens[0].start);\n\t\t}\n\t}\n\t\n\t/**\n\t * Finds parts of complex CSS value\n\t * @param {String} str\n\t * @returns {Array} Returns list of <code>Range</code>'s\n\t */\n\tfunction findParts(str) {\n\t\t/** @type StringStream */\n\t\tvar stream = require('stringStream').create(str);\n\t\tvar ch;\n\t\tvar result = [];\n\t\tvar sep = /[\\s\\u00a0,]/;\n\t\t\n\t\tvar add = function() {\n\t\t\tstream.next();\n\t\t\tresult.push(range(stream.start, stream.current()));\n\t\t\tstream.start = stream.pos;\n\t\t};\n\t\t\n\t\t// skip whitespace\n\t\tstream.eatSpace();\n\t\tstream.start = stream.pos;\n\t\t\n\t\twhile (ch = stream.next()) {\n\t\t\tif (ch == '\"' || ch == \"'\") {\n\t\t\t\tstream.next();\n\t\t\t\tif (!stream.skipTo(ch)) break;\n\t\t\t\tadd();\n\t\t\t} else if (ch == '(') {\n\t\t\t\t// function found, may have nested function\n\t\t\t\tstream.backUp(1);\n\t\t\t\tif (!stream.skipToPair('(', ')')) break;\n\t\t\t\tstream.backUp(1);\n\t\t\t\tadd();\n\t\t\t} else {\n\t\t\t\tif (sep.test(ch)) {\n\t\t\t\t\tresult.push(range(stream.start, stream.current().length - 1));\n\t\t\t\t\tstream.eatWhile(sep);\n\t\t\t\t\tstream.start = stream.pos;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tadd();\n\t\t\n\t\treturn _.chain(result)\n\t\t\t.filter(function(item) {\n\t\t\t\treturn !!item.length();\n\t\t\t})\n\t\t\t.uniq(false, function(item) {\n\t\t\t\treturn item.toString();\n\t\t\t})\n\t\t\t.value();\n\t}\n\t\n\t/**\n\t * A bit hacky way to identify invalid CSS property definition: when user\n\t * starts writing new abbreviation in CSS rule, he actually creates invalid\n\t * CSS property definition and this method tries to identify such abbreviation\n\t * and prevent it from being added to CSS edit tree \n\t * @param {TokenIterator} it\n\t */\n\tfunction isValidIdentifier(it) {\n//\t\treturn true;\n\t\tvar tokens = it.tokens;\n\t\tfor (var i = it._i + 1, il = tokens.length; i < il; i++) {\n\t\t\tif (tokens[i].type == ':')\n\t\t\t\treturn true;\n\t\t\t\n\t\t\tif (tokens[i].type == 'identifier' || tokens[i].type == 'line')\n\t\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * @class\n\t * @extends EditContainer\n\t */\n\tvar CSSEditContainer = require('editTree').EditContainer.extend({\n\t\tinitialize: function(source, options) {\n\t\t\t_.defaults(this.options, defaultOptions);\n\t\t\tvar editTree = require('editTree');\n\t\t\t\n\t\t\t/** @type TokenIterator */\n\t \t\tvar it = require('tokenIterator').create(\n\t \t\t\t\trequire('cssParser').parse(source));\n\t \t\t\n\t \t\tvar selectorRange = findSelectorRange(it);\n\t \t\tthis._positions.name = selectorRange.start;\n\t \t\tthis._name = selectorRange.substring(source);\n\t \t\t\n\t \t\tif (!it.current() || it.current().type != '{')\n\t \t\t\tthrow 'Invalid CSS rule';\n\t \t\t\n\t \t\tthis._positions.contentStart = it.position() + 1;\n\t \t\t\n\t \t\t// consume properties\n\t \t\tvar propertyRange, valueRange, token;\n\t\t\twhile (token = it.next()) {\n\t\t\t\tif (token.type == 'identifier' && isValidIdentifier(it)) {\n\t\t\t\t\tpropertyRange = range(token);\n\t\t\t\t\tvalueRange = findValueRange(it);\n\t\t\t\t\tvar end = (it.current() && it.current().type == ';') \n\t\t\t\t\t\t? range(it.current())\n\t\t\t\t\t\t: range(valueRange.end, 0);\n\t\t\t\t\tthis._children.push(new CSSEditElement(this,\n\t\t\t\t\t\t\teditTree.createToken(propertyRange.start, propertyRange.substring(source)),\n\t\t\t\t\t\t\teditTree.createToken(valueRange.start, valueRange.substring(source)),\n\t\t\t\t\t\t\teditTree.createToken(end.start, end.substring(source))\n\t\t\t\t\t\t\t));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tthis._saveStyle();\n\t\t},\n\t\t\n\t\t/**\n\t\t * Remembers all styles of properties\n\t\t * @private\n\t\t */\n\t\t_saveStyle: function() {\n\t\t\tvar start = this._positions.contentStart;\n\t\t\tvar source = this.source;\n\t\t\tvar utils = require('utils');\n\t\t\t\n\t\t\t_.each(this.list(), /** @param {CSSEditProperty} p */ function(p) {\n\t\t\t\tp.styleBefore = source.substring(start, p.namePosition());\n\t\t\t\t// a small hack here:\n\t\t\t\t// Sometimes users add empty lines before properties to logically\n\t\t\t\t// separate groups of properties. In this case, a blind copy of\n\t\t\t\t// characters between rules may lead to undesired behavior,\n\t\t\t\t// especially when current rule is duplicated or used as a donor\n\t\t\t\t// to create new rule.\n\t\t\t\t// To solve this issue, we‘ll take only last newline indentation\n\t\t\t\tvar lines = utils.splitByLines(p.styleBefore);\n\t\t\t\tif (lines.length > 1) {\n\t\t\t\t\tp.styleBefore = '\\n' + _.last(lines);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tp.styleSeparator = source.substring(p.nameRange().end, p.valuePosition());\n\t\t\t\t\n\t\t\t\t// graceful and naive comments removal \n\t\t\t\tp.styleBefore = _.last(p.styleBefore.split('*/'));\n\t\t\t\tp.styleSeparator = p.styleSeparator.replace(/\\/\\*.*?\\*\\//g, '');\n\t\t\t\t\n\t\t\t\tstart = p.range().end;\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Adds new CSS property \n\t\t * @param {String} name Property name\n\t\t * @param {String} value Property value\n\t\t * @param {Number} pos Position at which to insert new property. By \n\t\t * default the property is inserted at the end of rule \n\t\t * @returns {CSSEditProperty}\n\t\t */\n\t\tadd: function(name, value, pos) {\n\t\t\tvar list = this.list();\n\t\t\tvar start = this._positions.contentStart;\n\t\t\tvar styles = _.pick(this.options, 'styleBefore', 'styleSeparator');\n\t\t\tvar editTree = require('editTree');\n\t\t\t\n\t\t\tif (_.isUndefined(pos))\n\t\t\t\tpos = list.length;\n\t\t\t\n\t\t\t/** @type CSSEditProperty */\n\t\t\tvar donor = list[pos];\n\t\t\tif (donor) {\n\t\t\t\tstart = donor.fullRange().start;\n\t\t\t} else if (donor = list[pos - 1]) {\n\t\t\t\t// make sure that donor has terminating semicolon\n\t\t\t\tdonor.end(';');\n\t\t\t\tstart = donor.range().end;\n\t\t\t}\n\t\t\t\n\t\t\tif (donor) {\n\t\t\t\tstyles = _.pick(donor, 'styleBefore', 'styleSeparator');\n\t\t\t}\n\t\t\t\n\t\t\tvar nameToken = editTree.createToken(start + styles.styleBefore.length, name);\n\t\t\tvar valueToken = editTree.createToken(nameToken.end + styles.styleSeparator.length, value);\n\t\t\t\n\t\t\tvar property = new CSSEditElement(this, nameToken, valueToken,\n\t\t\t\t\teditTree.createToken(valueToken.end, ';'));\n\t\t\t\n\t\t\t_.extend(property, styles);\n\t\t\t\n\t\t\t// write new property into the source\n\t\t\tthis._updateSource(property.styleBefore + property.toString(), start);\n\t\t\t\n\t\t\t// insert new property\n\t\t\tthis._children.splice(pos, 0, property);\n\t\t\treturn property;\n\t\t}\n\t});\n\t\n\t/**\n\t * @class\n\t * @type CSSEditElement\n\t * @constructor\n\t */\n\tvar CSSEditElement = require('editTree').EditElement.extend({\n\t\tinitialize: function(rule, name, value, end) {\n\t\t\tthis.styleBefore = rule.options.styleBefore;\n\t\t\tthis.styleSeparator = rule.options.styleSeparator;\n\t\t\t\n\t\t\tthis._end = end.value;\n\t\t\tthis._positions.end = end.start;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns ranges of complex value parts\n\t\t * @returns {Array} Returns <code>null</code> if value is not complex\n\t\t */\n\t\tvalueParts: function(isAbsolute) {\n\t\t\tvar parts = findParts(this.value());\n\t\t\tif (isAbsolute) {\n\t\t\t\tvar offset = this.valuePosition(true);\n\t\t\t\t_.each(parts, function(p) {\n\t\t\t\t\tp.shift(offset);\n\t\t\t\t});\n\t\t\t}\n\t\t\t\n\t\t\treturn parts;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Sets of gets property end value (basically, it's a semicolon)\n\t\t * @param {String} val New end value. If not passed, current \n\t\t * value is returned\n\t\t */\n\t\tend: function(val) {\n\t\t\tif (!_.isUndefined(val) && this._end !== val) {\n\t\t\t\tthis.parent._updateSource(val, this._positions.end, this._positions.end + this._end.length);\n\t\t\t\tthis._end = val;\n\t\t\t}\n\t\t\t\n\t\t\treturn this._end;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns full rule range, with indentation\n\t\t * @param {Boolean} isAbsolute Return absolute range (with respect of\n\t\t * rule offset)\n\t\t * @returns {Range}\n\t\t */\n\t\tfullRange: function(isAbsolute) {\n\t\t\tvar r = this.range(isAbsolute);\n\t\t\tr.start -= this.styleBefore.length;\n\t\t\treturn r;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns item string representation\n\t\t * @returns {String}\n\t\t */\n\t\ttoString: function() {\n\t\t\treturn this.name() + this.styleSeparator + this.value() + this.end();\n\t\t}\n\t});\n\t\n\treturn {\n\t\t/**\n\t\t * Parses CSS rule into editable tree\n\t\t * @param {String} source\n\t\t * @param {Object} options\n\t\t * @memberOf emmet.cssEditTree\n\t\t * @returns {EditContainer}\n\t\t */\n\t\tparse: function(source, options) {\n\t\t\treturn new CSSEditContainer(source, options);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Extract and parse CSS rule from specified position in <code>content</code> \n\t\t * @param {String} content CSS source code\n\t\t * @param {Number} pos Character position where to start source code extraction\n\t\t * @returns {EditContainer}\n\t\t */\n\t\tparseFromPosition: function(content, pos, isBackward) {\n\t\t\tvar bounds = this.extractRule(content, pos, isBackward);\n\t\t\tif (!bounds || !bounds.inside(pos))\n\t\t\t\t// no matching CSS rule or caret outside rule bounds\n\t\t\t\treturn null;\n\t\t\t\n\t\t\treturn this.parse(bounds.substring(content), {\n\t\t\t\toffset: bounds.start\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Extracts single CSS selector definition from source code\n\t\t * @param {String} content CSS source code\n\t\t * @param {Number} pos Character position where to start source code extraction\n\t\t * @returns {Range}\n\t\t */\n\t\textractRule: function(content, pos, isBackward) {\n\t\t\tvar result = '';\n\t\t\tvar len = content.length;\n\t\t\tvar offset = pos;\n\t\t\tvar stopChars = '{}/\\\\<>\\n\\r';\n\t\t\tvar bracePos = -1, ch;\n\t\t\t\n\t\t\t// search left until we find rule edge\n\t\t\twhile (offset >= 0) {\n\t\t\t\tch = content.charAt(offset);\n\t\t\t\tif (ch == '{') {\n\t\t\t\t\tbracePos = offset;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (ch == '}' && !isBackward) {\n\t\t\t\t\toffset++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\toffset--;\n\t\t\t}\n\t\t\t\n\t\t\t// search right for full rule set\n\t\t\twhile (offset < len) {\n\t\t\t\tch = content.charAt(offset);\n\t\t\t\tif (ch == '{') {\n\t\t\t\t\tbracePos = offset;\n\t\t\t\t} else if (ch == '}') {\n\t\t\t\t\tif (bracePos != -1)\n\t\t\t\t\t\tresult = content.substring(bracePos, offset + 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\toffset++;\n\t\t\t}\n\t\t\t\n\t\t\tif (result) {\n\t\t\t\t// find CSS selector\n\t\t\t\toffset = bracePos - 1;\n\t\t\t\tvar selector = '';\n\t\t\t\twhile (offset >= 0) {\n\t\t\t\t\tch = content.charAt(offset);\n\t\t\t\t\tif (stopChars.indexOf(ch) != -1) break;\n\t\t\t\t\toffset--;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// also trim whitespace\n\t\t\t\tselector = content.substring(offset + 1, bracePos).replace(/^[\\s\\n\\r]+/m, '');\n\t\t\t\treturn require('range').create(bracePos - selector.length, result.length + selector.length);\n\t\t\t}\n\t\t\t\n\t\t\treturn null;\n\t\t},\n\t\t\n\t\t/**\n\t \t * Removes vendor prefix from CSS property\n\t \t * @param {String} name CSS property\n\t \t * @return {String}\n\t \t */\n\t \tbaseName: function(name) {\n\t \t\treturn name.replace(/^\\s*\\-\\w+\\-/, '');\n\t \t},\n\t \t\n\t \t/**\n\t \t * Finds parts of complex CSS value\n\t \t * @param {String} str\n\t \t * @returns {Array}\n\t \t */\n\t \tfindParts: findParts\n\t};\n});/**\n * XML EditTree is a module that can parse an XML/HTML element into a tree with \n * convenient methods for adding, modifying and removing attributes. These \n * changes can be written back to string with respect of code formatting.\n * \n * @memberOf __xmlEditTreeDefine\n * @constructor\n * @param {Function} require\n * @param {Underscore} _ \n */\nemmet.define('xmlEditTree', function(require, _) {\n\tvar defaultOptions = {\n\t\tstyleBefore: ' ',\n\t\tstyleSeparator: '=',\n\t\tstyleQuote: '\"',\n\t\toffset: 0\n\t};\n\t\n\tvar startTag = /^<([\\w\\:\\-]+)((?:\\s+[\\w\\-:]+(?:\\s*=\\s*(?:(?:\"[^\"]*\")|(?:'[^']*')|[^>\\s]+))?)*)\\s*(\\/?)>/m;\n\t\n\tvar XMLEditContainer = require('editTree').EditContainer.extend({\n\t\tinitialize: function(source, options) {\n\t\t\t_.defaults(this.options, defaultOptions);\n\t\t\tthis._positions.name = 1;\n\t\t\t\n\t\t\tvar attrToken = null;\n\t\t\tvar tokens = require('xmlParser').parse(source);\n\t\t\tvar range = require('range');\n\t\t\t\n\t\t\t_.each(tokens, function(token) {\n\t\t\t\ttoken.value = range.create(token).substring(source);\n\t\t\t\tswitch (token.type) {\n\t\t\t\t\tcase 'tag':\n\t\t\t\t\t\tif (/^<[^\\/]+/.test(token.value)) {\n\t\t\t\t\t\t\tthis._name = token.value.substring(1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\n\t\t\t\t\tcase 'attribute':\n\t\t\t\t\t\t// add empty attribute\n\t\t\t\t\t\tif (attrToken) {\n\t\t\t\t\t\t\tthis._children.push(new XMLEditElement(this, attrToken));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tattrToken = token;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\n\t\t\t\t\tcase 'string':\n\t\t\t\t\t\tthis._children.push(new XMLEditElement(this, attrToken, token));\n\t\t\t\t\t\tattrToken = null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}, this);\n\t\t\t\n\t\t\tif (attrToken) {\n\t\t\t\tthis._children.push(new XMLEditElement(this, attrToken));\n\t\t\t}\n\t\t\t\n\t\t\tthis._saveStyle();\n\t\t},\n\t\t\n\t\t/**\n\t\t * Remembers all styles of properties\n\t\t * @private\n\t\t */\n\t\t_saveStyle: function() {\n\t\t\tvar start = this.nameRange().end;\n\t\t\tvar source = this.source;\n\t\t\t\n\t\t\t_.each(this.list(), /** @param {EditElement} p */ function(p) {\n\t\t\t\tp.styleBefore = source.substring(start, p.namePosition());\n\t\t\t\t\n\t\t\t\tif (p.valuePosition() !== -1) {\n\t\t\t\t\tp.styleSeparator = source.substring(p.namePosition() + p.name().length, p.valuePosition() - p.styleQuote.length);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tstart = p.range().end;\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Adds new attribute \n\t\t * @param {String} name Property name\n\t\t * @param {String} value Property value\n\t\t * @param {Number} pos Position at which to insert new property. By \n\t\t * default the property is inserted at the end of rule \n\t\t */\n\t\tadd: function(name, value, pos) {\n\t\t\tvar list = this.list();\n\t\t\tvar start = this.nameRange().end;\n\t\t\tvar editTree = require('editTree');\n\t\t\tvar styles = _.pick(this.options, 'styleBefore', 'styleSeparator', 'styleQuote');\n\t\t\t\n\t\t\tif (_.isUndefined(pos))\n\t\t\t\tpos = list.length;\n\t\t\t\n\t\t\t\n\t\t\t/** @type XMLEditAttribute */\n\t\t\tvar donor = list[pos];\n\t\t\tif (donor) {\n\t\t\t\tstart = donor.fullRange().start;\n\t\t\t} else if (donor = list[pos - 1]) {\n\t\t\t\tstart = donor.range().end;\n\t\t\t}\n\t\t\t\n\t\t\tif (donor) {\n\t\t\t\tstyles = _.pick(donor, 'styleBefore', 'styleSeparator', 'styleQuote');\n\t\t\t}\n\t\t\t\n\t\t\tvalue = styles.styleQuote + value + styles.styleQuote;\n\t\t\t\n\t\t\tvar attribute = new XMLEditElement(this, \n\t\t\t\t\teditTree.createToken(start + styles.styleBefore.length, name),\n\t\t\t\t\teditTree.createToken(start + styles.styleBefore.length + name.length \n\t\t\t\t\t\t\t+ styles.styleSeparator.length, value)\n\t\t\t\t\t);\n\t\t\t\n\t\t\t_.extend(attribute, styles);\n\t\t\t\n\t\t\t// write new attribute into the source\n\t\t\tthis._updateSource(attribute.styleBefore + attribute.toString(), start);\n\t\t\t\n\t\t\t// insert new attribute\n\t\t\tthis._children.splice(pos, 0, attribute);\n\t\t\treturn attribute;\n\t\t}\n\t});\n\t\n\tvar XMLEditElement = require('editTree').EditElement.extend({\n\t\tinitialize: function(parent, nameToken, valueToken) {\n\t\t\tthis.styleBefore = parent.options.styleBefore;\n\t\t\tthis.styleSeparator = parent.options.styleSeparator;\n\t\t\t\n\t\t\tvar value = '', quote = parent.options.styleQuote;\n\t\t\tif (valueToken) {\n\t\t\t\tvalue = valueToken.value;\n\t\t\t\tquote = value.charAt(0);\n\t\t\t\tif (quote == '\"' || quote == \"'\") {\n\t\t\t\t\tvalue = value.substring(1);\n\t\t\t\t} else {\n\t\t\t\t\tquote = '';\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (quote && value.charAt(value.length - 1) == quote) {\n\t\t\t\t\tvalue = value.substring(0, value.length - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tthis.styleQuote = quote;\n\t\t\t\n\t\t\tthis._value = value;\n\t\t\tthis._positions.value = valueToken ? valueToken.start + quote.length : -1;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns full rule range, with indentation\n\t\t * @param {Boolean} isAbsolute Return absolute range (with respect of\n\t\t * rule offset)\n\t\t * @returns {Range}\n\t\t */\n\t\tfullRange: function(isAbsolute) {\n\t\t\tvar r = this.range(isAbsolute);\n\t\t\tr.start -= this.styleBefore.length;\n\t\t\treturn r;\n\t\t},\n\t\t\n\t\ttoString: function() {\n\t\t\treturn this.name() + this.styleSeparator\n\t\t\t\t+ this.styleQuote + this.value() + this.styleQuote;\n\t\t}\n\t});\n\t\n\treturn {\n\t\t/**\n\t\t * Parses HTML element into editable tree\n\t\t * @param {String} source\n\t\t * @param {Object} options\n\t\t * @memberOf emmet.htmlEditTree\n\t\t * @returns {EditContainer}\n\t\t */\n\t\tparse: function(source, options) {\n\t\t\treturn new XMLEditContainer(source, options);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Extract and parse HTML from specified position in <code>content</code> \n\t\t * @param {String} content CSS source code\n\t\t * @param {Number} pos Character position where to start source code extraction\n\t\t * @returns {XMLEditElement}\n\t\t */\n\t\tparseFromPosition: function(content, pos, isBackward) {\n\t\t\tvar bounds = this.extractTag(content, pos, isBackward);\n\t\t\tif (!bounds || !bounds.inside(pos))\n\t\t\t\t// no matching HTML tag or caret outside tag bounds\n\t\t\t\treturn null;\n\t\t\t\n\t\t\treturn this.parse(bounds.substring(content), {\n\t\t\t\toffset: bounds.start\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Extracts nearest HTML tag range from <code>content</code>, starting at \n\t\t * <code>pos</code> position\n\t\t * @param {String} content\n\t\t * @param {Number} pos\n\t\t * @param {Boolean} isBackward\n\t\t * @returns {Range}\n\t\t */\n\t\textractTag: function(content, pos, isBackward) {\n\t\t\tvar len = content.length, i;\n\t\t\tvar range = require('range');\n\t\t\t\n\t\t\t// max extraction length. I don't think there may be tags larger \n\t\t\t// than 2000 characters length\n\t\t\tvar maxLen = Math.min(2000, len);\n\t\t\t\n\t\t\t/** @type Range */\n\t\t\tvar r = null;\n\t\t\t\n\t\t\tvar match = function(pos) {\n\t\t\t\tvar m;\n\t\t\t\tif (content.charAt(pos) == '<' && (m = content.substr(pos, maxLen).match(startTag)))\n\t\t\t\t\treturn range.create(pos, m[0]);\n\t\t\t};\n\t\t\t\n\t\t\t// lookup backward, in case we are inside tag already\n\t\t\tfor (i = pos; i >= 0; i--) {\n\t\t\t\tif (r = match(i)) break;\n\t\t\t}\n\t\t\t\n\t\t\tif (r && (r.inside(pos) || isBackward))\n\t\t\t\treturn r;\n\t\t\t\n\t\t\tif (!r && isBackward)\n\t\t\t\treturn null;\n\t\t\t\n\t\t\t// search forward\n\t\t\tfor (i = pos; i < len; i++) {\n\t\t\t\tif (r = match(i))\n\t\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\t};\n});/**\n * 'Expand abbreviation' editor action: extracts abbreviation from current caret \n * position and replaces it with formatted output. \n * <br><br>\n * This behavior can be overridden with custom handlers which can perform \n * different actions when 'Expand Abbreviation' action is called.\n * For example, a CSS gradient handler that produces vendor-prefixed gradient\n * definitions registers its own expand abbreviation handler.  \n *  \n * @constructor\n * @memberOf __expandAbbreviationActionDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.define('expandAbbreviation', function(require, _) {\n\t/**\n\t * @type HandlerList List of registered handlers\n\t */\n\tvar handlers = require('handlerList').create();\n\t\n\t/** Back-reference to module */\n\tvar module = null;\n\t\n\tvar actions = require('actions');\n\t/**\n\t * 'Expand abbreviation' editor action \n\t * @param {IEmmetEditor} editor Editor instance\n\t * @param {String} syntax Syntax type (html, css, etc.)\n\t * @param {String} profile Output profile name (html, xml, xhtml)\n\t * @return {Boolean} Returns <code>true</code> if abbreviation was expanded \n\t * successfully\n\t */\n\tactions.add('expand_abbreviation', function(editor, syntax, profile) {\n\t\tvar args = _.toArray(arguments);\n\t\t\n\t\t// normalize incoming arguments\n\t\tvar info = require('editorUtils').outputInfo(editor, syntax, profile);\n\t\targs[1] = info.syntax;\n\t\targs[2] = info.profile;\n\t\t\n\t\treturn handlers.exec(false, args);\n\t});\n\t\n\t/**\n\t * A special version of <code>expandAbbreviation</code> function: if it can't\n\t * find abbreviation, it will place Tab character at caret position\n\t * @param {IEmmetEditor} editor Editor instance\n\t * @param {String} syntax Syntax type (html, css, etc.)\n\t * @param {String} profile Output profile name (html, xml, xhtml)\n\t */\n\tactions.add('expand_abbreviation_with_tab', function(editor, syntax, profile) {\n\t\tvar sel = editor.getSelection();\n\t\tvar indent = require('resources').getVariable('indentation');\n\t\tif (sel) {\n\t\t\t// indent selection\n\t\t\tvar utils = require('utils');\n\t\t\tvar selRange = require('range').create(editor.getSelectionRange());\n\t\t\tvar content = utils.padString(sel, indent);\n\t\t\t\n\t\t\teditor.replaceContent(indent + '${0}', editor.getCaretPos());\n\t\t\tvar replaceRange = require('range').create(editor.getCaretPos(), selRange.length());\n\t\t\teditor.replaceContent(content, replaceRange.start, replaceRange.end, true);\n\t\t\teditor.createSelection(replaceRange.start, replaceRange.start + content.length);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tif (!actions.run('expand_abbreviation', editor, syntax, profile)) {\n\t\t\teditor.replaceContent(indent, editor.getCaretPos());\n\t\t}\n\t\t\n\t\treturn true;\n\t}, {hidden: true});\n\t\n\t// XXX setup default handler\n\t/**\n\t * Extracts abbreviation from current caret \n\t * position and replaces it with formatted output \n\t * @param {IEmmetEditor} editor Editor instance\n\t * @param {String} syntax Syntax type (html, css, etc.)\n\t * @param {String} profile Output profile name (html, xml, xhtml)\n\t * @return {Boolean} Returns <code>true</code> if abbreviation was expanded \n\t * successfully\n\t */\n\thandlers.add(function(editor, syntax, profile) {\n\t\tvar caretPos = editor.getSelectionRange().end;\n\t\tvar abbr = module.findAbbreviation(editor);\n\t\t\t\n\t\tif (abbr) {\n\t\t\tvar content = emmet.expandAbbreviation(abbr, syntax, profile, \n\t\t\t\t\trequire('actionUtils').captureContext(editor));\n\t\t\tif (content) {\n\t\t\t\teditor.replaceContent(content, caretPos - abbr.length, caretPos);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}, {order: -1});\n\t\n\treturn module = {\n\t\t/**\n\t\t * Adds custom expand abbreviation handler. The passed function should \n\t\t * return <code>true</code> if it was performed successfully, \n\t\t * <code>false</code> otherwise.\n\t\t * \n\t\t * Added handlers will be called when 'Expand Abbreviation' is called\n\t\t * in order they were added\n\t\t * @memberOf expandAbbreviation\n\t\t * @param {Function} fn\n\t\t * @param {Object} options\n\t\t */\n\t\taddHandler: function(fn, options) {\n\t\t\thandlers.add(fn, options);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Removes registered handler\n\t\t * @returns\n\t\t */\n\t\tremoveHandler: function(fn) {\n\t\t\thandlers.remove(fn, options);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Search for abbreviation in editor from current caret position\n\t\t * @param {IEmmetEditor} editor Editor instance\n\t\t * @return {String}\n\t\t */\n\t\tfindAbbreviation: function(editor) {\n\t\t\t/** @type Range */\n\t\t\tvar range = require('range').create(editor.getSelectionRange());\n\t\t\tvar content = String(editor.getContent());\n\t\t\tif (range.length()) {\n\t\t\t\t// abbreviation is selected by user\n\t\t\t\treturn range.substring(content);\n\t\t\t}\n\t\t\t\n\t\t\t// search for new abbreviation from current caret position\n\t\t\tvar curLine = editor.getCurrentLineRange();\n\t\t\treturn require('actionUtils').extractAbbreviation(content.substring(curLine.start, range.start));\n\t\t}\n\t};\n});/**\n * Action that wraps content with abbreviation. For convenience, action is \n * defined as reusable module\n * @constructor\n * @memberOf __wrapWithAbbreviationDefine\n */\nemmet.define('wrapWithAbbreviation', function(require, _) {\n\t/** Back-references to current module */\n\tvar module = null;\n\t\n\t/**\n\t * Wraps content with abbreviation\n\t * @param {IEmmetEditor} Editor instance\n\t * @param {String} abbr Abbreviation to wrap with\n\t * @param {String} syntax Syntax type (html, css, etc.)\n\t * @param {String} profile Output profile name (html, xml, xhtml)\n\t */\n\trequire('actions').add('wrap_with_abbreviation', function (editor, abbr, syntax, profile) {\n\t\tvar info = require('editorUtils').outputInfo(editor, syntax, profile);\n\t\tvar utils = require('utils');\n\t\t/** @type emmet.editorUtils */\n\t\tvar editorUtils = require('editorUtils');\n\t\tabbr = abbr || editor.prompt(\"Enter abbreviation\");\n\t\t\n\t\tif (!abbr) \n\t\t\treturn null;\n\t\t\n\t\tabbr = String(abbr);\n\t\t\n\t\tvar range = require('range').create(editor.getSelectionRange());\n\t\t\n\t\tif (!range.length()) {\n\t\t\t// no selection, find tag pair\n\t\t\tvar match = require('htmlMatcher').tag(info.content, range.start);\n\t\t\tif (!match) {  // nothing to wrap\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\trange = utils.narrowToNonSpace(info.content, match.range);\n\t\t}\n\t\t\n\t\tvar newContent = utils.escapeText(range.substring(info.content));\n\t\tvar result = module\n\t\t\t.wrap(abbr, editorUtils.unindent(editor, newContent), info.syntax, \n\t\t\t\t\tinfo.profile, require('actionUtils').captureContext(editor));\n\t\t\n\t\tif (result) {\n\t\t\teditor.replaceContent(result, range.start, range.end);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t});\n\t\n\treturn module = {\n\t\t/**\n\t\t * Wraps passed text with abbreviation. Text will be placed inside last\n\t\t * expanded element\n\t\t * @memberOf wrapWithAbbreviation\n\t\t * @param {String} abbr Abbreviation\n\t\t * @param {String} text Text to wrap\n\t\t * @param {String} syntax Document type (html, xml, etc.). Default is 'html'\n\t\t * @param {String} profile Output profile's name. Default is 'plain'\n\t\t * @param {Object} contextNode Context node inside which abbreviation\n\t\t * is wrapped. It will be used as a reference for node name resolvers\n\t\t * @return {String}\n\t\t */\n\t\twrap: function(abbr, text, syntax, profile, contextNode) {\n\t\t\t/** @type emmet.filters */\n\t\t\tvar filters = require('filters');\n\t\t\t/** @type emmet.utils */\n\t\t\tvar utils = require('utils');\n\t\t\t\n\t\t\tsyntax = syntax || emmet.defaultSyntax();\n\t\t\tprofile = require('profile').get(profile, syntax);\n\t\t\t\n\t\t\trequire('tabStops').resetTabstopIndex();\n\t\t\t\n\t\t\tvar data = filters.extractFromAbbreviation(abbr);\n\t\t\tvar parsedTree = require('abbreviationParser').parse(data[0], {\n\t\t\t\tsyntax: syntax,\n\t\t\t\tpastedContent: text,\n\t\t\t\tcontextNode: contextNode\n\t\t\t});\n\t\t\tif (parsedTree) {\n\t\t\t\tvar filtersList = filters.composeList(syntax, profile, data[1]);\n\t\t\t\tfilters.apply(parsedTree, filtersList, profile);\n\t\t\t\treturn utils.replaceVariables(parsedTree.toString());\n\t\t\t}\n\t\t\t\n\t\t\treturn null;\n\t\t}\n\t};\n});/**\n * Toggles HTML and CSS comments depending on current caret context. Unlike\n * the same action in most editors, this action toggles comment on currently\n * matched item—HTML tag or CSS selector—when nothing is selected.\n * \n * @param {Function} require\n * @param {Underscore} _\n * @memberOf __toggleCommentAction\n * @constructor\n */\nemmet.exec(function(require, _) {\n\t/**\n\t * Toggle HTML comment on current selection or tag\n\t * @param {IEmmetEditor} editor\n\t * @return {Boolean} Returns <code>true</code> if comment was toggled\n\t */\n\tfunction toggleHTMLComment(editor) {\n\t\t/** @type Range */\n\t\tvar range = require('range').create(editor.getSelectionRange());\n\t\tvar info = require('editorUtils').outputInfo(editor);\n\t\t\t\n\t\tif (!range.length()) {\n\t\t\t// no selection, find matching tag\n\t\t\tvar tag = require('htmlMatcher').tag(info.content, editor.getCaretPos());\n\t\t\tif (tag) { // found pair\n\t\t\t\trange = tag.outerRange;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn genericCommentToggle(editor, '<!--', '-->', range);\n\t}\n\n\t/**\n\t * Simple CSS commenting\n\t * @param {IEmmetEditor} editor\n\t * @return {Boolean} Returns <code>true</code> if comment was toggled\n\t */\n\tfunction toggleCSSComment(editor) {\n\t\t/** @type Range */\n\t\tvar range = require('range').create(editor.getSelectionRange());\n\t\tvar info = require('editorUtils').outputInfo(editor);\n\t\t\t\n\t\tif (!range.length()) {\n\t\t\t// no selection, try to get current rule\n\t\t\t/** @type CSSRule */\n\t\t\tvar rule = require('cssEditTree').parseFromPosition(info.content, editor.getCaretPos());\n\t\t\tif (rule) {\n\t\t\t\tvar property = cssItemFromPosition(rule, editor.getCaretPos());\n\t\t\t\trange = property \n\t\t\t\t\t? property.range(true) \n\t\t\t\t\t: require('range').create(rule.nameRange(true).start, rule.source);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (!range.length()) {\n\t\t\t// still no selection, get current line\n\t\t\trange = require('range').create(editor.getCurrentLineRange());\n\t\t\trequire('utils').narrowToNonSpace(info.content, range);\n\t\t}\n\t\t\n\t\treturn genericCommentToggle(editor, '/*', '*/', range);\n\t}\n\t\n\t/**\n\t * Returns CSS property from <code>rule</code> that matches passed position\n\t * @param {EditContainer} rule\n\t * @param {Number} absPos\n\t * @returns {EditElement}\n\t */\n\tfunction cssItemFromPosition(rule, absPos) {\n\t\t// do not use default EditContainer.itemFromPosition() here, because\n\t\t// we need to make a few assumptions to make CSS commenting more reliable\n\t\tvar relPos = absPos - (rule.options.offset || 0);\n\t\tvar reSafeChar = /^[\\s\\n\\r]/;\n\t\treturn _.find(rule.list(), function(item) {\n\t\t\tif (item.range().end === relPos) {\n\t\t\t\t// at the end of property, but outside of it\n\t\t\t\t// if there’s a space character at current position,\n\t\t\t\t// use current property\n\t\t\t\treturn reSafeChar.test(rule.source.charAt(relPos));\n\t\t\t}\n\t\t\t\n\t\t\treturn item.range().inside(relPos);\n\t\t});\n\t}\n\n\t/**\n\t * Search for nearest comment in <code>str</code>, starting from index <code>from</code>\n\t * @param {String} text Where to search\n\t * @param {Number} from Search start index\n\t * @param {String} start_token Comment start string\n\t * @param {String} end_token Comment end string\n\t * @return {Range} Returns null if comment wasn't found\n\t */\n\tfunction searchComment(text, from, startToken, endToken) {\n\t\tvar commentStart = -1;\n\t\tvar commentEnd = -1;\n\t\t\n\t\tvar hasMatch = function(str, start) {\n\t\t\treturn text.substr(start, str.length) == str;\n\t\t};\n\t\t\t\n\t\t// search for comment start\n\t\twhile (from--) {\n\t\t\tif (hasMatch(startToken, from)) {\n\t\t\t\tcommentStart = from;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (commentStart != -1) {\n\t\t\t// search for comment end\n\t\t\tfrom = commentStart;\n\t\t\tvar contentLen = text.length;\n\t\t\twhile (contentLen >= from++) {\n\t\t\t\tif (hasMatch(endToken, from)) {\n\t\t\t\t\tcommentEnd = from + endToken.length;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn (commentStart != -1 && commentEnd != -1) \n\t\t\t? require('range').create(commentStart, commentEnd - commentStart) \n\t\t\t: null;\n\t}\n\n\t/**\n\t * Generic comment toggling routine\n\t * @param {IEmmetEditor} editor\n\t * @param {String} commentStart Comment start token\n\t * @param {String} commentEnd Comment end token\n\t * @param {Range} range Selection range\n\t * @return {Boolean}\n\t */\n\tfunction genericCommentToggle(editor, commentStart, commentEnd, range) {\n\t\tvar editorUtils = require('editorUtils');\n\t\tvar content = editorUtils.outputInfo(editor).content;\n\t\tvar caretPos = editor.getCaretPos();\n\t\tvar newContent = null;\n\t\t\n\t\tvar utils = require('utils');\n\t\t\t\n\t\t/**\n\t\t * Remove comment markers from string\n\t\t * @param {Sting} str\n\t\t * @return {String}\n\t\t */\n\t\tfunction removeComment(str) {\n\t\t\treturn str\n\t\t\t\t.replace(new RegExp('^' + utils.escapeForRegexp(commentStart) + '\\\\s*'), function(str){\n\t\t\t\t\tcaretPos -= str.length;\n\t\t\t\t\treturn '';\n\t\t\t\t}).replace(new RegExp('\\\\s*' + utils.escapeForRegexp(commentEnd) + '$'), '');\n\t\t}\n\t\t\n\t\t// first, we need to make sure that this substring is not inside \n\t\t// comment\n\t\tvar commentRange = searchComment(content, caretPos, commentStart, commentEnd);\n\t\tif (commentRange && commentRange.overlap(range)) {\n\t\t\t// we're inside comment, remove it\n\t\t\trange = commentRange;\n\t\t\tnewContent = removeComment(range.substring(content));\n\t\t} else {\n\t\t\t// should add comment\n\t\t\t// make sure that there's no comment inside selection\n\t\t\tnewContent = commentStart + ' ' +\n\t\t\t\trange.substring(content)\n\t\t\t\t\t.replace(new RegExp(utils.escapeForRegexp(commentStart) + '\\\\s*|\\\\s*' + utils.escapeForRegexp(commentEnd), 'g'), '') +\n\t\t\t\t' ' + commentEnd;\n\t\t\t\t\n\t\t\t// adjust caret position\n\t\t\tcaretPos += commentStart.length + 1;\n\t\t}\n\n\t\t// replace editor content\n\t\tif (newContent !== null) {\n\t\t\tnewContent = utils.escapeText(newContent);\n\t\t\teditor.setCaretPos(range.start);\n\t\t\teditor.replaceContent(editorUtils.unindent(editor, newContent), range.start, range.end);\n\t\t\teditor.setCaretPos(caretPos);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * Toggle comment on current editor's selection or HTML tag/CSS rule\n\t * @param {IEmmetEditor} editor\n\t */\n\trequire('actions').add('toggle_comment', function(editor) {\n\t\tvar info = require('editorUtils').outputInfo(editor);\n\t\tif (info.syntax == 'css') {\n\t\t\t// in case our editor is good enough and can recognize syntax from \n\t\t\t// current token, we have to make sure that cursor is not inside\n\t\t\t// 'style' attribute of html element\n\t\t\tvar caretPos = editor.getCaretPos();\n\t\t\tvar tag = require('htmlMatcher').tag(info.content, caretPos);\n\t\t\tif (tag && tag.open.range.inside(caretPos)) {\n\t\t\t\tinfo.syntax = 'html';\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (info.syntax == 'css')\n\t\t\treturn toggleCSSComment(editor);\n\t\t\n\t\treturn toggleHTMLComment(editor);\n\t});\n});/**\n * Move between next/prev edit points. 'Edit points' are places between tags \n * and quotes of empty attributes in html\n * @constructor\n * \n * @memberOf __editPointActionDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\t/**\n\t * Search for new caret insertion point\n\t * @param {IEmmetEditor} editor Editor instance\n\t * @param {Number} inc Search increment: -1 — search left, 1 — search right\n\t * @param {Number} offset Initial offset relative to current caret position\n\t * @return {Number} Returns -1 if insertion point wasn't found\n\t */\n\tfunction findNewEditPoint(editor, inc, offset) {\n\t\tinc = inc || 1;\n\t\toffset = offset || 0;\n\t\t\n\t\tvar curPoint = editor.getCaretPos() + offset;\n\t\tvar content = String(editor.getContent());\n\t\tvar maxLen = content.length;\n\t\tvar nextPoint = -1;\n\t\tvar reEmptyLine = /^\\s+$/;\n\t\t\n\t\tfunction getLine(ix) {\n\t\t\tvar start = ix;\n\t\t\twhile (start >= 0) {\n\t\t\t\tvar c = content.charAt(start);\n\t\t\t\tif (c == '\\n' || c == '\\r')\n\t\t\t\t\tbreak;\n\t\t\t\tstart--;\n\t\t\t}\n\t\t\t\n\t\t\treturn content.substring(start, ix);\n\t\t}\n\t\t\t\n\t\twhile (curPoint <= maxLen && curPoint >= 0) {\n\t\t\tcurPoint += inc;\n\t\t\tvar curChar = content.charAt(curPoint);\n\t\t\tvar nextChar = content.charAt(curPoint + 1);\n\t\t\tvar prevChar = content.charAt(curPoint - 1);\n\t\t\t\t\n\t\t\tswitch (curChar) {\n\t\t\t\tcase '\"':\n\t\t\t\tcase '\\'':\n\t\t\t\t\tif (nextChar == curChar && prevChar == '=') {\n\t\t\t\t\t\t// empty attribute\n\t\t\t\t\t\tnextPoint = curPoint + 1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '>':\n\t\t\t\t\tif (nextChar == '<') {\n\t\t\t\t\t\t// between tags\n\t\t\t\t\t\tnextPoint = curPoint + 1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\n':\n\t\t\t\tcase '\\r':\n\t\t\t\t\t// empty line\n\t\t\t\t\tif (reEmptyLine.test(getLine(curPoint - 1))) {\n\t\t\t\t\t\tnextPoint = curPoint;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tif (nextPoint != -1)\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\treturn nextPoint;\n\t}\n\t\n\t/** @type emmet.actions */\n\tvar actions = require('actions');\n\t\n\t/**\n\t * Move caret to previous edit point\n\t * @param {IEmmetEditor} editor Editor instance\n\t */\n\tactions.add('prev_edit_point', function(editor) {\n\t\tvar curPos = editor.getCaretPos();\n\t\tvar newPoint = findNewEditPoint(editor, -1);\n\t\t\t\n\t\tif (newPoint == curPos)\n\t\t\t// we're still in the same point, try searching from the other place\n\t\t\tnewPoint = findNewEditPoint(editor, -1, -2);\n\t\t\n\t\tif (newPoint != -1) {\n\t\t\teditor.setCaretPos(newPoint);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}, {label: 'Previous Edit Point'});\n\t\n\t/**\n\t * Move caret to next edit point\n\t * @param {IEmmetEditor} editor Editor instance\n\t */\n\tactions.add('next_edit_point', function(editor) {\n\t\tvar newPoint = findNewEditPoint(editor, 1);\n\t\tif (newPoint != -1) {\n\t\t\teditor.setCaretPos(newPoint);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t});\n});/**\n * Actions that use stream parsers and tokenizers for traversing:\n * -- Search for next/previous items in HTML\n * -- Search for next/previous items in CSS\n * @constructor\n * @memberOf __selectItemActionDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\tvar startTag = /^<([\\w\\:\\-]+)((?:\\s+[\\w\\-:]+(?:\\s*=\\s*(?:(?:\"[^\"]*\")|(?:'[^']*')|[^>\\s]+))?)*)\\s*(\\/?)>/;\n\t\n\t/**\n\t * Generic function for searching for items to select\n\t * @param {IEmmetEditor} editor\n\t * @param {Boolean} isBackward Search backward (search forward otherwise)\n\t * @param {Function} extractFn Function that extracts item content\n\t * @param {Function} rangeFn Function that search for next token range\n\t */\n\tfunction findItem(editor, isBackward, extractFn, rangeFn) {\n\t\tvar range = require('range');\n\t\tvar content = require('editorUtils').outputInfo(editor).content;\n\t\t\n\t\tvar contentLength = content.length;\n\t\tvar itemRange, rng;\n\t\t/** @type Range */\n\t\tvar prevRange = range.create(-1, 0);\n\t\t/** @type Range */\n\t\tvar sel = range.create(editor.getSelectionRange());\n\t\t\n\t\tvar searchPos = sel.start, loop = 100000; // endless loop protection\n\t\twhile (searchPos >= 0 && searchPos < contentLength && --loop > 0) {\n\t\t\tif ( (itemRange = extractFn(content, searchPos, isBackward)) ) {\n\t\t\t\tif (prevRange.equal(itemRange)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tprevRange = itemRange.clone();\n\t\t\t\trng = rangeFn(itemRange.substring(content), itemRange.start, sel.clone());\n\t\t\t\t\n\t\t\t\tif (rng) {\n\t\t\t\t\teditor.createSelection(rng.start, rng.end);\n\t\t\t\t\treturn true;\n\t\t\t\t} else {\n\t\t\t\t\tsearchPos = isBackward ? itemRange.start : itemRange.end - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tsearchPos += isBackward ? -1 : 1;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\t// XXX HTML section\n\t\n\t/**\n\t * Find next HTML item\n\t * @param {IEmmetEditor} editor\n\t */\n\tfunction findNextHTMLItem(editor) {\n\t\tvar isFirst = true;\n\t\treturn findItem(editor, false, function(content, searchPos){\n\t\t\tif (isFirst) {\n\t\t\t\tisFirst = false;\n\t\t\t\treturn findOpeningTagFromPosition(content, searchPos);\n\t\t\t} else {\n\t\t\t\treturn getOpeningTagFromPosition(content, searchPos);\n\t\t\t}\n\t\t}, function(tag, offset, selRange) {\n\t\t\treturn getRangeForHTMLItem(tag, offset, selRange, false);\n\t\t});\n\t}\n\t\n\t/**\n\t * Find previous HTML item\n\t * @param {IEmmetEditor} editor\n\t */\n\tfunction findPrevHTMLItem(editor) {\n\t\treturn findItem(editor, true, getOpeningTagFromPosition, function (tag, offset, selRange) {\n\t\t\treturn getRangeForHTMLItem(tag, offset, selRange, true);\n\t\t});\n\t}\n\t\n\t/**\n\t * Creates possible selection ranges for HTML tag\n\t * @param {String} source Original HTML source for tokens\n\t * @param {Array} tokens List of HTML tokens\n\t * @returns {Array}\n\t */\n\tfunction makePossibleRangesHTML(source, tokens, offset) {\n\t\toffset = offset || 0;\n\t\tvar range = require('range');\n\t\tvar result = [];\n\t\tvar attrStart = -1, attrName = '', attrValue = '', attrValueRange, tagName;\n\t\t_.each(tokens, function(tok) {\n\t\t\tswitch (tok.type) {\n\t\t\t\tcase 'tag':\n\t\t\t\t\ttagName = source.substring(tok.start, tok.end);\n\t\t\t\t\tif (/^<[\\w\\:\\-]/.test(tagName)) {\n\t\t\t\t\t\t// add tag name\n\t\t\t\t\t\tresult.push(range.create({\n\t\t\t\t\t\t\tstart: tok.start + 1, \n\t\t\t\t\t\t\tend: tok.end\n\t\t\t\t\t\t}));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'attribute':\n\t\t\t\t\tattrStart = tok.start;\n\t\t\t\t\tattrName = source.substring(tok.start, tok.end);\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase 'string':\n\t\t\t\t\t// attribute value\n\t\t\t\t\t// push full attribute first\n\t\t\t\t\t result.push(range.create(attrStart, tok.end - attrStart));\n\t\t\t\t\t \n\t\t\t\t\t attrValueRange = range.create(tok);\n\t\t\t\t\t attrValue = attrValueRange.substring(source);\n\t\t\t\t\t \n\t\t\t\t\t // is this a quoted attribute?\n\t\t\t\t\t if (isQuote(attrValue.charAt(0)))\n\t\t\t\t\t\t attrValueRange.start++;\n\t\t\t\t\t \n\t\t\t\t\t if (isQuote(attrValue.charAt(attrValue.length - 1)))\n\t\t\t\t\t\t attrValueRange.end--;\n\t\t\t\t\t \n\t\t\t\t\t result.push(attrValueRange);\n\t\t\t\t\t \n\t\t\t\t\t if (attrName == 'class') {\n\t\t\t\t\t\t result = result.concat(classNameRanges(attrValueRange.substring(source), attrValueRange.start));\n\t\t\t\t\t }\n\t\t\t\t\t \n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t});\n\t\t\n\t\t// offset ranges\n\t\t_.each(result, function(r) {\n\t\t\tr.shift(offset);\n\t\t});\n\t\t\n\t\treturn _.chain(result)\n\t\t\t.filter(function(item) {        // remove empty\n\t\t\t\treturn !!item.length();\n\t\t\t})\n\t\t\t.uniq(false, function(item) {   // remove duplicates\n\t\t\t\treturn item.toString();\n\t\t\t})\n\t\t\t.value();\n\t}\n\t\n\t/**\n\t * Returns ranges of class names in \"class\" attribute value\n\t * @param {String} className\n\t * @returns {Array}\n\t */\n\tfunction classNameRanges(className, offset) {\n\t\toffset = offset || 0;\n\t\tvar result = [];\n\t\t/** @type StringStream */\n\t\tvar stream = require('stringStream').create(className);\n\t\tvar range = require('range');\n\t\t\n\t\t// skip whitespace\n\t\tstream.eatSpace();\n\t\tstream.start = stream.pos;\n\t\t\n\t\tvar ch;\n\t\twhile (ch = stream.next()) {\n\t\t\tif (/[\\s\\u00a0]/.test(ch)) {\n\t\t\t\tresult.push(range.create(stream.start + offset, stream.pos - stream.start - 1));\n\t\t\t\tstream.eatSpace();\n\t\t\t\tstream.start = stream.pos;\n\t\t\t}\n\t\t}\n\t\t\n\t\tresult.push(range.create(stream.start + offset, stream.pos - stream.start));\n\t\treturn result;\n\t}\n\t\n\t/**\n\t * Returns best HTML tag range match for current selection\n\t * @param {String} tag Tag declaration\n\t * @param {Number} offset Tag's position index inside content\n\t * @param {Range} selRange Selection range\n\t * @return {Range} Returns range if next item was found, <code>null</code> otherwise\n\t */\n\tfunction getRangeForHTMLItem(tag, offset, selRange, isBackward) {\n\t\tvar ranges = makePossibleRangesHTML(tag, require('xmlParser').parse(tag), offset);\n\t\t\n\t\tif (isBackward)\n\t\t\tranges.reverse();\n\t\t\n\t\t// try to find selected range\n\t\tvar curRange = _.find(ranges, function(r) {\n\t\t\treturn r.equal(selRange);\n\t\t});\n\t\t\n\t\tif (curRange) {\n\t\t\tvar ix = _.indexOf(ranges, curRange);\n\t\t\tif (ix < ranges.length - 1)\n\t\t\t\treturn ranges[ix + 1];\n\t\t\t\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\t// no selected range, find nearest one\n\t\tif (isBackward)\n\t\t\t// search backward\n\t\t\treturn _.find(ranges, function(r) {\n\t\t\t\treturn r.start < selRange.start;\n\t\t\t});\n\t\t\n\t\t// search forward\n\t\t// to deal with overlapping ranges (like full attribute definition\n\t\t// and attribute value) let's find range under caret first\n\t\tif (!curRange) {\n\t\t\tvar matchedRanges = _.filter(ranges, function(r) {\n\t\t\t\treturn r.inside(selRange.end);\n\t\t\t});\n\t\t\t\n\t\t\tif (matchedRanges.length > 1)\n\t\t\t\treturn matchedRanges[1];\n\t\t}\n\t\t\n\t\t\n\t\treturn _.find(ranges, function(r) {\n\t\t\treturn r.end > selRange.end;\n\t\t});\n\t}\n\t\n\t/**\n\t * Search for opening tag in content, starting at specified position\n\t * @param {String} html Where to search tag\n\t * @param {Number} pos Character index where to start searching\n\t * @return {Range} Returns range if valid opening tag was found,\n\t * <code>null</code> otherwise\n\t */\n\tfunction findOpeningTagFromPosition(html, pos) {\n\t\tvar tag;\n\t\twhile (pos >= 0) {\n\t\t\tif (tag = getOpeningTagFromPosition(html, pos))\n\t\t\t\treturn tag;\n\t\t\tpos--;\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\t\n\t/**\n\t * @param {String} html Where to search tag\n\t * @param {Number} pos Character index where to start searching\n\t * @return {Range} Returns range if valid opening tag was found,\n\t * <code>null</code> otherwise\n\t */\n\tfunction getOpeningTagFromPosition(html, pos) {\n\t\tvar m;\n\t\tif (html.charAt(pos) == '<' && (m = html.substring(pos, html.length).match(startTag))) {\n\t\t\treturn require('range').create(pos, m[0]);\n\t\t}\n\t}\n\t\n\tfunction isQuote(ch) {\n\t\treturn ch == '\"' || ch == \"'\";\n\t}\n\t\n\t/**\n\t * Makes all possible selection ranges for specified CSS property\n\t * @param {CSSProperty} property\n\t * @returns {Array}\n\t */\n\tfunction makePossibleRangesCSS(property) {\n\t\t// find all possible ranges, sorted by position and size\n\t\tvar valueRange = property.valueRange(true);\n\t\tvar result = [property.range(true), valueRange];\n\t\tvar stringStream = require('stringStream');\n\t\tvar cssEditTree = require('cssEditTree');\n\t\tvar range = require('range');\n\t\t\n\t\t// locate parts of complex values.\n\t\t// some examples:\n\t\t// – 1px solid red: 3 parts\n\t\t// – arial, sans-serif: enumeration, 2 parts\n\t\t// – url(image.png): function value part\n\t\tvar value = property.value();\n\t\t_.each(property.valueParts(), function(r) {\n\t\t\t// add absolute range\n\t\t\tvar clone = r.clone();\n\t\t\tresult.push(clone.shift(valueRange.start));\n\t\t\t\n\t\t\t/** @type StringStream */\n\t\t\tvar stream = stringStream.create(r.substring(value));\n\t\t\tif (stream.match(/^[\\w\\-]+\\(/, true)) {\n\t\t\t\t// we have a function, find values in it.\n\t\t\t\t// but first add function contents\n\t\t\t\tstream.start = stream.pos;\n\t\t\t\tstream.skipToPair('(', ')');\n\t\t\t\tvar fnBody = stream.current();\n\t\t\t\tresult.push(range.create(clone.start + stream.start, fnBody));\n\t\t\t\t\n\t\t\t\t// find parts\n\t\t\t\t_.each(cssEditTree.findParts(fnBody), function(part) {\n\t\t\t\t\tresult.push(range.create(clone.start + stream.start + part.start, part.substring(fnBody)));\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t\t\n\t\t// optimize result: remove empty ranges and duplicates\n\t\treturn _.chain(result)\n\t\t\t.filter(function(item) {\n\t\t\t\treturn !!item.length();\n\t\t\t})\n\t\t\t.uniq(false, function(item) {\n\t\t\t\treturn item.toString();\n\t\t\t})\n\t\t\t.value();\n\t}\n\t\n\t/**\n\t * Tries to find matched CSS property and nearest range for selection\n\t * @param {CSSRule} rule\n\t * @param {Range} selRange\n\t * @param {Boolean} isBackward\n\t * @returns {Range}\n\t */\n\tfunction matchedRangeForCSSProperty(rule, selRange, isBackward) {\n\t\t/** @type CSSProperty */\n\t\tvar property = null;\n\t\tvar possibleRanges, curRange = null, ix;\n\t\tvar list = rule.list();\n\t\tvar searchFn, nearestItemFn;\n\t\t\n\t\tif (isBackward) {\n\t\t\tlist.reverse();\n\t\t\tsearchFn = function(p) {\n\t\t\t\treturn p.range(true).start <= selRange.start;\n\t\t\t};\n\t\t\tnearestItemFn = function(r) {\n\t\t\t\treturn r.start < selRange.start;\n\t\t\t};\n\t\t} else {\n\t\t\tsearchFn = function(p) {\n\t\t\t\treturn p.range(true).end >= selRange.end;\n\t\t\t};\n\t\t\tnearestItemFn = function(r) {\n\t\t\t\treturn r.end > selRange.start;\n\t\t\t};\n\t\t}\n\t\t\n\t\t// search for nearest to selection CSS property\n\t\twhile (property = _.find(list, searchFn)) {\n\t\t\tpossibleRanges = makePossibleRangesCSS(property);\n\t\t\tif (isBackward)\n\t\t\t\tpossibleRanges.reverse();\n\t\t\t\n\t\t\t// check if any possible range is already selected\n\t\t\tcurRange = _.find(possibleRanges, function(r) {\n\t\t\t\treturn r.equal(selRange);\n\t\t\t});\n\t\t\t\n\t\t\tif (!curRange) {\n\t\t\t\t// no selection, select nearest item\n\t\t\t\tvar matchedRanges = _.filter(possibleRanges, function(r) {\n\t\t\t\t\treturn r.inside(selRange.end);\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tif (matchedRanges.length > 1) {\n\t\t\t\t\tcurRange = matchedRanges[1];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (curRange = _.find(possibleRanges, nearestItemFn))\n\t\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tix = _.indexOf(possibleRanges, curRange);\n\t\t\t\tif (ix != possibleRanges.length - 1) {\n\t\t\t\t\tcurRange = possibleRanges[ix + 1];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tcurRange = null;\n\t\t\tselRange.start = selRange.end = isBackward \n\t\t\t\t? property.range(true).start - 1\n\t\t\t\t: property.range(true).end + 1;\n\t\t}\n\t\t\n\t\treturn curRange;\n\t}\n\t\n\tfunction findNextCSSItem(editor) {\n\t\treturn findItem(editor, false, require('cssEditTree').extractRule, getRangeForNextItemInCSS);\n\t}\n\t\n\tfunction findPrevCSSItem(editor) {\n\t\treturn findItem(editor, true, require('cssEditTree').extractRule, getRangeForPrevItemInCSS);\n\t}\n\t\n\t/**\n\t * Returns range for item to be selected in CSS after current caret \n\t * (selection) position\n\t * @param {String} rule CSS rule declaration\n\t * @param {Number} offset Rule's position index inside content\n\t * @param {Range} selRange Selection range\n\t * @return {Range} Returns range if next item was found, <code>null</code> otherwise\n\t */\n\tfunction getRangeForNextItemInCSS(rule, offset, selRange) {\n\t\tvar tree = require('cssEditTree').parse(rule, {\n\t\t\toffset: offset\n\t\t});\n\t\t\n\t\t// check if selector is matched\n\t\tvar range = tree.nameRange(true);\n\t\tif (selRange.end < range.end) {\n\t\t\treturn range;\n\t\t}\n\t\t\n\t\treturn matchedRangeForCSSProperty(tree, selRange, false);\n\t}\n\t\n\t/**\n\t * Returns range for item to be selected in CSS before current caret \n\t * (selection) position\n\t * @param {String} rule CSS rule declaration\n\t * @param {Number} offset Rule's position index inside content\n\t * @param {Range} selRange Selection range\n\t * @return {Range} Returns range if previous item was found, <code>null</code> otherwise\n\t */\n\tfunction getRangeForPrevItemInCSS(rule, offset, selRange) {\n\t\tvar tree = require('cssEditTree').parse(rule, {\n\t\t\toffset: offset\n\t\t});\n\t\t\n\t\tvar curRange = matchedRangeForCSSProperty(tree, selRange, true);\n\t\t\n\t\tif (!curRange) {\n\t\t\t// no matched property, try to match selector\n\t\t\tvar range = tree.nameRange(true);\n\t\t\tif (selRange.start > range.start) {\n\t\t\t\treturn range;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn curRange;\n\t}\n\t\n\t// XXX register actions\n\tvar actions = require('actions');\n\tactions.add('select_next_item', function(editor){\n\t\tif (editor.getSyntax() == 'css')\n\t\t\treturn findNextCSSItem(editor);\n\t\telse\n\t\t\treturn findNextHTMLItem(editor);\n\t});\n\t\n\tactions.add('select_previous_item', function(editor){\n\t\tif (editor.getSyntax() == 'css')\n\t\t\treturn findPrevCSSItem(editor);\n\t\telse\n\t\t\treturn findPrevHTMLItem(editor);\n\t});\n});/**\n * HTML pair matching (balancing) actions\n * @constructor\n * @memberOf __matchPairActionDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\t/** @type emmet.actions */\n\tvar actions = require('actions');\n\tvar matcher = require('htmlMatcher');\n\tvar lastMatch = null;\n\t\n\t/**\n\t * Find and select HTML tag pair\n\t * @param {IEmmetEditor} editor Editor instance\n\t * @param {String} direction Direction of pair matching: 'in' or 'out'. \n\t * Default is 'out'\n\t */\n\tfunction matchPair(editor, direction) {\n\t\tdirection = String((direction || 'out').toLowerCase());\n\t\tvar info = require('editorUtils').outputInfo(editor);\n\t\t\n\t\tvar range = require('range');\n\t\t/** @type Range */\n\t\tvar sel = range.create(editor.getSelectionRange());\n\t\tvar content = info.content;\n\t\t\n\t\t// validate previous match\n\t\tif (lastMatch && !lastMatch.range.equal(sel)) {\n\t\t\tlastMatch = null;\n\t\t}\n\t\t\n\t\tif (lastMatch && sel.length()) {\n\t\t\tif (direction == 'in') {\n\t\t\t\t// user has previously selected tag and wants to move inward\n\t\t\t\tif (lastMatch.type == 'tag' && !lastMatch.close) {\n\t\t\t\t\t// unary tag was selected, can't move inward\n\t\t\t\t\treturn false;\n\t\t\t\t} else {\n\t\t\t\t\tif (lastMatch.range.equal(lastMatch.outerRange)) {\n\t\t\t\t\t\tlastMatch.range = lastMatch.innerRange;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar narrowed = require('utils').narrowToNonSpace(content, lastMatch.innerRange);\n\t\t\t\t\t\tlastMatch = matcher.find(content, narrowed.start + 1);\n\t\t\t\t\t\tif (lastMatch && lastMatch.range.equal(sel) && lastMatch.outerRange.equal(sel)) {\n\t\t\t\t\t\t\tlastMatch.range = lastMatch.innerRange;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (\n\t\t\t\t\t\t!lastMatch.innerRange.equal(lastMatch.outerRange) \n\t\t\t\t\t\t&& lastMatch.range.equal(lastMatch.innerRange) \n\t\t\t\t\t\t&& sel.equal(lastMatch.range)) {\n\t\t\t\t\tlastMatch.range = lastMatch.outerRange;\n\t\t\t\t} else {\n\t\t\t\t\tlastMatch = matcher.find(content, sel.start);\n\t\t\t\t\tif (lastMatch && lastMatch.range.equal(sel) && lastMatch.innerRange.equal(sel)) {\n\t\t\t\t\t\tlastMatch.range = lastMatch.outerRange;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tlastMatch = matcher.find(content, sel.start);\n\t\t}\n\t\t\n\t\tif (lastMatch && !lastMatch.range.equal(sel)) {\n\t\t\teditor.createSelection(lastMatch.range.start, lastMatch.range.end);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tlastMatch = null;\n\t\treturn false;\n\t}\n\t\n\tactions.add('match_pair', matchPair, {hidden: true});\n\tactions.add('match_pair_inward', function(editor){\n\t\treturn matchPair(editor, 'in');\n\t}, {label: 'HTML/Match Pair Tag (inward)'});\n\n\tactions.add('match_pair_outward', function(editor){\n\t\treturn matchPair(editor, 'out');\n\t}, {label: 'HTML/Match Pair Tag (outward)'});\n\t\n\t/**\n\t * Moves caret to matching opening or closing tag\n\t * @param {IEmmetEditor} editor\n\t */\n\tactions.add('matching_pair', function(editor) {\n\t\tvar content = String(editor.getContent());\n\t\tvar caretPos = editor.getCaretPos();\n\t\t\n\t\tif (content.charAt(caretPos) == '<') \n\t\t\t// looks like caret is outside of tag pair  \n\t\t\tcaretPos++;\n\t\t\t\n\t\tvar tag = matcher.tag(content, caretPos);\n\t\tif (tag && tag.close) { // exclude unary tags\n\t\t\tif (tag.open.range.inside(caretPos)) {\n\t\t\t\teditor.setCaretPos(tag.close.range.start);\n\t\t\t} else {\n\t\t\t\teditor.setCaretPos(tag.open.range.start);\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}, {label: 'HTML/Go To Matching Tag Pair'});\n});/**\n * Gracefully removes tag under cursor\n * \n * @param {Function} require\n * @param {Underscore} _ \n */\nemmet.exec(function(require, _) {\n\trequire('actions').add('remove_tag', function(editor) {\n\t\tvar utils = require('utils');\n\t\tvar info = require('editorUtils').outputInfo(editor);\n\t\t\n\t\t// search for tag\n\t\tvar tag = require('htmlMatcher').tag(info.content, editor.getCaretPos());\n\t\tif (tag) {\n\t\t\tif (!tag.close) {\n\t\t\t\t// simply remove unary tag\n\t\t\t\teditor.replaceContent(utils.getCaretPlaceholder(), tag.range.start, tag.range.end);\n\t\t\t} else {\n\t\t\t\t// remove tag and its newlines\n\t\t\t\t/** @type Range */\n\t\t\t\tvar tagContentRange = utils.narrowToNonSpace(info.content, tag.innerRange);\n\t\t\t\t/** @type Range */\n\t\t\t\tvar startLineBounds = utils.findNewlineBounds(info.content, tagContentRange.start);\n\t\t\t\tvar startLinePad = utils.getLinePadding(startLineBounds.substring(info.content));\n\t\t\t\tvar tagContent = tagContentRange.substring(info.content);\n\t\t\t\t\n\t\t\t\ttagContent = utils.unindentString(tagContent, startLinePad);\n\t\t\t\teditor.replaceContent(utils.getCaretPlaceholder() + utils.escapeText(tagContent), tag.outerRange.start, tag.outerRange.end);\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}, {label: 'HTML/Remove Tag'});\n});\n/**\n * Splits or joins tag, e.g. transforms it into a short notation and vice versa:<br>\n * &lt;div&gt;&lt;/div&gt; → &lt;div /&gt; : join<br>\n * &lt;div /&gt; → &lt;div&gt;&lt;/div&gt; : split\n * @param {Function} require\n * @param {Underscore} _\n * @memberOf __splitJoinTagAction\n * @constructor\n */\nemmet.exec(function(require, _) {\n\t/**\n\t * @param {IEmmetEditor} editor\n\t * @param {Object} profile\n\t * @param {Object} tag\n\t */\n\tfunction joinTag(editor, profile, tag) {\n\t\t/** @type emmet.utils */\n\t\tvar utils = require('utils');\n\t\t\n\t\t// empty closing slash is a nonsense for this action\n\t\tvar slash = profile.selfClosing() || ' /';\n\t\tvar content = tag.open.range.substring(tag.source).replace(/\\s*>$/, slash + '>');\n\t\t\n\t\tvar caretPos = editor.getCaretPos();\n\t\t\n\t\t// update caret position\n\t\tif (content.length + tag.outerRange.start < caretPos) {\n\t\t\tcaretPos = content.length + tag.outerRange.start;\n\t\t}\n\t\t\n\t\tcontent = utils.escapeText(content);\n\t\teditor.replaceContent(content, tag.outerRange.start, tag.outerRange.end);\n\t\teditor.setCaretPos(caretPos);\n\t\treturn true;\n\t}\n\t\n\tfunction splitTag(editor, profile, tag) {\n\t\t/** @type emmet.utils */\n\t\tvar utils = require('utils');\n\t\t\n\t\tvar nl = utils.getNewline();\n\t\tvar pad = require('resources').getVariable('indentation');\n\t\tvar caretPos = editor.getCaretPos();\n\t\t\n\t\t// define tag content depending on profile\n\t\tvar tagContent = (profile.tag_nl === true) ? nl + pad + nl : '';\n\t\tvar content = tag.outerContent().replace(/\\s*\\/>$/, '>');\n\t\tcaretPos = tag.outerRange.start + content.length;\n\t\tcontent += tagContent + '</' + tag.open.name + '>';\n\t\t\n\t\tcontent = utils.escapeText(content);\n\t\teditor.replaceContent(content, tag.outerRange.start, tag.outerRange.end);\n\t\teditor.setCaretPos(caretPos);\n\t\treturn true;\n\t}\n\t\n\trequire('actions').add('split_join_tag', function(editor, profileName) {\n\t\tvar matcher = require('htmlMatcher');\n\t\t\n\t\tvar info = require('editorUtils').outputInfo(editor, null, profileName);\n\t\tvar profile = require('profile').get(info.profile);\n\t\t\n\t\t// find tag at current position\n\t\tvar tag = matcher.tag(info.content, editor.getCaretPos());\n\t\tif (tag) {\n\t\t\treturn tag.close \n\t\t\t\t? joinTag(editor, profile, tag) \n\t\t\t\t: splitTag(editor, profile, tag);\n\t\t}\n\t\t\n\t\treturn false;\n\t}, {label: 'HTML/Split\\\\Join Tag Declaration'});\n});/**\n * Reflect CSS value: takes rule's value under caret and pastes it for the same \n * rules with vendor prefixes\n * @constructor\n * @memberOf __reflectCSSActionDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.define('reflectCSSValue', function(require, _) {\n\t/**\n\t * @type HandlerList List of registered handlers\n\t */\n\tvar handlers = require('handlerList').create();\n\t\n\trequire('actions').add('reflect_css_value', function(editor) {\n\t\tif (editor.getSyntax() != 'css') return false;\n\t\t\n\t\treturn require('actionUtils').compoundUpdate(editor, doCSSReflection(editor));\n\t}, {label: 'CSS/Reflect Value'});\n\t\n\tfunction doCSSReflection(editor) {\n\t\t/** @type emmet.cssEditTree */\n\t\tvar cssEditTree = require('cssEditTree');\n\t\tvar outputInfo = require('editorUtils').outputInfo(editor);\n\t\tvar caretPos = editor.getCaretPos();\n\t\t\n\t\tvar cssRule = cssEditTree.parseFromPosition(outputInfo.content, caretPos);\n\t\tif (!cssRule) return;\n\t\t\n\t\tvar property = cssRule.itemFromPosition(caretPos, true);\n\t\t// no property under cursor, nothing to reflect\n\t\tif (!property) return;\n\t\t\n\t\tvar oldRule = cssRule.source;\n\t\tvar offset = cssRule.options.offset;\n\t\tvar caretDelta = caretPos - offset - property.range().start;\n\t\t\n\t\thandlers.exec(false, [property]);\n\t\t\n\t\tif (oldRule !== cssRule.source) {\n\t\t\treturn {\n\t\t\t\tdata:  cssRule.source,\n\t\t\t\tstart: offset,\n\t\t\t\tend:   offset + oldRule.length,\n\t\t\t\tcaret: offset + property.range().start + caretDelta\n\t\t\t};\n\t\t}\n\t}\n\t\n\t/**\n\t * Returns regexp that should match reflected CSS property names\n\t * @param {String} name Current CSS property name\n\t * @return {RegExp}\n\t */\n\tfunction getReflectedCSSName(name) {\n\t\tname = require('cssEditTree').baseName(name);\n\t\tvar vendorPrefix = '^(?:\\\\-\\\\w+\\\\-)?', m;\n\t\t\n\t\tif (name == 'opacity' || name == 'filter') {\n\t\t\treturn new RegExp(vendorPrefix + '(?:opacity|filter)$');\n\t\t} else if (m = name.match(/^border-radius-(top|bottom)(left|right)/)) {\n\t\t\t// Mozilla-style border radius\n\t\t\treturn new RegExp(vendorPrefix + '(?:' + name + '|border-' + m[1] + '-' + m[2] + '-radius)$');\n\t\t} else if (m = name.match(/^border-(top|bottom)-(left|right)-radius/)) { \n\t\t\treturn new RegExp(vendorPrefix + '(?:' + name + '|border-radius-' + m[1] + m[2] + ')$');\n\t\t}\n\t\t\n\t\treturn new RegExp(vendorPrefix + name + '$');\n\t}\n\t\n\t/**\n\t * Reflects value from <code>donor</code> into <code>receiver</code>\n\t * @param {CSSProperty} donor Donor CSS property from which value should\n\t * be reflected\n\t * @param {CSSProperty} receiver Property that should receive reflected \n\t * value from donor\n\t */\n\tfunction reflectValue(donor, receiver) {\n\t\tvar value = getReflectedValue(donor.name(), donor.value(), \n\t\t\t\treceiver.name(), receiver.value());\n\t\t\n\t\treceiver.value(value);\n\t}\n\t\n\t/**\n\t * Returns value that should be reflected for <code>refName</code> CSS property\n\t * from <code>curName</code> property. This function is used for special cases,\n\t * when the same result must be achieved with different properties for different\n\t * browsers. For example: opаcity:0.5; → filter:alpha(opacity=50);<br><br>\n\t * \n\t * This function does value conversion between different CSS properties\n\t * \n\t * @param {String} curName Current CSS property name\n\t * @param {String} curValue Current CSS property value\n\t * @param {String} refName Receiver CSS property's name \n\t * @param {String} refValue Receiver CSS property's value\n\t * @return {String} New value for receiver property\n\t */\n\tfunction getReflectedValue(curName, curValue, refName, refValue) {\n\t\tvar cssEditTree = require('cssEditTree');\n\t\tvar utils = require('utils');\n\t\tcurName = cssEditTree.baseName(curName);\n\t\trefName = cssEditTree.baseName(refName);\n\t\t\n\t\tif (curName == 'opacity' && refName == 'filter') {\n\t\t\treturn refValue.replace(/opacity=[^)]*/i, 'opacity=' + Math.floor(parseFloat(curValue) * 100));\n\t\t} else if (curName == 'filter' && refName == 'opacity') {\n\t\t\tvar m = curValue.match(/opacity=([^)]*)/i);\n\t\t\treturn m ? utils.prettifyNumber(parseInt(m[1]) / 100) : refValue;\n\t\t}\n\t\t\n\t\treturn curValue;\n\t}\n\t\n\t// XXX add default handler\n\thandlers.add(function(property) {\n\t\tvar reName = getReflectedCSSName(property.name());\n\t\t_.each(property.parent.list(), function(p) {\n\t\t\tif (reName.test(p.name())) {\n\t\t\t\treflectValue(property, p);\n\t\t\t}\n\t\t});\n\t}, {order: -1});\n\t\n\treturn {\n\t\t/**\n\t\t * Adds custom reflect handler. The passed function will receive matched\n\t\t * CSS property (as <code>CSSEditElement</code> object) and should\n\t\t * return <code>true</code> if it was performed successfully (handled \n\t\t * reflection), <code>false</code> otherwise.\n\t\t * @param {Function} fn\n\t\t * @param {Object} options\n\t\t */\n\t\taddHandler: function(fn, options) {\n\t\t\thandlers.add(fn, options);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Removes registered handler\n\t\t * @returns\n\t\t */\n\t\tremoveHandler: function(fn) {\n\t\t\thandlers.remove(fn, options);\n\t\t}\n\t};\n});/**\n * Evaluates simple math expression under caret\n * @param {Function} require\n * @param {Underscore} _ \n */\nemmet.exec(function(require, _) {\n\trequire('actions').add('evaluate_math_expression', function(editor) {\n\t\tvar actionUtils = require('actionUtils');\n\t\tvar utils = require('utils');\n\t\t\n\t\tvar content = String(editor.getContent());\n\t\tvar chars = '.+-*/\\\\';\n\t\t\n\t\t/** @type Range */\n\t\tvar sel = require('range').create(editor.getSelectionRange());\n\t\tif (!sel.length()) {\n\t\t\tsel = actionUtils.findExpressionBounds(editor, function(ch) {\n\t\t\t\treturn utils.isNumeric(ch) || chars.indexOf(ch) != -1;\n\t\t\t});\n\t\t}\n\t\t\n\t\tif (sel && sel.length()) {\n\t\t\tvar expr = sel.substring(content);\n\t\t\t\n\t\t\t// replace integral division: 11\\2 => Math.round(11/2) \n\t\t\texpr = expr.replace(/([\\d\\.\\-]+)\\\\([\\d\\.\\-]+)/g, 'Math.round($1/$2)');\n\t\t\t\n\t\t\ttry {\n\t\t\t\tvar result = utils.prettifyNumber(new Function('return ' + expr)());\n\t\t\t\teditor.replaceContent(result, sel.start, sel.end);\n\t\t\t\teditor.setCaretPos(sel.start + result.length);\n\t\t\t\treturn true;\n\t\t\t} catch (e) {}\n\t\t}\n\t\t\n\t\treturn false;\n\t}, {label: 'Numbers/Evaluate Math Expression'});\n});\n/**\n * Increment/decrement number under cursor\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\t/**\n\t * Extract number from current caret position of the <code>editor</code> and\n\t * increment it by <code>step</code>\n\t * @param {IEmmetEditor} editor\n\t * @param {Number} step Increment step (may be negative)\n\t */\n\tfunction incrementNumber(editor, step) {\n\t\tvar utils = require('utils');\n\t\tvar actionUtils = require('actionUtils');\n\t\t\n\t\tvar hasSign = false;\n\t\tvar hasDecimal = false;\n\t\t\t\n\t\tvar r = actionUtils.findExpressionBounds(editor, function(ch, pos, content) {\n\t\t\tif (utils.isNumeric(ch))\n\t\t\t\treturn true;\n\t\t\tif (ch == '.') {\n\t\t\t\t// make sure that next character is numeric too\n\t\t\t\tif (!utils.isNumeric(content.charAt(pos + 1)))\n\t\t\t\t\treturn false;\n\t\t\t\t\n\t\t\t\treturn hasDecimal ? false : hasDecimal = true;\n\t\t\t}\n\t\t\tif (ch == '-')\n\t\t\t\treturn hasSign ? false : hasSign = true;\n\t\t\t\t\n\t\t\treturn false;\n\t\t});\n\t\t\t\n\t\tif (r && r.length()) {\n\t\t\tvar strNum = r.substring(String(editor.getContent()));\n\t\t\tvar num = parseFloat(strNum);\n\t\t\tif (!_.isNaN(num)) {\n\t\t\t\tnum = utils.prettifyNumber(num + step);\n\t\t\t\t\n\t\t\t\t// do we have zero-padded number?\n\t\t\t\tif (/^(\\-?)0+[1-9]/.test(strNum)) {\n\t\t\t\t\tvar minus = '';\n\t\t\t\t\tif (RegExp.$1) {\n\t\t\t\t\t\tminus = '-';\n\t\t\t\t\t\tnum = num.substring(1);\n\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\tvar parts = num.split('.');\n\t\t\t\t\tparts[0] = utils.zeroPadString(parts[0], intLength(strNum));\n\t\t\t\t\tnum = minus + parts.join('.');\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\teditor.replaceContent(num, r.start, r.end);\n\t\t\t\teditor.createSelection(r.start, r.start + num.length);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * Returns length of integer part of number\n\t * @param {String} num\n\t */\n\tfunction intLength(num) {\n\t\tnum = num.replace(/^\\-/, '');\n\t\tif (~num.indexOf('.')) {\n\t\t\treturn num.split('.')[0].length;\n\t\t}\n\t\t\n\t\treturn num.length;\n\t}\n\t\n\tvar actions = require('actions');\n\t_.each([1, -1, 10, -10, 0.1, -0.1], function(num) {\n\t\tvar prefix = num > 0 ? 'increment' : 'decrement';\n\t\t\n\t\tactions.add(prefix + '_number_by_' + String(Math.abs(num)).replace('.', '').substring(0, 2), function(editor) {\n\t\t\treturn incrementNumber(editor, num);\n\t\t}, {label: 'Numbers/' + prefix.charAt(0).toUpperCase() + prefix.substring(1) + ' number by ' + Math.abs(num)});\n\t});\n});/**\n * Actions to insert line breaks. Some simple editors (like browser's \n * &lt;textarea&gt;, for example) do not provide such simple things\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\tvar actions = require('actions');\n\t/** @type emmet.preferences */\n\tvar prefs = require('preferences');\n\t\n\t// setup default preferences\n\tprefs.define('css.closeBraceIndentation', '\\n',\n\t\t\t'Indentation before closing brace of CSS rule. Some users prefere ' \n\t\t\t+ 'indented closing brace of CSS rule for better readability. '\n\t\t\t+ 'This preference’s value will be automatically inserted before '\n\t\t\t+ 'closing brace when user adds newline in newly created CSS rule '\n\t\t\t+ '(e.g. when “Insert formatted linebreak” action will be performed ' \n\t\t\t+ 'in CSS file). If you’re such user, you may want to write put a value ' \n\t\t\t+ 'like <code>\\\\n\\\\t</code> in this preference.');\n\t\n\t/**\n\t * Inserts newline character with proper indentation in specific positions only.\n\t * @param {IEmmetEditor} editor\n\t * @return {Boolean} Returns <code>true</code> if line break was inserted \n\t */\n\tactions.add('insert_formatted_line_break_only', function(editor) {\n\t\tvar utils = require('utils');\n\t\t/** @type emmet.resources */\n\t\tvar res = require('resources');\n\t\t\n\t\tvar info = require('editorUtils').outputInfo(editor);\n\t\tvar caretPos = editor.getCaretPos();\n\t\tvar nl = utils.getNewline();\n\t\t\n\t\tif (_.include(['html', 'xml', 'xsl'], info.syntax)) {\n\t\t\tvar pad = res.getVariable('indentation');\n\t\t\t// let's see if we're breaking newly created tag\n\t\t\tvar tag = require('htmlMatcher').tag(info.content, caretPos);\n\t\t\tif (tag && !tag.innerRange.length()) {\n\t\t\t\teditor.replaceContent(nl + pad + utils.getCaretPlaceholder() + nl, caretPos);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else if (info.syntax == 'css') {\n\t\t\t/** @type String */\n\t\t\tvar content = info.content;\n\t\t\tif (caretPos && content.charAt(caretPos - 1) == '{') {\n\t\t\t\tvar append = prefs.get('css.closeBraceIndentation');\n\t\t\t\tvar pad = res.getVariable('indentation');\n\t\t\t\t\n\t\t\t\tvar hasCloseBrace = content.charAt(caretPos) == '}';\n\t\t\t\tif (!hasCloseBrace) {\n\t\t\t\t\t// do we really need special formatting here?\n\t\t\t\t\t// check if this is really a newly created rule,\n\t\t\t\t\t// look ahead for a closing brace\n\t\t\t\t\tfor (var i = caretPos, il = content.length, ch; i < il; i++) {\n\t\t\t\t\t\tch = content.charAt(i);\n\t\t\t\t\t\tif (ch == '{') {\n\t\t\t\t\t\t\t// ok, this is a new rule without closing brace\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (ch == '}') {\n\t\t\t\t\t\t\t// not a new rule, just add indentation\n\t\t\t\t\t\t\tappend = '';\n\t\t\t\t\t\t\thasCloseBrace = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (!hasCloseBrace) {\n\t\t\t\t\tappend += '}';\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// defining rule set\n\t\t\t\tvar insValue = nl + pad + utils.getCaretPlaceholder() + append;\n\t\t\t\teditor.replaceContent(insValue, caretPos);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\t\n\t\treturn false;\n\t}, {hidden: true});\n\t\n\t/**\n\t * Inserts newline character with proper indentation. This action is used in\n\t * editors that doesn't have indentation control (like textarea element) to \n\t * provide proper indentation\n\t * @param {IEmmetEditor} editor Editor instance\n\t */\n\tactions.add('insert_formatted_line_break', function(editor) {\n\t\tif (!actions.run('insert_formatted_line_break_only', editor)) {\n\t\t\tvar utils = require('utils');\n\t\t\t\n\t\t\tvar curPadding = require('editorUtils').getCurrentLinePadding(editor);\n\t\t\tvar content = String(editor.getContent());\n\t\t\tvar caretPos = editor.getCaretPos();\n\t\t\tvar len = content.length;\n\t\t\tvar nl = utils.getNewline();\n\t\t\t\t\n\t\t\t// check out next line padding\n\t\t\tvar lineRange = editor.getCurrentLineRange();\n\t\t\tvar nextPadding = '';\n\t\t\t\t\n\t\t\tfor (var i = lineRange.end + 1, ch; i < len; i++) {\n\t\t\t\tch = content.charAt(i);\n\t\t\t\tif (ch == ' ' || ch == '\\t')\n\t\t\t\t\tnextPadding += ch;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tif (nextPadding.length > curPadding.length)\n\t\t\t\teditor.replaceContent(nl + nextPadding, caretPos, caretPos, true);\n\t\t\telse\n\t\t\t\teditor.replaceContent(nl, caretPos);\n\t\t}\n\t\t\n\t\treturn true;\n\t}, {hidden: true});\n});/**\n * Merges selected lines or lines between XHTML tag pairs\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\trequire('actions').add('merge_lines', function(editor) {\n\t\tvar matcher = require('htmlMatcher');\n\t\tvar utils = require('utils');\n\t\tvar editorUtils = require('editorUtils');\n\t\tvar info = editorUtils.outputInfo(editor);\n\t\t\n\t\t/** @type Range */\n\t\tvar selection = require('range').create(editor.getSelectionRange());\n\t\tif (!selection.length()) {\n\t\t\t// find matching tag\n\t\t\tvar pair = matcher.find(info.content, editor.getCaretPos());\n\t\t\tif (pair) {\n\t\t\t\tselection = pair.outerRange;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (selection.length()) {\n\t\t\t// got range, merge lines\n\t\t\tvar text =  selection.substring(info.content);\n\t\t\tvar lines = utils.splitByLines(text);\n\t\t\t\n\t\t\tfor (var i = 1; i < lines.length; i++) {\n\t\t\t\tlines[i] = lines[i].replace(/^\\s+/, '');\n\t\t\t}\n\t\t\t\n\t\t\ttext = lines.join('').replace(/\\s{2,}/, ' ');\n\t\t\tvar textLen = text.length;\n\t\t\ttext = utils.escapeText(text);\n\t\t\teditor.replaceContent(text, selection.start, selection.end);\n\t\t\teditor.createSelection(selection.start, selection.start + textLen);\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t});\n});/**\n * Encodes/decodes image under cursor to/from base64\n * @param {IEmmetEditor} editor\n * @since 0.65\n * \n * @memberOf __base64ActionDefine\n * @constructor\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\trequire('actions').add('encode_decode_data_url', function(editor) {\n\t\tvar data = String(editor.getSelection());\n\t\tvar caretPos = editor.getCaretPos();\n\t\t\t\n\t\tif (!data) {\n\t\t\t// no selection, try to find image bounds from current caret position\n\t\t\tvar text = String(editor.getContent()),  m;\n\t\t\twhile (caretPos-- >= 0) {\n\t\t\t\tif (startsWith('src=', text, caretPos)) { // found <img src=\"\">\n\t\t\t\t\tif (m = text.substr(caretPos).match(/^(src=([\"'])?)([^'\"<>\\s]+)\\1?/)) {\n\t\t\t\t\t\tdata = m[3];\n\t\t\t\t\t\tcaretPos += m[1].length;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (startsWith('url(', text, caretPos)) { // found CSS url() pattern\n\t\t\t\t\tif (m = text.substr(caretPos).match(/^(url\\((['\"])?)([^'\"\\)\\s]+)\\1?/)) {\n\t\t\t\t\t\tdata = m[3];\n\t\t\t\t\t\tcaretPos += m[1].length;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (data) {\n\t\t\tif (startsWith('data:', data))\n\t\t\t\treturn decodeFromBase64(editor, data, caretPos);\n\t\t\telse\n\t\t\t\treturn encodeToBase64(editor, data, caretPos);\n\t\t}\n\t\t\n\t\treturn false;\n\t}, {label: 'Encode\\\\Decode data:URL image'});\n\t\n\t/**\n\t * Test if <code>text</code> starts with <code>token</code> at <code>pos</code>\n\t * position. If <code>pos</code> is omitted, search from beginning of text \n\t * @param {String} token Token to test\n\t * @param {String} text Where to search\n\t * @param {Number} pos Position where to start search\n\t * @return {Boolean}\n\t * @since 0.65\n\t */\n\tfunction startsWith(token, text, pos) {\n\t\tpos = pos || 0;\n\t\treturn text.charAt(pos) == token.charAt(0) && text.substr(pos, token.length) == token;\n\t}\n\t\n\t/**\n\t * Encodes image to base64\n\t * \n\t * @param {IEmmetEditor} editor\n\t * @param {String} imgPath Path to image\n\t * @param {Number} pos Caret position where image is located in the editor\n\t * @return {Boolean}\n\t */\n\tfunction encodeToBase64(editor, imgPath, pos) {\n\t\tvar file = require('file');\n\t\tvar actionUtils = require('actionUtils');\n\t\t\n\t\tvar editorFile = editor.getFilePath();\n\t\tvar defaultMimeType = 'application/octet-stream';\n\t\t\t\n\t\tif (editorFile === null) {\n\t\t\tthrow \"You should save your file before using this action\";\n\t\t}\n\t\t\n\t\t// locate real image path\n\t\tvar realImgPath = file.locateFile(editorFile, imgPath);\n\t\tif (realImgPath === null) {\n\t\t\tthrow \"Can't find \" + imgPath + ' file';\n\t\t}\n\t\t\n\t\tfile.read(realImgPath, function(err, content) {\n\t\t\tif (err) {\n\t\t\t\tthrow 'Unable to read ' + realImgPath + ': ' + err;\n\t\t\t}\n\t\t\t\n\t\t\tvar b64 = require('base64').encode(String(content));\n\t\t\tif (!b64) {\n\t\t\t\tthrow \"Can't encode file content to base64\";\n\t\t\t}\n\t\t\t\n\t\t\tb64 = 'data:' + (actionUtils.mimeTypes[String(file.getExt(realImgPath))] || defaultMimeType) +\n\t\t\t\t';base64,' + b64;\n\t\t\t\t\n\t\t\teditor.replaceContent('$0' + b64, pos, pos + imgPath.length);\n\t\t});\n\t\t\n\t\t\n\t\treturn true;\n\t}\n\n\t/**\n\t * Decodes base64 string back to file.\n\t * @param {IEmmetEditor} editor\n\t * @param {String} data Base64-encoded file content\n\t * @param {Number} pos Caret position where image is located in the editor\n\t */\n\tfunction decodeFromBase64(editor, data, pos) {\n\t\t// ask user to enter path to file\n\t\tvar filePath = String(editor.prompt('Enter path to file (absolute or relative)'));\n\t\tif (!filePath)\n\t\t\treturn false;\n\t\t\t\n\t\tvar file = require('file');\n\t\tvar absPath = file.createPath(editor.getFilePath(), filePath);\n\t\tif (!absPath) {\n\t\t\tthrow \"Can't save file\";\n\t\t}\n\t\t\n\t\tfile.save(absPath, require('base64').decode( data.replace(/^data\\:.+?;.+?,/, '') ));\n\t\teditor.replaceContent('$0' + filePath, pos, pos + data.length);\n\t\treturn true;\n\t}\n});\n/**\n * Automatically updates image size attributes in HTML's &lt;img&gt; element or\n * CSS rule\n * @param {Function} require\n * @param {Underscore} _\n * @constructor\n * @memberOf __updateImageSizeAction\n */\nemmet.exec(function(require, _) {\n\t/**\n\t * Updates image size of &lt;img src=\"\"&gt; tag\n\t * @param {IEmmetEditor} editor\n\t */\n\tfunction updateImageSizeHTML(editor) {\n\t\tvar offset = editor.getCaretPos();\n\t\t\n\t\t// find tag from current caret position\n\t\tvar info = require('editorUtils').outputInfo(editor);\n\t\tvar xmlElem = require('xmlEditTree').parseFromPosition(info.content, offset, true);\n\t\tif (xmlElem && (xmlElem.name() || '').toLowerCase() == 'img') {\n\t\t\tgetImageSizeForSource(editor, xmlElem.value('src'), function(size) {\n\t\t\t\tif (size) {\n\t\t\t\t\tvar compoundData = xmlElem.range(true);\n\t\t\t\t\txmlElem.value('width', size.width);\n\t\t\t\t\txmlElem.value('height', size.height, xmlElem.indexOf('width') + 1);\n\t\t\t\t\t\n\t\t\t\t\trequire('actionUtils').compoundUpdate(editor, _.extend(compoundData, {\n\t\t\t\t\t\tdata: xmlElem.toString(),\n\t\t\t\t\t\tcaret: offset\n\t\t\t\t\t}));\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\t\n\t/**\n\t * Updates image size of CSS property\n\t * @param {IEmmetEditor} editor\n\t */\n\tfunction updateImageSizeCSS(editor) {\n\t\tvar offset = editor.getCaretPos();\n\t\t\n\t\t// find tag from current caret position\n\t\tvar info = require('editorUtils').outputInfo(editor);\n\t\tvar cssRule = require('cssEditTree').parseFromPosition(info.content, offset, true);\n\t\tif (cssRule) {\n\t\t\t// check if there is property with image under caret\n\t\t\tvar prop = cssRule.itemFromPosition(offset, true), m;\n\t\t\tif (prop && (m = /url\\(([\"']?)(.+?)\\1\\)/i.exec(prop.value() || ''))) {\n\t\t\t\tgetImageSizeForSource(editor, m[2], function(size) {\n\t\t\t\t\tif (size) {\n\t\t\t\t\t\tvar compoundData = cssRule.range(true);\n\t\t\t\t\t\tcssRule.value('width', size.width + 'px');\n\t\t\t\t\t\tcssRule.value('height', size.height + 'px', cssRule.indexOf('width') + 1);\n\t\t\t\t\t\t\n\t\t\t\t\t\trequire('actionUtils').compoundUpdate(editor, _.extend(compoundData, {\n\t\t\t\t\t\t\tdata: cssRule.toString(),\n\t\t\t\t\t\t\tcaret: offset\n\t\t\t\t\t\t}));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * Returns image dimensions for source\n\t * @param {IEmmetEditor} editor\n\t * @param {String} src Image source (path or data:url)\n\t */\n\tfunction getImageSizeForSource(editor, src, callback) {\n\t\tvar fileContent;\n\t\tvar au = require('actionUtils');\n\t\tif (src) {\n\t\t\t// check if it is data:url\n\t\t\tif (/^data:/.test(src)) {\n\t\t\t\tfileContent = require('base64').decode( src.replace(/^data\\:.+?;.+?,/, '') );\n\t\t\t\treturn callback(au.getImageSize(fileContent));\n\t\t\t}\n\t\t\t\n\t\t\tvar file = require('file');\n\t\t\tvar absPath = file.locateFile(editor.getFilePath(), src);\n\t\t\tif (absPath === null) {\n\t\t\t\tthrow \"Can't find \" + src + ' file';\n\t\t\t}\n\t\t\t\n\t\t\tfile.read(absPath, function(err, content) {\n\t\t\t\tif (err) {\n\t\t\t\t\tthrow 'Unable to read ' + absPath + ': ' + err;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcontent = String(content);\n\t\t\t\tcallback(au.getImageSize(content));\n\t\t\t});\n\t\t}\n\t}\n\t\n\trequire('actions').add('update_image_size', function(editor) {\n\t\t// this action will definitely won’t work in SASS dialect,\n\t\t// but may work in SCSS or LESS\n\t\tif (_.include(['css', 'less', 'scss'], String(editor.getSyntax()))) {\n\t\t\tupdateImageSizeCSS(editor);\n\t\t} else {\n\t\t\tupdateImageSizeHTML(editor);\n\t\t}\n\t\t\n\t\treturn true;\n\t});\n});/**\n * Resolver for fast CSS typing. Handles abbreviations with the following \n * notation:<br>\n * \n * <code>(-vendor prefix)?property(value)*(!)?</code>\n * \n * <br><br>\n * <b>Abbreviation handling</b><br>\n * \n * By default, Emmet searches for matching snippet definition for provided abbreviation.\n * If snippet wasn't found, Emmet automatically generates element with \n * abbreviation's name. For example, <code>foo</code> abbreviation will generate\n * <code>&lt;foo&gt;&lt;/foo&gt;</code> output.\n * <br><br>\n * This module will capture all expanded properties and upgrade them with values, \n * vendor prefixes and !important declarations. All unmatched abbreviations will \n * be automatically transformed into <code>property-name: ${1}</code> snippets. \n * \n * <b>Vendor prefixes<b><br>\n * \n * If CSS-property is preceded with dash, resolver should output property with\n * all <i>known</i> vendor prefixes. For example, if <code>brad</code> \n * abbreviation generates <code>border-radius: ${value};</code> snippet,\n * the <code>-brad</code> abbreviation should generate:\n * <pre><code>\n * -webkit-border-radius: ${value};\n * -moz-border-radius: ${value};\n * border-radius: ${value};\n * </code></pre>\n * Note that <i>o</i> and <i>ms</i> prefixes are omitted since Opera and IE \n * supports unprefixed property.<br><br>\n * \n * Users can also provide an explicit list of one-character prefixes for any\n * CSS property. For example, <code>-wm-float</code> will produce\n * \n * <pre><code>\n * -webkit-float: ${1};\n * -moz-float: ${1};\n * float: ${1};\n * </code></pre>\n * \n * Although this example looks pointless, users can use this feature to write\n * cutting-edge properties implemented by browser vendors recently.  \n * \n * @constructor\n * @memberOf __cssResolverDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.define('cssResolver', function(require, _) {\n\t/** Back-reference to module */\n\tvar module = null;\n\t\n\tvar prefixObj = {\n\t\t/** Real vendor prefix name */\n\t\tprefix: 'emmet',\n\t\t\n\t\t/** \n\t\t * Indicates this prefix is obsolete and should't be used when user \n\t\t * wants to generate all-prefixed properties\n\t\t */\n\t\tobsolete: false,\n\t\t\n\t\t/**\n\t\t * Returns prefixed CSS property name\n\t\t * @param {String} name Unprefixed CSS property\n\t\t */\n\t\ttransformName: function(name) {\n\t\t\treturn '-' + this.prefix + '-' + name;\n\t\t},\n\t\t\n\t\t/**\n\t\t * List of unprefixed CSS properties that supported by \n\t\t * current prefix. This list is used to generate all-prefixed property\n\t\t * @returns {Array} \n\t\t */\n\t\tproperties: function() {\n\t\t\treturn getProperties('css.' + this.prefix + 'Properties') || [];\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if given property is supported by current prefix\n\t\t * @param name\n\t\t */\n\t\tsupports: function(name) {\n\t\t\treturn _.include(this.properties(), name);\n\t\t}\n\t};\n\t\n\t\n\t/** \n\t * List of registered one-character prefixes. Key is a one-character prefix, \n\t * value is an <code>prefixObj</code> object\n\t */\n\tvar vendorPrefixes = {};\n\t\n\tvar defaultValue = '${1};';\n\t\n\t// XXX module preferences\n\tvar prefs = require('preferences');\n\tprefs.define('css.valueSeparator', ': ',\n\t\t\t'Defines a symbol that should be placed between CSS property and ' \n\t\t\t+ 'value when expanding CSS abbreviations.');\n\tprefs.define('css.propertyEnd', ';',\n\t\t\t'Defines a symbol that should be placed at the end of CSS property  ' \n\t\t\t+ 'when expanding CSS abbreviations.');\n\t\n\tprefs.define('stylus.valueSeparator', ' ',\n\t\t\t'Defines a symbol that should be placed between CSS property and ' \n\t\t\t+ 'value when expanding CSS abbreviations in Stylus dialect.');\n\tprefs.define('stylus.propertyEnd', '',\n\t\t\t'Defines a symbol that should be placed at the end of CSS property  ' \n\t\t\t+ 'when expanding CSS abbreviations in Stylus dialect.');\n\t\n\tprefs.define('sass.propertyEnd', '',\n\t\t\t'Defines a symbol that should be placed at the end of CSS property  ' \n\t\t\t+ 'when expanding CSS abbreviations in SASS dialect.');\n\t\n\tprefs.define('css.autoInsertVendorPrefixes', true,\n\t\t\t'Automatically generate vendor-prefixed copies of expanded CSS ' \n\t\t\t+ 'property. By default, Emmet will generate vendor-prefixed '\n\t\t\t+ 'properties only when you put dash before abbreviation ' \n\t\t\t+ '(e.g. <code>-bxsh</code>). With this option enabled, you don’t ' \n\t\t\t+ 'need dashes before abbreviations: Emmet will produce ' \n\t\t\t+ 'vendor-prefixed properties for you.');\n\t\n\tvar descTemplate = _.template('A comma-separated list of CSS properties that may have ' \n\t\t+ '<code><%= vendor %></code> vendor prefix. This list is used to generate '\n\t\t+ 'a list of prefixed properties when expanding <code>-property</code> '\n\t\t+ 'abbreviations. Empty list means that all possible CSS values may ' \n\t\t+ 'have <code><%= vendor %></code> prefix.');\n\t\n\tvar descAddonTemplate = _.template('A comma-separated list of <em>additional</em> CSS properties ' \n\t\t\t+ 'for <code>css.<%= vendor %>Preperties</code> preference. ' \n\t\t\t+ 'You should use this list if you want to add or remove a few CSS ' \n\t\t\t+ 'properties to original set. To add a new property, simply write its name, '\n\t\t\t+ 'to remove it, precede property with hyphen.<br>'\n\t\t\t+ 'For example, to add <em>foo</em> property and remove <em>border-radius</em> one, '\n\t\t\t+ 'the preference value will look like this: <code>foo, -border-radius</code>.');\n\t\n\t// properties list is created from cssFeatures.html file\n\tvar props = {\n\t\t'webkit': 'animation, animation-delay, animation-direction, animation-duration, animation-fill-mode, animation-iteration-count, animation-name, animation-play-state, animation-timing-function, appearance, backface-visibility, background-clip, background-composite, background-origin, background-size, border-fit, border-horizontal-spacing, border-image, border-vertical-spacing, box-align, box-direction, box-flex, box-flex-group, box-lines, box-ordinal-group, box-orient, box-pack, box-reflect, box-shadow, color-correction, column-break-after, column-break-before, column-break-inside, column-count, column-gap, column-rule-color, column-rule-style, column-rule-width, column-span, column-width, dashboard-region, font-smoothing, highlight, hyphenate-character, hyphenate-limit-after, hyphenate-limit-before, hyphens, line-box-contain, line-break, line-clamp, locale, margin-before-collapse, margin-after-collapse, marquee-direction, marquee-increment, marquee-repetition, marquee-style, mask-attachment, mask-box-image, mask-box-image-outset, mask-box-image-repeat, mask-box-image-slice, mask-box-image-source, mask-box-image-width, mask-clip, mask-composite, mask-image, mask-origin, mask-position, mask-repeat, mask-size, nbsp-mode, perspective, perspective-origin, rtl-ordering, text-combine, text-decorations-in-effect, text-emphasis-color, text-emphasis-position, text-emphasis-style, text-fill-color, text-orientation, text-security, text-stroke-color, text-stroke-width, transform, transition, transform-origin, transform-style, transition-delay, transition-duration, transition-property, transition-timing-function, user-drag, user-modify, user-select, writing-mode, svg-shadow, box-sizing, border-radius',\n\t\t'moz': 'animation-delay, animation-direction, animation-duration, animation-fill-mode, animation-iteration-count, animation-name, animation-play-state, animation-timing-function, appearance, backface-visibility, background-inline-policy, binding, border-bottom-colors, border-image, border-left-colors, border-right-colors, border-top-colors, box-align, box-direction, box-flex, box-ordinal-group, box-orient, box-pack, box-shadow, box-sizing, column-count, column-gap, column-rule-color, column-rule-style, column-rule-width, column-width, float-edge, font-feature-settings, font-language-override, force-broken-image-icon, hyphens, image-region, orient, outline-radius-bottomleft, outline-radius-bottomright, outline-radius-topleft, outline-radius-topright, perspective, perspective-origin, stack-sizing, tab-size, text-blink, text-decoration-color, text-decoration-line, text-decoration-style, text-size-adjust, transform, transform-origin, transform-style, transition, transition-delay, transition-duration, transition-property, transition-timing-function, user-focus, user-input, user-modify, user-select, window-shadow, background-clip, border-radius',\n\t\t'ms': 'accelerator, backface-visibility, background-position-x, background-position-y, behavior, block-progression, box-align, box-direction, box-flex, box-line-progression, box-lines, box-ordinal-group, box-orient, box-pack, content-zoom-boundary, content-zoom-boundary-max, content-zoom-boundary-min, content-zoom-chaining, content-zoom-snap, content-zoom-snap-points, content-zoom-snap-type, content-zooming, filter, flow-from, flow-into, font-feature-settings, grid-column, grid-column-align, grid-column-span, grid-columns, grid-layer, grid-row, grid-row-align, grid-row-span, grid-rows, high-contrast-adjust, hyphenate-limit-chars, hyphenate-limit-lines, hyphenate-limit-zone, hyphens, ime-mode, interpolation-mode, layout-flow, layout-grid, layout-grid-char, layout-grid-line, layout-grid-mode, layout-grid-type, line-break, overflow-style, perspective, perspective-origin, perspective-origin-x, perspective-origin-y, scroll-boundary, scroll-boundary-bottom, scroll-boundary-left, scroll-boundary-right, scroll-boundary-top, scroll-chaining, scroll-rails, scroll-snap-points-x, scroll-snap-points-y, scroll-snap-type, scroll-snap-x, scroll-snap-y, scrollbar-arrow-color, scrollbar-base-color, scrollbar-darkshadow-color, scrollbar-face-color, scrollbar-highlight-color, scrollbar-shadow-color, scrollbar-track-color, text-align-last, text-autospace, text-justify, text-kashida-space, text-overflow, text-size-adjust, text-underline-position, touch-action, transform, transform-origin, transform-origin-x, transform-origin-y, transform-origin-z, transform-style, transition, transition-delay, transition-duration, transition-property, transition-timing-function, user-select, word-break, word-wrap, wrap-flow, wrap-margin, wrap-through, writing-mode',\n\t\t'o': 'dashboard-region, animation, animation-delay, animation-direction, animation-duration, animation-fill-mode, animation-iteration-count, animation-name, animation-play-state, animation-timing-function, border-image, link, link-source, object-fit, object-position, tab-size, table-baseline, transform, transform-origin, transition, transition-delay, transition-duration, transition-property, transition-timing-function, accesskey, input-format, input-required, marquee-dir, marquee-loop, marquee-speed, marquee-style'\n\t};\n\t\n\t_.each(props, function(v, k) {\n\t\tprefs.define('css.' + k + 'Properties', v, descTemplate({vendor: k}));\n\t\tprefs.define('css.' + k + 'PropertiesAddon', '', descAddonTemplate({vendor: k}));\n\t});\n\t\n\tprefs.define('css.unitlessProperties', 'z-index, line-height, opacity, font-weight, zoom', \n\t\t\t'The list of properties whose values ​​must not contain units.');\n\t\n\tprefs.define('css.intUnit', 'px', 'Default unit for integer values');\n\tprefs.define('css.floatUnit', 'em', 'Default unit for float values');\n\t\n\tprefs.define('css.keywords', 'auto, inherit', \n\t\t\t'A comma-separated list of valid keywords that can be used in CSS abbreviations.');\n\t\n\tprefs.define('css.keywordAliases', 'a:auto, i:inherit, s:solid, da:dashed, do:dotted, t:transparent', \n\t\t\t'A comma-separated list of keyword aliases, used in CSS abbreviation. '\n\t\t\t+ 'Each alias should be defined as <code>alias:keyword_name</code>.');\n\t\n\tprefs.define('css.unitAliases', 'e:em, p:%, x:ex, r:rem', \n\t\t\t'A comma-separated list of unit aliases, used in CSS abbreviation. '\n\t\t\t+ 'Each alias should be defined as <code>alias:unit_value</code>.');\n\t\n\tprefs.define('css.color.short', true, \n\t\t\t'Should color values like <code>#ffffff</code> be shortened to '\n\t\t\t+ '<code>#fff</code> after abbreviation with color was expanded.');\n\t\n\tprefs.define('css.color.case', 'keep', \n\t\t\t'Letter case of color values generated by abbreviations with color '\n\t\t\t+ '(like <code>c#0</code>). Possible values are <code>upper</code>, '\n\t\t\t+ '<code>lower</code> and <code>keep</code>.');\n\t\n\tprefs.define('css.fuzzySearch', true, \n\t\t\t'Enable fuzzy search among CSS snippet names. When enabled, every ' \n\t\t\t+ '<em>unknown</em> snippet will be scored against available snippet '\n\t\t\t+ 'names (not values or CSS properties!). The match with best score '\n\t\t\t+ 'will be used to resolve snippet value. For example, with this ' \n\t\t\t+ 'preference enabled, the following abbreviations are equal: '\n\t\t\t+ '<code>ov:h</code> == <code>ov-h</code> == <code>o-h</code> == '\n\t\t\t+ '<code>oh</code>');\n\t\n\tprefs.define('css.fuzzySearchMinScore', 0.3, \n\t\t\t'The minium score (from 0 to 1) that fuzzy-matched abbreviation should ' \n\t\t\t+ 'achive. Lower values may produce many false-positive matches, '\n\t\t\t+ 'higher values may reduce possible matches.');\n\t\n\tprefs.define('css.alignVendor', false, \n\t\t\t'If set to <code>true</code>, all generated vendor-prefixed properties ' \n\t\t\t+ 'will be aligned by real property name.');\n\t\n\t\n\tfunction isNumeric(ch) {\n\t\tvar code = ch && ch.charCodeAt(0);\n\t\treturn (ch && ch == '.' || (code > 47 && code < 58));\n\t}\n\t\n\t/**\n\t * Check if provided snippet contains only one CSS property and value.\n\t * @param {String} snippet\n\t * @returns {Boolean}\n\t */\n\tfunction isSingleProperty(snippet) {\n\t\tvar utils = require('utils');\n\t\tsnippet = utils.trim(snippet);\n\t\t\n\t\t// check if it doesn't contain a comment and a newline\n\t\tif (~snippet.indexOf('/*') || /[\\n\\r]/.test(snippet)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t// check if it's a valid snippet definition\n\t\tif (!/^[a-z0-9\\-]+\\s*\\:/i.test(snippet)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tsnippet = require('tabStops').processText(snippet, {\n\t\t\treplaceCarets: true,\n\t\t\ttabstop: function() {\n\t\t\t\treturn 'value';\n\t\t\t}\n\t\t});\n\t\t\n\t\treturn snippet.split(':').length == 2;\n\t}\n\t\n\t/**\n\t * Normalizes abbreviated value to final CSS one\n\t * @param {String} value\n\t * @returns {String}\n\t */\n\tfunction normalizeValue(value) {\n\t\tif (value.charAt(0) == '-' && !/^\\-[\\.\\d]/.test(value)) {\n\t\t\tvalue = value.replace(/^\\-+/, '');\n\t\t}\n\t\t\n\t\tif (value.charAt(0) == '#') {\n\t\t\treturn normalizeHexColor(value);\n\t\t}\n\t\t\n\t\treturn getKeyword(value);\n\t}\n\t\n\tfunction normalizeHexColor(value) {\n\t\tvar hex = value.replace(/^#+/, '') || '0';\n\t\tif (hex.toLowerCase() == 't') {\n\t\t\treturn 'transparent';\n\t\t}\n\t\t\n\t\tvar repeat = require('utils').repeatString;\n\t\tvar color = null;\n\t\tswitch (hex.length) {\n\t\t\tcase 1:\n\t\t\t\tcolor = repeat(hex, 6);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tcolor = repeat(hex, 3);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tcolor = hex.charAt(0) + hex.charAt(0) + hex.charAt(1) + hex.charAt(1) + hex.charAt(2) + hex.charAt(2);\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tcolor = hex + hex.substr(0, 2);\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tcolor = hex + hex.charAt(0);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcolor = hex.substr(0, 6);\n\t\t}\n\t\t\n\t\t// color must be shortened?\n\t\tif (prefs.get('css.color.short')) {\n\t\t\tvar p = color.split('');\n\t\t\tif (p[0] == p[1] && p[2] == p[3] && p[4] == p[5]) {\n\t\t\t\tcolor = p[0] + p[2] + p[4];\n\t\t\t}\n\t\t}\n\t\t\n\t\t// should transform case?\n\t\tswitch (prefs.get('css.color.case')) {\n\t\t\tcase 'upper':\n\t\t\t\tcolor = color.toUpperCase();\n\t\t\t\tbreak;\n\t\t\tcase 'lower':\n\t\t\t\tcolor = color.toLowerCase();\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\treturn '#' + color;\n\t}\n\t\n\tfunction getKeyword(name) {\n\t\tvar aliases = prefs.getDict('css.keywordAliases');\n\t\treturn name in aliases ? aliases[name] : name;\n\t}\n\t\n\tfunction getUnit(name) {\n\t\tvar aliases = prefs.getDict('css.unitAliases');\n\t\treturn name in aliases ? aliases[name] : name;\n\t}\n\t\n\tfunction isValidKeyword(keyword) {\n\t\treturn _.include(prefs.getArray('css.keywords'), getKeyword(keyword));\n\t}\n\t\n\t/**\n\t * Check if passed CSS property support specified vendor prefix \n\t * @param {String} property\n\t * @param {String} prefix\n\t */\n\tfunction hasPrefix(property, prefix) {\n\t\tvar info = vendorPrefixes[prefix];\n\t\t\n\t\tif (!info)\n\t\t\tinfo = _.find(vendorPrefixes, function(data) {\n\t\t\t\treturn data.prefix == prefix;\n\t\t\t});\n\t\t\n\t\treturn info && info.supports(property);\n\t}\n\t\n\t/**\n\t * Search for a list of supported prefixes for CSS property. This list\n\t * is used to generate all-prefixed snippet\n\t * @param {String} property CSS property name\n\t * @returns {Array}\n\t */\n\tfunction findPrefixes(property, noAutofill) {\n\t\tvar result = [];\n\t\t_.each(vendorPrefixes, function(obj, prefix) {\n\t\t\tif (hasPrefix(property, prefix)) {\n\t\t\t\tresult.push(prefix);\n\t\t\t}\n\t\t});\n\t\t\n\t\tif (!result.length && !noAutofill) {\n\t\t\t// add all non-obsolete prefixes\n\t\t\t_.each(vendorPrefixes, function(obj, prefix) {\n\t\t\t\tif (!obj.obsolete)\n\t\t\t\t\tresult.push(prefix);\n\t\t\t});\n\t\t}\n\t\t\n\t\treturn result;\n\t}\n\t\n\tfunction addPrefix(name, obj) {\n\t\tif (_.isString(obj))\n\t\t\tobj = {prefix: obj};\n\t\t\n\t\tvendorPrefixes[name] = _.extend({}, prefixObj, obj);\n\t}\n\t\n\tfunction getSyntaxPreference(name, syntax) {\n\t\tif (syntax) {\n\t\t\tvar val = prefs.get(syntax + '.' + name);\n\t\t\tif (!_.isUndefined(val))\n\t\t\t\treturn val;\n\t\t}\n\t\t\n\t\treturn prefs.get('css.' + name);\n\t}\n\t\n\t/**\n\t * Format CSS property according to current syntax dialect\n\t * @param {String} property\n\t * @param {String} syntax\n\t * @returns {String}\n\t */\n\tfunction formatProperty(property, syntax) {\n\t\tvar ix = property.indexOf(':');\n\t\tproperty = property.substring(0, ix).replace(/\\s+$/, '') \n\t\t\t+ getSyntaxPreference('valueSeparator', syntax)\n\t\t\t+ require('utils').trim(property.substring(ix + 1));\n\t\t\n\t\treturn property.replace(/\\s*;\\s*$/, getSyntaxPreference('propertyEnd', syntax));\n\t}\n\t\n\t/**\n\t * Transforms snippet value if required. For example, this transformation\n\t * may add <i>!important</i> declaration to CSS property\n\t * @param {String} snippet\n\t * @param {Boolean} isImportant\n\t * @returns {String}\n\t */\n\tfunction transformSnippet(snippet, isImportant, syntax) {\n\t\tif (!_.isString(snippet))\n\t\t\tsnippet = snippet.data;\n\t\t\n\t\tif (!isSingleProperty(snippet))\n\t\t\treturn snippet;\n\t\t\n\t\tif (isImportant) {\n\t\t\tif (~snippet.indexOf(';')) {\n\t\t\t\tsnippet = snippet.split(';').join(' !important;');\n\t\t\t} else {\n\t\t\t\tsnippet += ' !important';\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn formatProperty(snippet, syntax);\n\t}\n\t\n\t/**\n\t * Helper function that parses comma-separated list of elements into array\n\t * @param {String} list\n\t * @returns {Array}\n\t */\n\tfunction parseList(list) {\n\t\tvar result = _.map((list || '').split(','), require('utils').trim);\n\t\treturn result.length ? result : null;\n\t}\n\t\n\tfunction getProperties(key) {\n\t\tvar list = prefs.getArray(key);\n\t\t_.each(prefs.getArray(key + 'Addon'), function(prop) {\n\t\t\tif (prop.charAt(0) == '-') {\n\t\t\t\tlist = _.without(list, prop.substr(1));\n\t\t\t} else {\n\t\t\t\tif (prop.charAt(0) == '+')\n\t\t\t\t\tprop = prop.substr(1);\n\t\t\t\t\n\t\t\t\tlist.push(prop);\n\t\t\t}\n\t\t});\n\t\t\n\t\treturn list;\n\t}\n\t\n\t\n\t// TODO refactor, this looks awkward now\n\taddPrefix('w', {\n\t\tprefix: 'webkit'\n\t});\n\taddPrefix('m', {\n\t\tprefix: 'moz'\n\t});\n\taddPrefix('s', {\n\t\tprefix: 'ms'\n\t});\n\taddPrefix('o', {\n\t\tprefix: 'o'\n\t});\n\t\n\t// I think nobody uses it\n//\taddPrefix('k', {\n//\t\tprefix: 'khtml',\n//\t\tobsolete: true\n//\t});\n\t\n\tvar cssSyntaxes = ['css', 'less', 'sass', 'scss', 'stylus'];\n\t\n\t/**\n\t * XXX register resolver\n\t * @param {TreeNode} node\n\t * @param {String} syntax\n\t */\n\trequire('resources').addResolver(function(node, syntax) {\n\t\tif (_.include(cssSyntaxes, syntax) && node.isElement()) {\n\t\t\treturn module.expandToSnippet(node.abbreviation, syntax);\n\t\t}\n\t\t\n\t\treturn null;\n\t});\n\t\n\tvar ea = require('expandAbbreviation');\n\t/**\n\t * For CSS-like syntaxes, we need to handle a special use case. Some editors\n\t * (like Sublime Text 2) may insert semicolons automatically when user types\n\t * abbreviation. After expansion, user receives a double semicolon. This\n\t * handler automatically removes semicolon from generated content in such cases.\n\t * @param {IEmmetEditor} editor\n\t * @param {String} syntax\n\t * @param {String} profile\n\t */\n\tea.addHandler(function(editor, syntax, profile) {\n\t\tif (!_.include(cssSyntaxes, syntax)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tvar caretPos = editor.getSelectionRange().end;\n\t\tvar abbr = ea.findAbbreviation(editor);\n\t\t\t\n\t\tif (abbr) {\n\t\t\tvar content = emmet.expandAbbreviation(abbr, syntax, profile);\n\t\t\tif (content) {\n\t\t\t\tvar replaceFrom = caretPos - abbr.length;\n\t\t\t\tvar replaceTo = caretPos;\n\t\t\t\tif (editor.getContent().charAt(caretPos) == ';' && content.charAt(content.length - 1) == ';') {\n\t\t\t\t\treplaceTo++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\teditor.replaceContent(content, replaceFrom, replaceTo);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t});\n\t\n\treturn module = {\n\t\t/**\n\t\t * Adds vendor prefix\n\t\t * @param {String} name One-character prefix name\n\t\t * @param {Object} obj Object describing vendor prefix\n\t\t * @memberOf cssResolver\n\t\t */\n\t\taddPrefix: addPrefix,\n\t\t\n\t\t/**\n\t\t * Check if passed CSS property supports specified vendor prefix\n\t\t * @param {String} property\n\t\t * @param {String} prefix\n\t\t */\n\t\tsupportsPrefix: hasPrefix,\n\t\t\n\t\t/**\n\t\t * Returns prefixed version of passed CSS property, only if this\n\t\t * property supports such prefix\n\t\t * @param {String} property\n\t\t * @param {String} prefix\n\t\t * @returns\n\t\t */\n\t\tprefixed: function(property, prefix) {\n\t\t\treturn hasPrefix(property, prefix) \n\t\t\t\t? '-' + prefix + '-' + property \n\t\t\t\t: property;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns list of all registered vendor prefixes\n\t\t * @returns {Array}\n\t\t */\n\t\tlistPrefixes: function() {\n\t\t\treturn _.map(vendorPrefixes, function(obj) {\n\t\t\t\treturn obj.prefix;\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns object describing vendor prefix\n\t\t * @param {String} name\n\t\t * @returns {Object}\n\t\t */\n\t\tgetPrefix: function(name) {\n\t\t\treturn vendorPrefixes[name];\n\t\t},\n\t\t\n\t\t/**\n\t\t * Removes prefix object\n\t\t * @param {String} name\n\t\t */\n\t\tremovePrefix: function(name) {\n\t\t\tif (name in vendorPrefixes)\n\t\t\t\tdelete vendorPrefixes[name];\n\t\t},\n\t\t\n\t\t/**\n\t\t * Extract vendor prefixes from abbreviation\n\t\t * @param {String} abbr\n\t\t * @returns {Object} Object containing array of prefixes and clean \n\t\t * abbreviation name\n\t\t */\n\t\textractPrefixes: function(abbr) {\n\t\t\tif (abbr.charAt(0) != '-') {\n\t\t\t\treturn {\n\t\t\t\t\tproperty: abbr,\n\t\t\t\t\tprefixes: null\n\t\t\t\t};\n\t\t\t}\n\t\t\t\n\t\t\t// abbreviation may either contain sequence of one-character prefixes\n\t\t\t// or just dash, meaning that user wants to produce all possible\n\t\t\t// prefixed properties\n\t\t\tvar i = 1, il = abbr.length, ch;\n\t\t\tvar prefixes = [];\n\t\t\t\n\t\t\twhile (i < il) {\n\t\t\t\tch = abbr.charAt(i);\n\t\t\t\tif (ch == '-') {\n\t\t\t\t\t// end-sequence character found, stop searching\n\t\t\t\t\ti++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (ch in vendorPrefixes) {\n\t\t\t\t\tprefixes.push(ch);\n\t\t\t\t} else {\n\t\t\t\t\t// no prefix found, meaning user want to produce all\n\t\t\t\t\t// vendor-prefixed properties\n\t\t\t\t\tprefixes.length = 0;\n\t\t\t\t\ti = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ti++;\n\t\t\t}\n\t\t\t\n\t\t\t// reached end of abbreviation and no property name left\n\t\t\tif (i == il -1) {\n\t\t\t\ti = 1;\n\t\t\t\tprefixes.length = 1;\n\t\t\t}\n\t\t\t\n\t\t\treturn {\n\t\t\t\tproperty: abbr.substring(i),\n\t\t\t\tprefixes: prefixes.length ? prefixes : 'all'\n\t\t\t};\n\t\t},\n\t\t\n\t\t/**\n\t\t * Search for value substring in abbreviation\n\t\t * @param {String} abbr\n\t\t * @returns {String} Value substring\n\t\t */\n\t\tfindValuesInAbbreviation: function(abbr, syntax) {\n\t\t\tsyntax = syntax || 'css';\n\t\t\t\n\t\t\tvar i = 0, il = abbr.length, value = '', ch;\n\t\t\twhile (i < il) {\n\t\t\t\tch = abbr.charAt(i);\n\t\t\t\tif (isNumeric(ch) || ch == '#' || (ch == '-' && isNumeric(abbr.charAt(i + 1)))) {\n\t\t\t\t\tvalue = abbr.substring(i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ti++;\n\t\t\t}\n\t\t\t\n\t\t\t// try to find keywords in abbreviation\n\t\t\tvar property = abbr.substring(0, abbr.length - value.length);\n\t\t\tvar res = require('resources');\n\t\t\tvar keywords = [];\n\t\t\t// try to extract some commonly-used properties\n\t\t\twhile (~property.indexOf('-') && !res.findSnippet(syntax, property)) {\n\t\t\t\tvar parts = property.split('-');\n\t\t\t\tvar lastPart = parts.pop();\n\t\t\t\tif (!isValidKeyword(lastPart)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tkeywords.unshift(lastPart);\n\t\t\t\tproperty = parts.join('-');\n\t\t\t}\n\t\t\t\n\t\t\treturn keywords.join('-') + value;\n\t\t},\n\t\t\n\t\tparseValues: function(str) {\n\t\t\t/** @type StringStream */\n\t\t\tvar stream = require('stringStream').create(str);\n\t\t\tvar values = [];\n\t\t\tvar ch = null;\n\t\t\t\n\t\t\twhile (ch = stream.next()) {\n\t\t\t\tif (ch == '#') {\n\t\t\t\t\tstream.match(/^t|[0-9a-f]+/i, true);\n\t\t\t\t\tvalues.push(stream.current());\n\t\t\t\t} else if (ch == '-') {\n\t\t\t\t\tif (isValidKeyword(_.last(values)) || \n\t\t\t\t\t\t\t( stream.start && isNumeric(str.charAt(stream.start - 1)) )\n\t\t\t\t\t\t) {\n\t\t\t\t\t\tstream.start = stream.pos;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tstream.match(/^\\-?[0-9]*(\\.[0-9]+)?[a-z%\\.]*/, true);\n\t\t\t\t\tvalues.push(stream.current());\n\t\t\t\t} else {\n\t\t\t\t\tstream.match(/^[0-9]*(\\.[0-9]*)?[a-z%]*/, true);\n\t\t\t\t\tvalues.push(stream.current());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tstream.start = stream.pos;\n\t\t\t}\n\t\t\t\n\t\t\treturn _.map(_.compact(values), normalizeValue);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Extracts values from abbreviation\n\t\t * @param {String} abbr\n\t\t * @returns {Object} Object containing array of values and clean \n\t\t * abbreviation name\n\t\t */\n\t\textractValues: function(abbr) {\n\t\t\t// search for value start\n\t\t\tvar abbrValues = this.findValuesInAbbreviation(abbr);\n\t\t\tif (!abbrValues) {\n\t\t\t\treturn {\n\t\t\t\t\tproperty: abbr,\n\t\t\t\t\tvalues: null\n\t\t\t\t};\n\t\t\t}\n\t\t\t\n\t\t\treturn {\n\t\t\t\tproperty: abbr.substring(0, abbr.length - abbrValues.length).replace(/-$/, ''),\n\t\t\t\tvalues: this.parseValues(abbrValues)\n\t\t\t};\n\t\t},\n\t\t\n\t\t/**\n\t\t * Normalizes value, defined in abbreviation.\n\t\t * @param {String} value\n\t\t * @param {String} property\n\t\t * @returns {String}\n\t\t */\n\t\tnormalizeValue: function(value, property) {\n\t\t\tproperty = (property || '').toLowerCase();\n\t\t\tvar unitlessProps = prefs.getArray('css.unitlessProperties');\n\t\t\treturn value.replace(/^(\\-?[0-9\\.]+)([a-z]*)$/, function(str, val, unit) {\n\t\t\t\tif (!unit && (val == '0' || _.include(unitlessProps, property)))\n\t\t\t\t\treturn val;\n\t\t\t\t\n\t\t\t\tif (!unit)\n\t\t\t\t\treturn val.replace(/\\.$/, '') + prefs.get(~val.indexOf('.') ? 'css.floatUnit' : 'css.intUnit');\n\t\t\t\t\n\t\t\t\treturn val + getUnit(unit);\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Expands abbreviation into a snippet\n\t\t * @param {String} abbr Abbreviation name to expand\n\t\t * @param {String} value Abbreviation value\n\t\t * @param {String} syntax Currect syntax or dialect. Default is 'css'\n\t\t * @returns {Object} Array of CSS properties and values or predefined\n\t\t * snippet (string or element)\n\t\t */\n\t\texpand: function(abbr, value, syntax) {\n\t\t\tsyntax = syntax || 'css';\n\t\t\tvar resources = require('resources');\n\t\t\tvar autoInsertPrefixes = prefs.get('css.autoInsertVendorPrefixes');\n\t\t\t\n\t\t\t// check if snippet should be transformed to !important\n\t\t\tvar isImportant;\n\t\t\tif (isImportant = /^(.+)\\!$/.test(abbr)) {\n\t\t\t\tabbr = RegExp.$1;\n\t\t\t}\n\t\t\t\n\t\t\t// check if we have abbreviated resource\n\t\t\tvar snippet = resources.findSnippet(syntax, abbr);\n\t\t\tif (snippet && !autoInsertPrefixes) {\n\t\t\t\treturn transformSnippet(snippet, isImportant, syntax);\n\t\t\t}\n\t\t\t\n\t\t\t// no abbreviated resource, parse abbreviation\n\t\t\tvar prefixData = this.extractPrefixes(abbr);\n\t\t\tvar valuesData = this.extractValues(prefixData.property);\n\t\t\tvar abbrData = _.extend(prefixData, valuesData);\n\t\t\t\n\t\t\tif (!snippet) {\n\t\t\t\tsnippet = resources.findSnippet(syntax, abbrData.property);\n\t\t\t} else {\n\t\t\t\tabbrData.values = null;\n\t\t\t}\n\t\t\t\n\t\t\tif (!snippet && prefs.get('css.fuzzySearch')) {\n\t\t\t\t// let’s try fuzzy search\n\t\t\t\tsnippet = resources.fuzzyFindSnippet(syntax, abbrData.property, parseFloat(prefs.get('css.fuzzySearchMinScore')));\n\t\t\t}\n\t\t\t\n\t\t\tif (!snippet) {\n\t\t\t\tsnippet = abbrData.property + ':' + defaultValue;\n\t\t\t} else if (!_.isString(snippet)) {\n\t\t\t\tsnippet = snippet.data;\n\t\t\t}\n\t\t\t\n\t\t\tif (!isSingleProperty(snippet)) {\n\t\t\t\treturn snippet;\n\t\t\t}\n\t\t\t\n\t\t\tvar snippetObj = this.splitSnippet(snippet);\n\t\t\tvar result = [];\n\t\t\tif (!value && abbrData.values) {\n\t\t\t\tvalue = _.map(abbrData.values, function(val) {\n\t\t\t\t\treturn this.normalizeValue(val, snippetObj.name);\n\t\t\t\t}, this).join(' ') + ';';\n\t\t\t}\n\t\t\t\n\t\t\tsnippetObj.value = value || snippetObj.value;\n\t\t\t\n\t\t\tvar prefixes = abbrData.prefixes == 'all' || (!abbrData.prefixes && autoInsertPrefixes) \n\t\t\t\t? findPrefixes(snippetObj.name, autoInsertPrefixes && abbrData.prefixes != 'all')\n\t\t\t\t: abbrData.prefixes;\n\t\t\t\t\n\t\t\t\t\n\t\t\tvar names = [], propName;\n\t\t\t_.each(prefixes, function(p) {\n\t\t\t\tif (p in vendorPrefixes) {\n\t\t\t\t\tpropName = vendorPrefixes[p].transformName(snippetObj.name);\n\t\t\t\t\tnames.push(propName);\n\t\t\t\t\tresult.push(transformSnippet(propName + ':' + snippetObj.value,\n\t\t\t\t\t\t\tisImportant, syntax));\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\t// put the original property\n\t\t\tresult.push(transformSnippet(snippetObj.name + ':' + snippetObj.value, isImportant, syntax));\n\t\t\tnames.push(snippetObj.name);\n\t\t\t\n\t\t\tif (prefs.get('css.alignVendor')) {\n\t\t\t\tvar pads = require('utils').getStringsPads(names);\n\t\t\t\tresult = _.map(result, function(prop, i) {\n\t\t\t\t\treturn pads[i] + prop;\n\t\t\t\t});\n\t\t\t}\n\t\t\t\n\t\t\treturn result;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Same as <code>expand</code> method but transforms output into \n\t\t * Emmet snippet\n\t\t * @param {String} abbr\n\t\t * @param {String} syntax\n\t\t * @returns {String}\n\t\t */\n\t\texpandToSnippet: function(abbr, syntax) {\n\t\t\tvar snippet = this.expand(abbr, null, syntax);\n\t\t\tif (_.isArray(snippet)) {\n\t\t\t\treturn snippet.join('\\n');\n\t\t\t}\n\t\t\t\n\t\t\tif (!_.isString(snippet))\n\t\t\t\treturn snippet.data;\n\t\t\t\n\t\t\treturn String(snippet);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Split snippet into a CSS property-value pair\n\t\t * @param {String} snippet\n\t\t */\n\t\tsplitSnippet: function(snippet) {\n\t\t\tvar utils = require('utils');\n\t\t\tsnippet = utils.trim(snippet);\n\t\t\tif (snippet.indexOf(':') == -1) {\n\t\t\t\treturn {\n\t\t\t\t\tname: snippet,\n\t\t\t\t\tvalue: defaultValue\n\t\t\t\t};\n\t\t\t}\n\t\t\t\n\t\t\tvar pair = snippet.split(':');\n\t\t\t\n\t\t\treturn {\n\t\t\t\tname: utils.trim(pair.shift()),\n\t\t\t\t// replace ${0} tabstop to produce valid vendor-prefixed values\n\t\t\t\t// where possible\n\t\t\t\tvalue: utils.trim(pair.join(':')).replace(/^(\\$\\{0\\}|\\$0)(\\s*;?)$/, '${1}$2')\n\t\t\t};\n\t\t},\n\t\t\n\t\tgetSyntaxPreference: getSyntaxPreference,\n\t\ttransformSnippet: transformSnippet\n\t};\n});\n/**\n * 'Expand Abbreviation' handler that parses gradient definition from under \n * cursor and updates CSS rule with vendor-prefixed values.\n * \n * @memberOf __cssGradientHandlerDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.define('cssGradient', function(require, _) {\n\tvar defaultLinearDirections = ['top', 'to bottom', '0deg'];\n\t/** Back-reference to current module */\n\tvar module = null;\n\t\n\tvar cssSyntaxes = ['css', 'less', 'sass', 'scss', 'stylus', 'styl'];\n\t\n\tvar reDeg = /\\d+deg/i;\n\tvar reKeyword = /top|bottom|left|right/i;\n\t\n\t// XXX define preferences\n\t/** @type preferences */\n\tvar prefs = require('preferences');\n\tprefs.define('css.gradient.prefixes', 'webkit, moz, o',\n\t\t\t'A comma-separated list of vendor-prefixes for which values should ' \n\t\t\t+ 'be generated.');\n\t\n\tprefs.define('css.gradient.oldWebkit', true,\n\t\t\t'Generate gradient definition for old Webkit implementations');\n\t\n\tprefs.define('css.gradient.omitDefaultDirection', true,\n\t\t'Do not output default direction definition in generated gradients.');\n\t\n\tprefs.define('css.gradient.defaultProperty', 'background-image',\n\t\t'When gradient expanded outside CSS value context, it will produce '\n\t\t\t+ 'properties with this name.');\n\t\n\tprefs.define('css.gradient.fallback', false,\n\t\t\t'With this option enabled, CSS gradient generator will produce '\n\t\t\t+ '<code>background-color</code> property with gradient first color '\n\t\t\t+ 'as fallback for old browsers.');\n\t\n\tfunction normalizeSpace(str) {\n\t\treturn require('utils').trim(str).replace(/\\s+/g, ' ');\n\t}\n\t\n\t/**\n\t * Parses linear gradient definition\n\t * @param {String}\n\t */\n\tfunction parseLinearGradient(gradient) {\n\t\tvar direction = defaultLinearDirections[0];\n\t\t\n\t\t// extract tokens\n\t\t/** @type StringStream */\n\t\tvar stream = require('stringStream').create(require('utils').trim(gradient));\n\t\tvar colorStops = [], ch;\n\t\twhile (ch = stream.next()) {\n\t\t\tif (stream.peek() == ',') {\n\t\t\t\tcolorStops.push(stream.current());\n\t\t\t\tstream.next();\n\t\t\t\tstream.eatSpace();\n\t\t\t\tstream.start = stream.pos;\n\t\t\t} else if (ch == '(') { // color definition, like 'rgb(0,0,0)'\n\t\t\t\tstream.skipTo(')');\n\t\t\t}\n\t\t}\n\t\t\n\t\t// add last token\n\t\tcolorStops.push(stream.current());\n\t\tcolorStops = _.compact(_.map(colorStops, normalizeSpace));\n\t\t\n\t\tif (!colorStops.length)\n\t\t\treturn null;\n\t\t\n\t\t// let's see if the first color stop is actually a direction\n\t\tif (reDeg.test(colorStops[0]) || reKeyword.test(colorStops[0])) {\n\t\t\tdirection = colorStops.shift();\n\t\t}\n\t\t\n\t\treturn {\n\t\t\ttype: 'linear',\n\t\t\tdirection: direction,\n\t\t\tcolorStops: _.map(colorStops, parseColorStop)\n\t\t};\n\t}\n\t\n\t/**\n\t * Parses color stop definition\n\t * @param {String} colorStop\n\t * @returns {Object}\n\t */\n\tfunction parseColorStop(colorStop) {\n\t\tcolorStop = normalizeSpace(colorStop);\n\t\t\n\t\t// find color declaration\n\t\t// first, try complex color declaration, like rgb(0,0,0)\n\t\tvar color = null;\n\t\tcolorStop = colorStop.replace(/^(\\w+\\(.+?\\))\\s*/, function(str, c) {\n\t\t\tcolor = c;\n\t\t\treturn '';\n\t\t});\n\t\t\n\t\tif (!color) {\n\t\t\t// try simple declaration, like yellow, #fco, #ffffff, etc.\n\t\t\tvar parts = colorStop.split(' ');\n\t\t\tcolor = parts[0];\n\t\t\tcolorStop = parts[1] || '';\n\t\t}\n\t\t\n\t\tvar result = {\n\t\t\tcolor: color\n\t\t};\n\t\t\n\t\tif (colorStop) {\n\t\t\t// there's position in color stop definition\n\t\t\tcolorStop.replace(/^(\\-?[\\d\\.]+)([a-z%]+)?$/, function(str, pos, unit) {\n\t\t\t\tresult.position = pos;\n\t\t\t\tif (~pos.indexOf('.')) {\n\t\t\t\t\tunit = '';\n\t\t\t\t} else if (!unit) {\n\t\t\t\t\tunit = '%';\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (unit)\n\t\t\t\t\tresult.unit = unit;\n\t\t\t});\n\t\t}\n\t\t\n\t\treturn result;\n\t}\n\t\n\t/**\n\t * Resolves property name (abbreviation): searches for snippet definition in \n\t * 'resources' and returns new name of matched property\n\t */\n\tfunction resolvePropertyName(name, syntax) {\n\t\tvar res = require('resources');\n\t\tvar prefs = require('preferences');\n\t\tvar snippet = res.findSnippet(syntax, name);\n\t\t\n\t\tif (!snippet && prefs.get('css.fuzzySearch')) {\n\t\t\tsnippet = res.fuzzyFindSnippet(syntax, name, \n\t\t\t\t\tparseFloat(prefs.get('css.fuzzySearchMinScore')));\n\t\t}\n\t\t\n\t\tif (snippet) {\n\t\t\tif (!_.isString(snippet)) {\n\t\t\t\tsnippet = snippet.data;\n\t\t\t}\n\t\t\t\n\t\t\treturn require('cssResolver').splitSnippet(snippet).name;\n\t\t}\n\t}\n\t\n\t/**\n\t * Fills-out implied positions in color-stops. This function is useful for\n\t * old Webkit gradient definitions\n\t */\n\tfunction fillImpliedPositions(colorStops) {\n\t\tvar from = 0;\n\t\t\n\t\t_.each(colorStops, function(cs, i) {\n\t\t\t// make sure that first and last positions are defined\n\t\t\tif (!i)\n\t\t\t\treturn cs.position = cs.position || 0;\n\t\t\t\n\t\t\tif (i == colorStops.length - 1 && !('position' in cs))\n\t\t\t\tcs.position = 1;\n\t\t\t\n\t\t\tif ('position' in cs) {\n\t\t\t\tvar start = colorStops[from].position || 0;\n\t\t\t\tvar step = (cs.position - start) / (i - from);\n\t\t\t\t_.each(colorStops.slice(from, i), function(cs2, j) {\n\t\t\t\t\tcs2.position = start + step * j;\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tfrom = i;\n\t\t\t}\n\t\t});\n\t}\n\t\n\t/**\n\t * Returns textual version of direction expressed in degrees\n\t * @param {String} direction\n\t * @returns {String}\n\t */\n\tfunction textualDirection(direction) {\n\t\tvar angle = parseFloat(direction);\n\t\t\n\t\tif(!_.isNaN(angle)) {\n\t\t\tswitch(angle % 360) {\n\t\t\t\tcase 0:   return 'left';\n\t\t\t\tcase 90:  return 'bottom';\n\t\t\t\tcase 180: return 'right';\n\t\t\t\tcase 240: return 'top';\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn direction;\n\t}\n\t\n\t/**\n\t * Creates direction definition for old Webkit gradients\n\t * @param {String} direction\n\t * @returns {String}\n\t */\n\tfunction oldWebkitDirection(direction) {\n\t\tdirection = textualDirection(direction);\n\t\t\n\t\tif(reDeg.test(direction))\n\t\t\tthrow \"The direction is an angle that can’t be converted.\";\n\t\t\n\t\tvar v = function(pos) {\n\t\t\treturn ~direction.indexOf(pos) ? '100%' : '0';\n\t\t};\n\t\t\n\t\treturn v('right') + ' ' + v('bottom') + ', ' + v('left') + ' ' + v('top');\n\t}\n\t\n\tfunction getPrefixedNames(name) {\n\t\tvar prefixes = prefs.getArray('css.gradient.prefixes');\n\t\tvar names = prefixes \n\t\t\t? _.map(prefixes, function(p) {\n\t\t\t\treturn '-' + p + '-' + name;\n\t\t\t}) \n\t\t\t: [];\n\t\t\n\t\tnames.push(name);\n\t\t\n\t\treturn names;\n\t}\n\t\n\t/**\n\t * Returns list of CSS properties with gradient\n\t * @param {Object} gradient\n\t * @param {String} propertyName Original CSS property name\n\t * @returns {Array}\n\t */\n\tfunction getPropertiesForGradient(gradient, propertyName) {\n\t\tvar props = [];\n\t\tvar css = require('cssResolver');\n\t\t\n\t\tif (prefs.get('css.gradient.fallback') && ~propertyName.toLowerCase().indexOf('background')) {\n\t\t\tprops.push({\n\t\t\t\tname: 'background-color',\n\t\t\t\tvalue: '${1:' + gradient.colorStops[0].color + '}'\n\t\t\t});\n\t\t}\n\t\t\n\t\t_.each(prefs.getArray('css.gradient.prefixes'), function(prefix) {\n\t\t\tvar name = css.prefixed(propertyName, prefix);\n\t\t\tif (prefix == 'webkit' && prefs.get('css.gradient.oldWebkit')) {\n\t\t\t\ttry {\n\t\t\t\t\tprops.push({\n\t\t\t\t\t\tname: name,\n\t\t\t\t\t\tvalue: module.oldWebkitLinearGradient(gradient)\n\t\t\t\t\t});\n\t\t\t\t} catch(e) {}\n\t\t\t}\n\t\t\t\n\t\t\tprops.push({\n\t\t\t\tname: name,\n\t\t\t\tvalue: module.toString(gradient, prefix)\n\t\t\t});\n\t\t});\n\t\t\n\t\treturn props.sort(function(a, b) {\n\t\t\treturn b.name.length - a.name.length;\n\t\t});\n\t}\n\t\n\t/**\n\t * Pastes gradient definition into CSS rule with correct vendor-prefixes\n\t * @param {EditElement} property Matched CSS property\n\t * @param {Object} gradient Parsed gradient\n\t * @param {Range} valueRange If passed, only this range within property \n\t * value will be replaced with gradient. Otherwise, full value will be \n\t * replaced\n\t */\n\tfunction pasteGradient(property, gradient, valueRange) {\n\t\tvar rule = property.parent;\n\t\tvar utils = require('utils');\n\t\tvar alignVendor = require('preferences').get('css.alignVendor');\n\t\t\n\t\t// we may have aligned gradient definitions: find the smallest value\n\t\t// separator\n\t\tvar sep = property.styleSeparator;\n\t\tvar before = property.styleBefore;\n\t\t\n\t\t// first, remove all properties within CSS rule with the same name and\n\t\t// gradient definition\n\t\t_.each(rule.getAll(getPrefixedNames(property.name())), function(item) {\n\t\t\tif (item != property && /gradient/i.test(item.value())) {\n\t\t\t\tif (item.styleSeparator.length < sep.length) {\n\t\t\t\t\tsep = item.styleSeparator;\n\t\t\t\t}\n\t\t\t\tif (item.styleBefore.length < before.length) {\n\t\t\t\t\tbefore = item.styleBefore;\n\t\t\t\t}\n\t\t\t\trule.remove(item);\n\t\t\t}\n\t\t});\n\t\t\n\t\tif (alignVendor) {\n\t\t\t// update prefix\n\t\t\tif (before != property.styleBefore) {\n\t\t\t\tvar fullRange = property.fullRange();\n\t\t\t\trule._updateSource(before, fullRange.start, fullRange.start + property.styleBefore.length);\n\t\t\t\tproperty.styleBefore = before;\n\t\t\t}\n\t\t\t\n\t\t\t// update separator value\n\t\t\tif (sep != property.styleSeparator) {\n\t\t\t\trule._updateSource(sep, property.nameRange().end, property.valueRange().start);\n\t\t\t\tproperty.styleSeparator = sep;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar value = property.value();\n\t\tif (!valueRange)\n\t\t\tvalueRange = require('range').create(0, property.value());\n\t\t\n\t\tvar val = function(v) {\n\t\t\treturn utils.replaceSubstring(value, v, valueRange);\n\t\t};\n\t\t\n\t\t// put vanilla-clean gradient definition into current rule\n\t\tproperty.value(val(module.toString(gradient)) + '${2}');\n\t\t\n\t\t// create list of properties to insert\n\t\tvar propsToInsert = getPropertiesForGradient(gradient, property.name());\n\t\t\n\t\t// align prefixed values\n\t\tif (alignVendor) {\n\t\t\tvar values = _.pluck(propsToInsert, 'value');\n\t\t\tvar names = _.pluck(propsToInsert, 'name');\n\t\t\tvalues.push(property.value());\n\t\t\tnames.push(property.name());\n\t\t\t\n\t\t\tvar valuePads = utils.getStringsPads(_.map(values, function(v) {\n\t\t\t\treturn v.substring(0, v.indexOf('('));\n\t\t\t}));\n\t\t\t\n\t\t\tvar namePads = utils.getStringsPads(names);\n\t\t\tproperty.name(_.last(namePads) + property.name());\n\t\t\t\n\t\t\t_.each(propsToInsert, function(prop, i) {\n\t\t\t\tprop.name = namePads[i] + prop.name;\n\t\t\t\tprop.value = valuePads[i] + prop.value;\n\t\t\t});\n\t\t\t\n\t\t\tproperty.value(_.last(valuePads) + property.value());\n\t\t}\n\t\t\n\t\t// put vendor-prefixed definitions before current rule\n\t\t_.each(propsToInsert, function(prop) {\n\t\t\trule.add(prop.name, prop.value, rule.indexOf(property));\n\t\t});\n\t}\n\t\n\t/**\n\t * Search for gradient definition inside CSS property value\n\t */\n\tfunction findGradient(cssProp) {\n\t\tvar value = cssProp.value();\n\t\tvar gradient = null;\n\t\tvar matchedPart = _.find(cssProp.valueParts(), function(part) {\n\t\t\treturn gradient = module.parse(part.substring(value));\n\t\t});\n\t\t\n\t\tif (matchedPart && gradient) {\n\t\t\treturn {\n\t\t\t\tgradient: gradient,\n\t\t\t\tvalueRange: matchedPart\n\t\t\t};\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\t\n\t/**\n\t * Tries to expand gradient outside CSS value \n\t * @param {IEmmetEditor} editor\n\t * @param {String} syntax\n\t */\n\tfunction expandGradientOutsideValue(editor, syntax) {\n\t\tvar propertyName = prefs.get('css.gradient.defaultProperty');\n\t\t\n\t\tif (!propertyName)\n\t\t\treturn false;\n\t\t\n\t\t// assuming that gradient definition is written on new line,\n\t\t// do a simplified parsing\n\t\tvar content = String(editor.getContent());\n\t\t/** @type Range */\n\t\tvar lineRange = require('range').create(editor.getCurrentLineRange());\n\t\t\n\t\t// get line content and adjust range with padding\n\t\tvar line = lineRange.substring(content)\n\t\t\t.replace(/^\\s+/, function(pad) {\n\t\t\t\tlineRange.start += pad.length;\n\t\t\t\treturn '';\n\t\t\t})\n\t\t\t.replace(/\\s+$/, function(pad) {\n\t\t\t\tlineRange.end -= pad.length;\n\t\t\t\treturn '';\n\t\t\t});\n\t\t\n\t\tvar css = require('cssResolver');\n\t\tvar gradient = module.parse(line);\n\t\tif (gradient) {\n\t\t\tvar props = getPropertiesForGradient(gradient, propertyName);\n\t\t\tprops.push({\n\t\t\t\tname: propertyName,\n\t\t\t\tvalue: module.toString(gradient) + '${2}'\n\t\t\t});\n\t\t\t\n\t\t\tvar sep = css.getSyntaxPreference('valueSeparator', syntax);\n\t\t\tvar end = css.getSyntaxPreference('propertyEnd', syntax);\n\t\t\t\n\t\t\tif (require('preferences').get('css.alignVendor')) {\n\t\t\t\tvar pads = require('utils').getStringsPads(_.map(props, function(prop) {\n\t\t\t\t\treturn prop.value.substring(0, prop.value.indexOf('('));\n\t\t\t\t}));\n\t\t\t\t_.each(props, function(prop, i) {\n\t\t\t\t\tprop.value = pads[i] + prop.value;\n\t\t\t\t});\n\t\t\t}\n\t\t\t\n\t\t\tprops = _.map(props, function(item) {\n\t\t\t\treturn item.name + sep + item.value + end;\n\t\t\t});\n\t\t\t\n\t\t\teditor.replaceContent(props.join('\\n'), lineRange.start, lineRange.end);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * Search for gradient definition inside CSS value under cursor\n\t * @param {String} content\n\t * @param {Number} pos\n\t * @returns {Object}\n\t */\n\tfunction findGradientFromPosition(content, pos) {\n\t\tvar cssProp = null;\n\t\t/** @type EditContainer */\n\t\tvar cssRule = require('cssEditTree').parseFromPosition(content, pos, true);\n\t\t\n\t\tif (cssRule) {\n\t\t\tcssProp = cssRule.itemFromPosition(pos, true);\n\t\t\tif (!cssProp) {\n\t\t\t\t// in case user just started writing CSS property\n\t\t\t\t// and didn't include semicolon–try another approach\n\t\t\t\tcssProp = _.find(cssRule.list(), function(elem) {\n\t\t\t\t\treturn elem.range(true).end == pos;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn {\n\t\t\trule: cssRule,\n\t\t\tproperty: cssProp\n\t\t};\n\t}\n\t\n\t// XXX register expand abbreviation handler\n\t/**\n\t * @param {IEmmetEditor} editor\n\t * @param {String} syntax\n\t * @param {String} profile\n\t */\n\trequire('expandAbbreviation').addHandler(function(editor, syntax, profile) {\n\t\tvar info = require('editorUtils').outputInfo(editor, syntax, profile);\n\t\tif (!_.include(cssSyntaxes, info.syntax))\n\t\t\treturn false;\n\t\t\n\t\t// let's see if we are expanding gradient definition\n\t\tvar caret = editor.getCaretPos();\n\t\tvar content = info.content;\n\t\tvar css = findGradientFromPosition(content, caret);\n\t\t\n\t\tif (css.property) {\n\t\t\t// make sure that caret is inside property value with gradient \n\t\t\t// definition\n\t\t\tvar g = findGradient(css.property);\n\t\t\tif (g) {\n\t\t\t\tvar ruleStart = css.rule.options.offset || 0;\n\t\t\t\tvar ruleEnd = ruleStart + css.rule.toString().length;\n\t\t\t\t\n\t\t\t\t// Handle special case:\n\t\t\t\t// user wrote gradient definition between existing CSS \n\t\t\t\t// properties and did not finished it with semicolon.\n\t\t\t\t// In this case, we have semicolon right after gradient \n\t\t\t\t// definition and re-parse rule again\n\t\t\t\tif (/[\\n\\r]/.test(css.property.value())) {\n\t\t\t\t\t// insert semicolon at the end of gradient definition\n\t\t\t\t\tvar insertPos = css.property.valueRange(true).start + g.valueRange.end;\n\t\t\t\t\tcontent = require('utils').replaceSubstring(content, ';', insertPos);\n\t\t\t\t\tvar newCss = findGradientFromPosition(content, caret);\n\t\t\t\t\tif (newCss.property) {\n\t\t\t\t\t\tg = findGradient(newCss.property);\n\t\t\t\t\t\tcss = newCss;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// make sure current property has terminating semicolon\n\t\t\t\tcss.property.end(';');\n\t\t\t\t\n\t\t\t\t// resolve CSS property name\n\t\t\t\tvar resolvedName = resolvePropertyName(css.property.name(), syntax);\n\t\t\t\tif (resolvedName) {\n\t\t\t\t\tcss.property.name(resolvedName);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpasteGradient(css.property, g.gradient, g.valueRange);\n\t\t\t\teditor.replaceContent(css.rule.toString(), ruleStart, ruleEnd, true);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn expandGradientOutsideValue(editor, syntax);\n\t});\n\t\n\t// XXX register \"Reflect CSS Value\" action delegate\n\t/**\n\t * @param {EditElement} property\n\t */\n\trequire('reflectCSSValue').addHandler(function(property) {\n\t\tvar utils = require('utils');\n\t\t\n\t\tvar g = findGradient(property);\n\t\tif (!g)\n\t\t\treturn false;\n\t\t\n\t\tvar value = property.value();\n\t\tvar val = function(v) {\n\t\t\treturn utils.replaceSubstring(value, v, g.valueRange);\n\t\t};\n\t\t\n\t\t// reflect value for properties with the same name\n\t\t_.each(property.parent.getAll(getPrefixedNames(property.name())), function(prop) {\n\t\t\tif (prop === property)\n\t\t\t\treturn;\n\t\t\t\n\t\t\t// check if property value starts with gradient definition\n\t\t\tvar m = prop.value().match(/^\\s*(\\-([a-z]+)\\-)?linear\\-gradient/);\n\t\t\tif (m) {\n\t\t\t\tprop.value(val(module.toString(g.gradient, m[2] || '')));\n\t\t\t} else if (m = prop.value().match(/\\s*\\-webkit\\-gradient/)) {\n\t\t\t\t// old webkit gradient definition\n\t\t\t\tprop.value(val(module.oldWebkitLinearGradient(g.gradient)));\n\t\t\t}\n\t\t});\n\t\t\n\t\treturn true;\n\t});\n\t\n\treturn module = {\n\t\t/**\n\t\t * Parses gradient definition\n\t\t * @param {String} gradient\n\t\t * @returns {Object}\n\t\t */\n\t\tparse: function(gradient) {\n\t\t\tvar result = null;\n\t\t\trequire('utils').trim(gradient).replace(/^([\\w\\-]+)\\((.+?)\\)$/, function(str, type, definition) {\n\t\t\t\t// remove vendor prefix\n\t\t\t\ttype = type.toLowerCase().replace(/^\\-[a-z]+\\-/, '');\n\t\t\t\tif (type == 'linear-gradient' || type == 'lg') {\n\t\t\t\t\tresult = parseLinearGradient(definition);\n\t\t\t\t\treturn '';\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn str;\n\t\t\t});\n\t\t\t\n\t\t\treturn result;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Produces linear gradient definition used in early Webkit \n\t\t * implementations\n\t\t * @param {Object} gradient Parsed gradient\n\t\t * @returns {String}\n\t\t */\n\t\toldWebkitLinearGradient: function(gradient) {\n\t\t\tif (_.isString(gradient))\n\t\t\t\tgradient = this.parse(gradient);\n\t\t\t\n\t\t\tif (!gradient)\n\t\t\t\treturn null;\n\t\t\t\n\t\t\tvar colorStops = _.map(gradient.colorStops, _.clone);\n\t\t\t\n\t\t\t// normalize color-stops position\n\t\t\t_.each(colorStops, function(cs) {\n\t\t\t\tif (!('position' in cs)) // implied position\n\t\t\t\t\treturn;\n\t\t\t\t\n\t\t\t\tif (~cs.position.indexOf('.') || cs.unit == '%') {\n\t\t\t\t\tcs.position = parseFloat(cs.position) / (cs.unit == '%' ? 100 : 1);\n\t\t\t\t} else {\n\t\t\t\t\tthrow \"Can't convert color stop '\" + (cs.position + (cs.unit || '')) + \"'\";\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\tfillImpliedPositions(colorStops);\n\t\t\t\n\t\t\t// transform color-stops into string representation\n\t\t\tcolorStops = _.map(colorStops, function(cs, i) {\n\t\t\t\tif (!cs.position && !i)\n\t\t\t\t\treturn 'from(' + cs.color + ')';\n\t\t\t\t\n\t\t\t\tif (cs.position == 1 && i == colorStops.length - 1)\n\t\t\t\t\treturn 'to(' + cs.color + ')';\n\t\t\t\t\n\t\t\t\treturn 'color-stop(' + (cs.position.toFixed(2).replace(/\\.?0+$/, '')) + ', ' + cs.color + ')';\n\t\t\t});\n\t\t\t\n\t\t\treturn '-webkit-gradient(linear, ' \n\t\t\t\t+ oldWebkitDirection(gradient.direction)\n\t\t\t\t+ ', '\n\t\t\t\t+ colorStops.join(', ')\n\t\t\t\t+ ')';\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns string representation of parsed gradient\n\t\t * @param {Object} gradient Parsed gradient\n\t\t * @param {String} prefix Vendor prefix\n\t\t * @returns {String}\n\t\t */\n\t\ttoString: function(gradient, prefix) {\n\t\t\tif (gradient.type == 'linear') {\n\t\t\t\tvar fn = (prefix ? '-' + prefix + '-' : '') + 'linear-gradient';\n\t\t\t\t\n\t\t\t\t// transform color-stops\n\t\t\t\tvar colorStops = _.map(gradient.colorStops, function(cs) {\n\t\t\t\t\treturn cs.color + ('position' in cs \n\t\t\t\t\t\t\t? ' ' + cs.position + (cs.unit || '')\n\t\t\t\t\t\t\t: '');\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tif (gradient.direction \n\t\t\t\t\t\t&& (!prefs.get('css.gradient.omitDefaultDirection') \n\t\t\t\t\t\t|| !_.include(defaultLinearDirections, gradient.direction))) {\n\t\t\t\t\tcolorStops.unshift(gradient.direction);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn fn + '(' + colorStops.join(', ') + ')';\n\t\t\t}\n\t\t}\n\t};\n});/**\n * Module adds support for generators: a regexp-based abbreviation resolver \n * that can produce custom output.\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\t/** @type HandlerList */\n\tvar generators = require('handlerList').create();\n\tvar resources = require('resources');\n\t\n\t_.extend(resources, {\n\t\t/**\n\t\t * Add generator. A generator function <code>fn</code> will be called \n\t\t * only if current abbreviation matches <code>regexp</code> regular \n\t\t * expression and this function should return <code>null</code> if\n\t\t * abbreviation cannot be resolved\n\t\t * @param {RegExp} regexp Regular expression for abbreviation element name\n\t\t * @param {Function} fn Resolver function\n\t\t * @param {Object} options Options list as described in \n\t\t * {@link HandlerList#add()} method\n\t\t */\n\t\taddGenerator: function(regexp, fn, options) {\n\t\t\tif (_.isString(regexp))\n\t\t\t\tregexp = new RegExp(regexp);\n\t\t\t\n\t\t\tgenerators.add(function(node, syntax) {\n\t\t\t\tvar m;\n\t\t\t\tif ((m = regexp.exec(node.name()))) {\n\t\t\t\t\treturn fn(m, node, syntax);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn null;\n\t\t\t}, options);\n\t\t}\n\t});\n\t\n\tresources.addResolver(function(node, syntax) {\n\t\treturn generators.exec(null, _.toArray(arguments));\n\t});\n});/**\n * Module for resolving tag names: returns best matched tag name for child\n * element based on passed parent's tag name. Also provides utility function\n * for element type detection (inline, block-level, empty)\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.define('tagName', function(require, _) {\n\tvar elementTypes = {\n//\t\tempty: 'area,base,basefont,br,col,frame,hr,img,input,isindex,link,meta,param,embed,keygen,command'.split(','),\n\t\tempty: [],\n\t\tblockLevel: 'address,applet,blockquote,button,center,dd,del,dir,div,dl,dt,fieldset,form,frameset,hr,iframe,ins,isindex,li,link,map,menu,noframes,noscript,object,ol,p,pre,script,table,tbody,td,tfoot,th,thead,tr,ul,h1,h2,h3,h4,h5,h6'.split(','),\n\t\tinlineLevel: 'a,abbr,acronym,applet,b,basefont,bdo,big,br,button,cite,code,del,dfn,em,font,i,iframe,img,input,ins,kbd,label,map,object,q,s,samp,select,small,span,strike,strong,sub,sup,textarea,tt,u,var'.split(',')\n\t};\n\t\n\tvar elementMap = {\n\t\t'p': 'span',\n\t\t'ul': 'li',\n\t\t'ol': 'li',\n\t\t'table': 'tr',\n\t\t'tr': 'td',\n\t\t'tbody': 'tr',\n\t\t'thead': 'tr',\n\t\t'tfoot': 'tr',\n\t\t'colgroup': 'col',\n\t\t'select': 'option',\n\t\t'optgroup': 'option',\n\t\t'audio': 'source',\n\t\t'video': 'source',\n\t\t'object': 'param',\n\t\t'map': 'area'\n\t};\n\t\n\treturn {\n\t\t/**\n\t\t * Returns best matched child element name for passed parent's\n\t\t * tag name\n\t\t * @param {String} name\n\t\t * @returns {String}\n\t\t * @memberOf tagName\n\t\t */\n\t\tresolve: function(name) {\n\t\t\tname = (name || '').toLowerCase();\n\t\t\t\n\t\t\tif (name in elementMap)\n\t\t\t\treturn this.getMapping(name);\n\t\t\t\n\t\t\tif (this.isInlineLevel(name))\n\t\t\t\treturn 'span';\n\t\t\t\n\t\t\treturn 'div';\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns mapped child element name for passed parent's name \n\t\t * @param {String} name\n\t\t * @returns {String}\n\t\t */\n\t\tgetMapping: function(name) {\n\t\t\treturn elementMap[name.toLowerCase()];\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if passed element name belongs to inline-level element\n\t\t * @param {String} name\n\t\t * @returns {Boolean}\n\t\t */\n\t\tisInlineLevel: function(name) {\n\t\t\treturn this.isTypeOf(name, 'inlineLevel');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if passed element belongs to block-level element.\n\t\t * For better matching of unknown elements (for XML, for example), \n\t\t * you should use <code>!this.isInlineLevel(name)</code>\n\t\t * @returns {Boolean}\n\t\t */\n\t\tisBlockLevel: function(name) {\n\t\t\treturn this.isTypeOf(name, 'blockLevel');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if passed element is void (i.e. should not have closing tag).\n\t\t * @returns {Boolean}\n\t\t */\n\t\tisEmptyElement: function(name) {\n\t\t\treturn this.isTypeOf(name, 'empty');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Generic function for testing if element name belongs to specified\n\t\t * elements collection\n\t\t * @param {String} name Element name\n\t\t * @param {String} type Collection name\n\t\t * @returns {Boolean}\n\t\t */\n\t\tisTypeOf: function(name, type) {\n\t\t\treturn _.include(elementTypes[type], name);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Adds new parent–child mapping\n\t\t * @param {String} parent\n\t\t * @param {String} child\n\t\t */\n\t\taddMapping: function(parent, child) {\n\t\t\telementMap[parent] = child;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Removes parent-child mapping\n\t\t */\n\t\tremoveMapping: function(parent) {\n\t\t\tif (parent in elementMap)\n\t\t\t\tdelete elementMap[parent];\n\t\t},\n\t\t\n\t\t/**\n\t\t * Adds new element into collection\n\t\t * @param {String} name Element name\n\t\t * @param {String} collection Collection name\n\t\t */\n\t\taddElementToCollection: function(name, collection) {\n\t\t\tif (!elementTypes[collection])\n\t\t\t\telementTypes[collection] = [];\n\t\t\t\n\t\t\tvar col = this.getCollection(collection);\n\t\t\tif (!_.include(col, name))\n\t\t\t\tcol.push(name);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Removes element name from specified collection\n\t\t * @param {String} name Element name\n\t\t * @param {String} collection Collection name\n\t\t * @returns\n\t\t */\n\t\tremoveElementFromCollection: function(name, collection) {\n\t\t\tif (collection in elementTypes) {\n\t\t\t\telementTypes[collection] = _.without(this.getCollection(collection), name);\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns elements name collection\n\t\t * @param {String} name Collection name\n\t\t * @returns {Array}\n\t\t */\n\t\tgetCollection: function(name) {\n\t\t\treturn elementTypes[name];\n\t\t}\n\t};\n});/**\n * Filter for aiding of writing elements with complex class names as described\n * in Yandex's BEM (Block, Element, Modifier) methodology. This filter will\n * automatically inherit block and element names from parent elements and insert\n * them into child element classes\n * @memberOf __bemFilterDefine\n * @constructor\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\tvar prefs = require('preferences');\n\tprefs.define('bem.elementSeparator', '__', 'Class name’s element separator.');\n\tprefs.define('bem.modifierSeparator', '_', 'Class name’s modifier separator.');\n\tprefs.define('bem.shortElementPrefix', '-', \n\t\t\t'Symbol for describing short “block-element” notation. Class names '\n\t\t\t+ 'prefixed with this symbol will be treated as element name for parent‘s '\n\t\t\t+ 'block name. Each symbol instance traverses one level up in parsed ' \n\t\t\t+ 'tree for block name lookup. Empty value will disable short notation.');\n\t\n\tvar shouldRunHtmlFilter = false;\n\t\n\tfunction getSeparators() {\n\t\treturn {\n\t\t\telement: prefs.get('bem.elementSeparator'),\n\t\t\tmodifier: prefs.get('bem.modifierSeparator')\n\t\t};\n\t}\n\t\n\t/**\n\t * @param {AbbreviationNode} item\n\t */\n\tfunction bemParse(item) {\n\t\tif (require('abbreviationUtils').isSnippet(item))\n\t\t\treturn item;\n\t\t\n\t\t// save BEM stuff in cache for faster lookups\n\t\titem.__bem = {\n\t\t\tblock: '',\n\t\t\telement: '',\n\t\t\tmodifier: ''\n\t\t};\n\t\t\n\t\tvar classNames = normalizeClassName(item.attribute('class')).split(' ');\n\t\t\n\t\t// guess best match for block name\n\t\tvar reBlockName = /^[a-z]\\-/i;\n\t\titem.__bem.block = _.find(classNames, function(name) {\n\t\t\treturn reBlockName.test(name);\n\t\t});\n\t\t\n\t\t// guessing doesn't worked, pick first class name as block name\n\t\tif (!item.__bem.block) {\n\t\t\treBlockName = /^[a-z]/i;\n\t\t\titem.__bem.block = _.find(classNames, function(name) {\n\t\t\t\treturn reBlockName.test(name);\n\t\t\t}) || '';\n\t\t}\n\t\t\n\t\tclassNames = _.chain(classNames)\n\t\t\t.map(function(name) {return processClassName(name, item);})\n\t\t\t.flatten()\n\t\t\t.uniq()\n\t\t\t.value()\n\t\t\t.join(' ');\n\t\t\n\t\tif (classNames)\n\t\t\titem.attribute('class', classNames);\n\t\t\n\t\treturn item;\n\t}\n\t\n\t/**\n\t * @param {String} className\n\t * @returns {String}\n\t */\n\tfunction normalizeClassName(className) {\n\t\tvar utils = require('utils');\n\t\tclassName = (' ' + (className || '') + ' ').replace(/\\s+/g, ' ');\n\t\t\n\t\tvar shortSymbol = prefs.get('bem.shortElementPrefix');\n\t\tif (shortSymbol) {\n\t\t\tvar re = new RegExp('\\\\s(' + utils.escapeForRegexp(shortSymbol) + '+)', 'g');\n\t\t\tclassName = className.replace(re, function(str, p1) {\n\t\t\t\treturn ' ' + utils.repeatString(getSeparators().element, p1.length);\n\t\t\t});\n\t\t}\n\t\t\n\t\treturn utils.trim(className);\n\t}\n\t\n\t/**\n\t * Processes class name\n\t * @param {String} name Class name item to process\n\t * @param {AbbreviationNode} item Host node for provided class name\n\t * @returns Processed class name. May return <code>Array</code> of\n\t * class names \n\t */\n\tfunction processClassName(name, item) {\n\t\tname = transformClassName(name, item, 'element');\n\t\tname = transformClassName(name, item, 'modifier');\n\t\t\n\t\t// expand class name\n\t\t// possible values:\n\t\t// * block__element\n\t\t// * block__element_modifier\n\t\t// * block__element_modifier1_modifier2\n\t\t// * block_modifier\n\t\tvar block = '', element = '', modifier = '';\n\t\tvar separators = getSeparators();\n\t\tif (~name.indexOf(separators.element)) {\n\t\t\tvar blockElem = name.split(separators.element);\n\t\t\tvar elemModifiers = blockElem[1].split(separators.modifier);\n\t\t\t\n\t\t\tblock = blockElem[0];\n\t\t\telement = elemModifiers.shift();\n\t\t\tmodifier = elemModifiers.join(separators.modifier);\n\t\t} else if (~name.indexOf(separators.modifier)) {\n\t\t\tvar blockModifiers = name.split(separators.modifier);\n\t\t\t\n\t\t\tblock = blockModifiers.shift();\n\t\t\tmodifier = blockModifiers.join(separators.modifier);\n\t\t}\n\t\t\n\t\tif (block || element || modifier) {\n\t\t\tif (!block) {\n\t\t\t\tblock = item.__bem.block;\n\t\t\t}\n\t\t\t\n\t\t\t// inherit parent bem element, if exists\n//\t\t\tif (item.parent && item.parent.__bem && item.parent.__bem.element)\n//\t\t\t\telement = item.parent.__bem.element + separators.element + element;\n\t\t\t\n\t\t\t// produce multiple classes\n\t\t\tvar prefix = block;\n\t\t\tvar result = [];\n\t\t\t\n\t\t\tif (element) {\n\t\t\t\tprefix += separators.element + element;\n\t\t\t\tresult.push(prefix);\n\t\t\t} else {\n\t\t\t\tresult.push(prefix);\n\t\t\t}\n\t\t\t\n\t\t\tif (modifier) {\n\t\t\t\tresult.push(prefix + separators.modifier + modifier);\n\t\t\t}\n\t\t\t\n\t\t\titem.__bem.block = block;\n\t\t\titem.__bem.element = element;\n\t\t\titem.__bem.modifier = modifier;\n\t\t\t\n\t\t\treturn result;\n\t\t}\n\t\t\n\t\t// ...otherwise, return processed or original class name\n\t\treturn name;\n\t}\n\t\n\t/**\n\t * Low-level function to transform user-typed class name into full BEM class\n\t * @param {String} name Class name item to process\n\t * @param {AbbreviationNode} item Host node for provided class name\n\t * @param {String} entityType Type of entity to be tried to transform \n\t * ('element' or 'modifier')\n\t * @returns {String} Processed class name or original one if it can't be\n\t * transformed\n\t */\n\tfunction transformClassName(name, item, entityType) {\n\t\tvar separators = getSeparators();\n\t\tvar reSep = new RegExp('^(' + separators[entityType] + ')+', 'g');\n\t\tif (reSep.test(name)) {\n\t\t\tvar depth = 0; // parent lookup depth\n\t\t\tvar cleanName = name.replace(reSep, function(str, p1) {\n\t\t\t\tdepth = str.length / separators[entityType].length;\n\t\t\t\treturn '';\n\t\t\t});\n\t\t\t\n\t\t\t// find donor element\n\t\t\tvar donor = item;\n\t\t\twhile (donor.parent && depth--) {\n\t\t\t\tdonor = donor.parent;\n\t\t\t}\n\t\t\t\n\t\t\tif (!donor || !donor.__bem)\n\t\t\t\tdonor = item;\n\t\t\t\n\t\t\tif (donor && donor.__bem) {\n\t\t\t\tvar prefix = donor.__bem.block;\n\t\t\t\t\n\t\t\t\t// decide if we should inherit element name\n//\t\t\t\tif (entityType == 'element') {\n//\t\t\t\t\tvar curElem = cleanName.split(separators.modifier, 1)[0];\n//\t\t\t\t\tif (donor.__bem.element && donor.__bem.element != curElem)\n//\t\t\t\t\t\tprefix += separators.element + donor.__bem.element;\n//\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (entityType == 'modifier' &&  donor.__bem.element)\n\t\t\t\t\tprefix += separators.element + donor.__bem.element;\n\t\t\t\t\n\t\t\t\treturn prefix + separators[entityType] + cleanName;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn name;\n\t}\n\t\n\t/**\n\t * Recursive function for processing tags, which extends class names \n\t * according to BEM specs: http://bem.github.com/bem-method/pages/beginning/beginning.ru.html\n\t * <br><br>\n\t * It does several things:<br>\n\t * <ul>\n\t * <li>Expands complex class name (according to BEM symbol semantics):\n\t * .block__elem_modifier → .block.block__elem.block__elem_modifier\n\t * </li>\n\t * <li>Inherits block name on child elements: \n\t * .b-block > .__el > .__el → .b-block > .b-block__el > .b-block__el__el\n\t * </li>\n\t * <li>Treats first dash symbol as '__'</li>\n\t * <li>Double underscore (or typographic '–') is also treated as an element \n\t * level lookup, e.g. ____el will search for element definition in parent’s \n\t * parent element:\n\t * .b-block > .__el1 > .____el2 → .b-block > .b-block__el1 > .b-block__el2\n\t * </li>\n\t * </ul>\n\t * \n\t * @param {AbbreviationNode} tree\n\t * @param {Object} profile\n\t */\n\tfunction process(tree, profile) {\n\t\tif (tree.name)\n\t\t\tbemParse(tree, profile);\n\t\t\n\t\tvar abbrUtils = require('abbreviationUtils');\n\t\t_.each(tree.children, function(item) {\n\t\t\tprocess(item, profile);\n\t\t\tif (!abbrUtils.isSnippet(item) && item.start)\n\t\t\t\tshouldRunHtmlFilter = true;\n\t\t});\n\t\t\n\t\treturn tree;\n\t};\n\t\n\trequire('filters').add('bem', function(tree, profile) {\n\t\tshouldRunHtmlFilter = false;\n\t\ttree = process(tree, profile);\n\t\t// in case 'bem' filter is applied after 'html' filter: run it again\n\t\t// to update output\n\t\tif (shouldRunHtmlFilter) {\n\t\t\ttree = require('filters').apply(tree, 'html', profile);\n\t\t}\n\t\t\n\t\treturn tree;\n\t});\n});\n\n/**\n * Comment important tags (with 'id' and 'class' attributes)\n * @author Sergey Chikuyonok (serge.che@gmail.com)\n * @link http://chikuyonok.ru\n * @constructor\n * @memberOf __commentFilterDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\t// define some preferences\n\t/** @type emmet.preferences */\n\tvar prefs = require('preferences');\n\t\n\tprefs.define('filter.commentAfter', \n\t\t\t'\\n<!-- /<%= attr(\"id\", \"#\") %><%= attr(\"class\", \".\") %> -->',\n\t\t\t'A definition of comment that should be placed <i>after</i> matched '\n\t\t\t+ 'element when <code>comment</code> filter is applied. This definition '\n\t\t\t+ 'is an ERB-style template passed to <code>_.template()</code> '\n\t\t\t+ 'function (see Underscore.js docs for details). In template context, '\n\t\t\t+ 'the following properties and functions are availabe:\\n'\n\t\t\t+ '<ul>'\n\t\t\t\n\t\t\t+ '<li><code>attr(name, before, after)</code> – a function that outputs' \n\t\t\t+ 'specified attribute value concatenated with <code>before</code> ' \n\t\t\t+ 'and <code>after</code> strings. If attribute doesn\\'t exists, the ' \n\t\t\t+ 'empty string will be returned.</li>'\n\t\t\t\n\t\t\t+ '<li><code>node</code> – current node (instance of <code>AbbreviationNode</code>)</li>'\n\t\t\t\n\t\t\t+ '<li><code>name</code> – name of current tag</li>'\n\t\t\t\n\t\t\t+ '<li><code>padding</code> – current string padding, can be used ' \n\t\t\t+ 'for formatting</li>'\n\t\t\t\n\t\t\t+'</ul>');\n\t\n\tprefs.define('filter.commentBefore', \n\t\t\t'',\n\t\t\t'A definition of comment that should be placed <i>before</i> matched '\n\t\t\t+ 'element when <code>comment</code> filter is applied. '\n\t\t\t+ 'For more info, read description of <code>filter.commentAfter</code> '\n\t\t\t+ 'property');\n\t\n\tprefs.define('filter.commentTrigger', 'id, class',\n\t\t\t'A comma-separated list of attribute names that should exist in abbreviatoin '\n\t\t\t+ 'where comment should be added. If you wish to add comment for '\n\t\t\t+ 'every element, set this option to <code>*</code>');\n\t\n\t/**\n\t * Add comments to tag\n\t * @param {AbbreviationNode} node\n\t */\n\tfunction addComments(node, templateBefore, templateAfter) {\n\t\tvar utils = require('utils');\n\t\t\n\t\t// check if comments should be added\n\t\tvar trigger = prefs.get('filter.commentTrigger');\n\t\tif (trigger != '*') {\n\t\t\tvar shouldAdd = _.find(trigger.split(','), function(name) {\n\t\t\t\treturn !!node.attribute(utils.trim(name));\n\t\t\t});\n\t\t\tif (!shouldAdd) return;\n\t\t}\n\t\t\n\t\tvar ctx = {\n\t\t\tnode: node,\n\t\t\tname: node.name(),\n\t\t\tpadding: node.parent ? node.parent.padding : '',\n\t\t\tattr: function(name, before, after) {\n\t\t\t\tvar attr = node.attribute(name);\n\t\t\t\tif (attr) {\n\t\t\t\t\treturn (before || '') + attr + (after || '');\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn '';\n\t\t\t}\n\t\t};\n\t\t\n\t\tvar nodeBefore = utils.normalizeNewline(templateBefore ? templateBefore(ctx) : '');\n\t\tvar nodeAfter = utils.normalizeNewline(templateAfter ? templateAfter(ctx) : '');\n\t\t\n\t\tnode.start = node.start.replace(/</, nodeBefore + '<');\n\t\tnode.end = node.end.replace(/>/, '>' + nodeAfter);\n\t}\n\t\n\tfunction process(tree, before, after) {\n\t\tvar abbrUtils = require('abbreviationUtils');\n\t\t_.each(tree.children, function(item) {\n\t\t\tif (abbrUtils.isBlock(item))\n\t\t\t\taddComments(item, before, after);\n\t\t\t\n\t\t\tprocess(item, before, after);\n\t\t});\n\t\t\t\n\t\treturn tree;\n\t}\n\t\n\trequire('filters').add('c', function(tree) {\n\t\tvar templateBefore = _.template(prefs.get('filter.commentBefore'));\n\t\tvar templateAfter = _.template(prefs.get('filter.commentAfter'));\n\t\t\n\t\treturn process(tree, templateBefore, templateAfter);\n\t});\n});\n/**\n * Filter for escaping unsafe XML characters: <, >, &\n * @author Sergey Chikuyonok (serge.che@gmail.com)\n * @link http://chikuyonok.ru\n */\nemmet.exec(function(require, _) {\n\tvar charMap = {\n\t\t'<': '&lt;',\n\t\t'>': '&gt;',\n\t\t'&': '&amp;'\n\t};\n\t\n\tfunction escapeChars(str) {\n\t\treturn str.replace(/([<>&])/g, function(str, p1){\n\t\t\treturn charMap[p1];\n\t\t});\n\t}\n\t\n\trequire('filters').add('e', function process(tree) {\n\t\t_.each(tree.children, function(item) {\n\t\t\titem.start = escapeChars(item.start);\n\t\t\titem.end = escapeChars(item.end);\n\t\t\titem.content = escapeChars(item.content);\n\t\t\tprocess(item);\n\t\t});\n\t\t\n\t\treturn tree;\n\t});\n});/**\n * Generic formatting filter: creates proper indentation for each tree node,\n * placing \"%s\" placeholder where the actual output should be. You can use\n * this filter to preformat tree and then replace %s placeholder to whatever you\n * need. This filter should't be called directly from editor as a part \n * of abbreviation.\n * @author Sergey Chikuyonok (serge.che@gmail.com)\n * @link http://chikuyonok.ru\n * @constructor\n * @memberOf __formatFilterDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _){\n\tvar placeholder = '%s';\n\t\n\t/** @type preferences */\n\tvar prefs = require('preferences');\n\tprefs.define('format.noIndentTags', 'html', \n\t\t\t'A comma-separated list of tag names that should not get inner indentation.');\n\t\n\tprefs.define('format.forceIndentationForTags', 'body', \n\t\t'A comma-separated list of tag names that should <em>always</em> get inner indentation.');\n\t\n\t/**\n\t * Get indentation for given node\n\t * @param {AbbreviationNode} node\n\t * @returns {String}\n\t */\n\tfunction getIndentation(node) {\n\t\tif (_.include(prefs.getArray('format.noIndentTags') || [], node.name())) {\n\t\t\treturn '';\n\t\t}\n\t\t\n\t\treturn require('resources').getVariable('indentation');\n\t}\n\t\n\t/**\n\t * Test if passed node has block-level sibling element\n\t * @param {AbbreviationNode} item\n\t * @return {Boolean}\n\t */\n\tfunction hasBlockSibling(item) {\n\t\treturn item.parent && require('abbreviationUtils').hasBlockChildren(item.parent);\n\t}\n\t\n\t/**\n\t * Test if passed item is very first child in parsed tree\n\t * @param {AbbreviationNode} item\n\t */\n\tfunction isVeryFirstChild(item) {\n\t\treturn item.parent && !item.parent.parent && !item.index();\n\t}\n\t\n\t/**\n\t * Check if a newline should be added before element\n\t * @param {AbbreviationNode} node\n\t * @param {OutputProfile} profile\n\t * @return {Boolean}\n\t */\n\tfunction shouldAddLineBreak(node, profile) {\n\t\tvar abbrUtils = require('abbreviationUtils');\n\t\tif (profile.tag_nl === true || abbrUtils.isBlock(node))\n\t\t\treturn true;\n\t\t\n\t\tif (!node.parent || !profile.inline_break)\n\t\t\treturn false;\n\t\t\n\t\t// check if there are required amount of adjacent inline element\n\t\treturn shouldFormatInline(node.parent, profile);\n}\n\t\n\t/**\n\t * Need to add newline because <code>item</code> has too many inline children\n\t * @param {AbbreviationNode} node\n\t * @param {OutputProfile} profile\n\t */\n\tfunction shouldBreakChild(node, profile) {\n\t\t// we need to test only one child element, because \n\t\t// hasBlockChildren() method will do the rest\n\t\treturn node.children.length && shouldAddLineBreak(node.children[0], profile);\n\t}\n\t\n\tfunction shouldFormatInline(node, profile) {\n\t\tvar nodeCount = 0;\n\t\tvar abbrUtils = require('abbreviationUtils');\n\t\treturn !!_.find(node.children, function(child) {\n\t\t\tif (child.isTextNode() || !abbrUtils.isInline(child))\n\t\t\t\tnodeCount = 0;\n\t\t\telse if (abbrUtils.isInline(child))\n\t\t\t\tnodeCount++;\n\t\t\t\n\t\t\tif (nodeCount >= profile.inline_break)\n\t\t\t\treturn true;\n\t\t});\n\t}\n\t\n\tfunction isRoot(item) {\n\t\treturn !item.parent;\n\t}\n\t\n\t/**\n\t * Processes element with matched resource of type <code>snippet</code>\n\t * @param {AbbreviationNode} item\n\t * @param {OutputProfile} profile\n\t * @param {Number} level Depth level\n\t */\n\tfunction processSnippet(item, profile, level) {\n\t\titem.start = item.end = '';\n\t\tif (!isVeryFirstChild(item) && profile.tag_nl !== false && shouldAddLineBreak(item, profile)) {\n\t\t\t// check if we’re not inside inline element\n\t\t\tif (isRoot(item.parent) || !require('abbreviationUtils').isInline(item.parent)) {\n\t\t\t\titem.start = require('utils').getNewline() + item.start;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn item;\n\t}\n\t\n\t/**\n\t * Check if we should add line breaks inside inline element\n\t * @param {AbbreviationNode} node\n\t * @param {OutputProfile} profile\n\t * @return {Boolean}\n\t */\n\tfunction shouldBreakInsideInline(node, profile) {\n\t\tvar abbrUtils = require('abbreviationUtils');\n\t\tvar hasBlockElems = _.any(node.children, function(child) {\n\t\t\tif (abbrUtils.isSnippet(child))\n\t\t\t\treturn false;\n\t\t\t\n\t\t\treturn !abbrUtils.isInline(child);\n\t\t});\n\t\t\n\t\tif (!hasBlockElems) {\n\t\t\treturn shouldFormatInline(node, profile);\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\t/**\n\t * Processes element with <code>tag</code> type\n\t * @param {AbbreviationNode} item\n\t * @param {OutputProfile} profile\n\t * @param {Number} level Depth level\n\t */\n\tfunction processTag(item, profile, level) {\n\t\titem.start = item.end = placeholder;\n\t\tvar utils = require('utils');\n\t\tvar abbrUtils = require('abbreviationUtils');\n\t\tvar isUnary = abbrUtils.isUnary(item);\n\t\tvar nl = utils.getNewline();\n\t\tvar indent = getIndentation(item);\n\t\t\t\n\t\t// formatting output\n\t\tif (profile.tag_nl !== false) {\n\t\t\tvar forceNl = profile.tag_nl === true && (profile.tag_nl_leaf || item.children.length);\n\t\t\tif (!forceNl) {\n\t\t\t\tforceNl = _.include(prefs.getArray('format.forceIndentationForTags') || [], item.name());\n\t\t\t}\n\t\t\t\n\t\t\t// formatting block-level elements\n\t\t\tif (!item.isTextNode()) {\n\t\t\t\tif (shouldAddLineBreak(item, profile)) {\n\t\t\t\t\t// - do not indent the very first element\n\t\t\t\t\t// - do not indent first child of a snippet\n\t\t\t\t\tif (!isVeryFirstChild(item) && (!abbrUtils.isSnippet(item.parent) || item.index()))\n\t\t\t\t\t\titem.start = nl + item.start;\n\t\t\t\t\t\t\n\t\t\t\t\tif (abbrUtils.hasBlockChildren(item) || shouldBreakChild(item, profile) || (forceNl && !isUnary))\n\t\t\t\t\t\titem.end = nl + item.end;\n\t\t\t\t\t\t\n\t\t\t\t\tif (abbrUtils.hasTagsInContent(item) || (forceNl && !item.children.length && !isUnary))\n\t\t\t\t\t\titem.start += nl + indent;\n\t\t\t\t} else if (abbrUtils.isInline(item) && hasBlockSibling(item) && !isVeryFirstChild(item)) {\n\t\t\t\t\titem.start = nl + item.start;\n\t\t\t\t} else if (abbrUtils.isInline(item) && shouldBreakInsideInline(item, profile)) {\n\t\t\t\t\titem.end = nl + item.end;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\titem.padding = indent;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn item;\n\t}\n\t\n\t/**\n\t * Processes simplified tree, making it suitable for output as HTML structure\n\t * @param {AbbreviationNode} tree\n\t * @param {OutputProfile} profile\n\t * @param {Number} level Depth level\n\t */\n\trequire('filters').add('_format', function process(tree, profile, level) {\n\t\tlevel = level || 0;\n\t\tvar abbrUtils = require('abbreviationUtils');\n\t\t\n\t\t_.each(tree.children, function(item) {\n\t\t\tif (abbrUtils.isSnippet(item))\n\t\t\t\tprocessSnippet(item, profile, level);\n\t\t\telse\n\t\t\t\tprocessTag(item, profile, level);\n\t\t\t\n\t\t\tprocess(item, profile, level + 1);\n\t\t});\n\t\t\n\t\treturn tree;\n\t});\n});/**\n * Filter for producing HAML code from abbreviation.\n * @author Sergey Chikuyonok (serge.che@gmail.com)\n * @link http://chikuyonok.ru\n * @constructor\n * @memberOf __hamlFilterDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\tvar childToken = '${child}';\n\t\n\tfunction transformClassName(className) {\n\t\treturn require('utils').trim(className).replace(/\\s+/g, '.');\n\t}\n\t\n\t/**\n\t * Creates HAML attributes string from tag according to profile settings\n\t * @param {AbbreviationNode} tag\n\t * @param {Object} profile\n\t */\n\tfunction makeAttributesString(tag, profile) {\n\t\tvar attrs = '';\n\t\tvar otherAttrs = [];\n\t\tvar attrQuote = profile.attributeQuote();\n\t\tvar cursor = profile.cursor();\n\t\t\n\t\t_.each(tag.attributeList(), function(a) {\n\t\t\tvar attrName = profile.attributeName(a.name);\n\t\t\tswitch (attrName.toLowerCase()) {\n\t\t\t\t// use short notation for ID and CLASS attributes\n\t\t\t\tcase 'id':\n\t\t\t\t\tattrs += '#' + (a.value || cursor);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'class':\n\t\t\t\t\tattrs += '.' + transformClassName(a.value || cursor);\n\t\t\t\t\tbreak;\n\t\t\t\t// process other attributes\n\t\t\t\tdefault:\n\t\t\t\t\totherAttrs.push(':' +attrName + ' => ' + attrQuote + (a.value || cursor) + attrQuote);\n\t\t\t}\n\t\t});\n\t\t\n\t\tif (otherAttrs.length)\n\t\t\tattrs += '{' + otherAttrs.join(', ') + '}';\n\t\t\n\t\treturn attrs;\n\t}\n\t\n\t/**\n\t * Test if passed node has block-level sibling element\n\t * @param {AbbreviationNode} item\n\t * @return {Boolean}\n\t */\n\tfunction hasBlockSibling(item) {\n\t\treturn item.parent && item.parent.hasBlockChildren();\n\t}\n\t\n\t/**\n\t * Processes element with <code>tag</code> type\n\t * @param {AbbreviationNode} item\n\t * @param {OutputProfile} profile\n\t * @param {Number} level Depth level\n\t */\n\tfunction processTag(item, profile, level) {\n\t\tif (!item.parent)\n\t\t\t// looks like it's root element\n\t\t\treturn item;\n\t\t\n\t\tvar abbrUtils = require('abbreviationUtils');\n\t\tvar utils = require('utils');\n\t\t\n\t\tvar attrs = makeAttributesString(item, profile);\n\t\tvar cursor = profile.cursor();\n\t\tvar isUnary = abbrUtils.isUnary(item);\n\t\tvar selfClosing = profile.self_closing_tag && isUnary ? '/' : '';\n\t\tvar start= '';\n\t\t\t\n\t\t// define tag name\n\t\tvar tagName = '%' + profile.tagName(item.name());\n\t\tif (tagName.toLowerCase() == '%div' && attrs && attrs.indexOf('{') == -1)\n\t\t\t// omit div tag\n\t\t\ttagName = '';\n\t\t\t\n\t\titem.end = '';\n\t\tstart = tagName + attrs + selfClosing + ' ';\n\t\t\n\t\tvar placeholder = '%s';\n\t\t// We can't just replace placeholder with new value because\n\t\t// JavaScript will treat double $ character as a single one, assuming\n\t\t// we're using RegExp literal.\n\t\titem.start = utils.replaceSubstring(item.start, start, item.start.indexOf(placeholder), placeholder);\n\t\t\n\t\tif (!item.children.length && !isUnary)\n\t\t\titem.start += cursor;\n\t\t\n\t\treturn item;\n\t}\n\t\n\t/**\n\t * Processes simplified tree, making it suitable for output as HTML structure\n\t * @param {AbbreviationNode} tree\n\t * @param {Object} profile\n\t * @param {Number} level Depth level\n\t */\n\trequire('filters').add('haml', function process(tree, profile, level) {\n\t\tlevel = level || 0;\n\t\tvar abbrUtils = require('abbreviationUtils');\n\t\t\n\t\tif (!level) {\n\t\t\ttree = require('filters').apply(tree, '_format', profile);\n\t\t}\n\t\t\n\t\t_.each(tree.children, function(item) {\n\t\t\tif (!abbrUtils.isSnippet(item))\n\t\t\t\tprocessTag(item, profile, level);\n\t\t\t\n\t\t\tprocess(item, profile, level + 1);\n\t\t});\n\t\t\n\t\treturn tree;\n\t});\n});/**\n * Filter that produces HTML tree\n * @author Sergey Chikuyonok (serge.che@gmail.com)\n * @link http://chikuyonok.ru\n * @constructor\n * @memberOf __htmlFilterDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\t/**\n\t * Creates HTML attributes string from tag according to profile settings\n\t * @param {AbbreviationNode} node\n\t * @param {OutputProfile} profile\n\t */\n\tfunction makeAttributesString(node, profile) {\n\t\tvar attrQuote = profile.attributeQuote();\n\t\tvar cursor = profile.cursor();\n\t\t\n\t\treturn _.map(node.attributeList(), function(a) {\n\t\t\tvar attrName = profile.attributeName(a.name);\n\t\t\treturn ' ' + attrName + '=' + attrQuote + (a.value || cursor) + attrQuote;\n\t\t}).join('');\n\t}\n\t\n\t/**\n\t * Processes element with <code>tag</code> type\n\t * @param {AbbreviationNode} item\n\t * @param {OutputProfile} profile\n\t * @param {Number} level Depth level\n\t */\n\tfunction processTag(item, profile, level) {\n\t\tif (!item.parent) // looks like it's root element\n\t\t\treturn item;\n\t\t\n\t\tvar abbrUtils = require('abbreviationUtils');\n\t\tvar utils = require('utils');\n\t\t\n\t\tvar attrs = makeAttributesString(item, profile); \n\t\tvar cursor = profile.cursor();\n\t\tvar isUnary = abbrUtils.isUnary(item);\n\t\tvar start= '';\n\t\tvar end = '';\n\t\t\t\n\t\t// define opening and closing tags\n\t\tif (!item.isTextNode()) {\n\t\t\tvar tagName = profile.tagName(item.name());\n\t\t\tif (isUnary) {\n\t\t\t\tstart = '<' + tagName + attrs + profile.selfClosing() + '>';\n\t\t\t\titem.end = '';\n\t\t\t} else {\n\t\t\t\tstart = '<' + tagName + attrs + '>';\n\t\t\t\tend = '</' + tagName + '>';\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar placeholder = '%s';\n\t\t// We can't just replace placeholder with new value because\n\t\t// JavaScript will treat double $ character as a single one, assuming\n\t\t// we're using RegExp literal.\n\t\titem.start = utils.replaceSubstring(item.start, start, item.start.indexOf(placeholder), placeholder);\n\t\titem.end = utils.replaceSubstring(item.end, end, item.end.indexOf(placeholder), placeholder);\n\t\t\n\t\t// should we put caret placeholder after opening tag?\n\t\tif (\n\t\t\t\t!item.children.length \n\t\t\t\t&& !isUnary \n\t\t\t\t&& !~item.content.indexOf(cursor)\n\t\t\t\t&& !require('tabStops').extract(item.content).tabstops.length\n\t\t\t) {\n\t\t\titem.start += cursor;\n\t\t}\n\t\t\n\t\treturn item;\n\t}\n\t\n\t/**\n\t * Processes simplified tree, making it suitable for output as HTML structure\n\t * @param {AbbreviationNode} tree\n\t * @param {Object} profile\n\t * @param {Number} level Depth level\n\t */\n\trequire('filters').add('html', function process(tree, profile, level) {\n\t\tlevel = level || 0;\n\t\tvar abbrUtils = require('abbreviationUtils');\n\t\t\n\t\tif (!level) {\n\t\t\ttree = require('filters').apply(tree, '_format', profile);\n\t\t}\n\t\t\n\t\t_.each(tree.children, function(item) {\n\t\t\tif (!abbrUtils.isSnippet(item))\n\t\t\t\tprocessTag(item, profile, level);\n\t\t\t\n\t\t\tprocess(item, profile, level + 1);\n\t\t});\n\t\t\n\t\treturn tree;\n\t});\n});/**\n * Output abbreviation on a single line (i.e. no line breaks)\n * @author Sergey Chikuyonok (serge.che@gmail.com)\n * @link http://chikuyonok.ru\n * @constructor\n * @memberOf __singleLineFilterDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\tvar rePad = /^\\s+/;\n\tvar reNl = /[\\n\\r]/g;\n\t\n\trequire('filters').add('s', function process(tree, profile, level) {\n\t\tvar abbrUtils = require('abbreviationUtils');\n\t\t\n\t\t_.each(tree.children, function(item) {\n\t\t\tif (!abbrUtils.isSnippet(item)) {\n\t\t\t\t// remove padding from item \n\t\t\t\titem.start = item.start.replace(rePad, '');\n\t\t\t\titem.end = item.end.replace(rePad, '');\n\t\t\t}\n\t\t\t\n\t\t\t// remove newlines \n\t\t\titem.start = item.start.replace(reNl, '');\n\t\t\titem.end = item.end.replace(reNl, '');\n\t\t\titem.content = item.content.replace(reNl, '');\n\t\t\t\n\t\t\tprocess(item);\n\t\t});\n\t\t\n\t\treturn tree;\n\t});\n});\n/**\n * Trim filter: removes characters at the beginning of the text\n * content that indicates lists: numbers, #, *, -, etc.\n * \n * Useful for wrapping lists with abbreviation.\n * \n * @author Sergey Chikuyonok (serge.che@gmail.com)\n * @link http://chikuyonok.ru\n * \n * @constructor\n * @memberOf __trimFilterDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\trequire('preferences').define('filter.trimRegexp', '[\\\\s|\\\\u00a0]*[\\\\d|#|\\\\-|\\*|\\\\u2022]+\\\\.?\\\\s*',\n\t\t\t'Regular expression used to remove list markers (numbers, dashes, ' \n\t\t\t+ 'bullets, etc.) in <code>t</code> (trim) filter. The trim filter '\n\t\t\t+ 'is useful for wrapping with abbreviation lists, pased from other ' \n\t\t\t+ 'documents (for example, Word documents).');\n\t\n\tfunction process(tree, re) {\n\t\t_.each(tree.children, function(item) {\n\t\t\tif (item.content)\n\t\t\t\titem.content = item.content.replace(re, '');\n\t\t\t\n\t\t\tprocess(item, re);\n\t\t});\n\t\t\n\t\treturn tree;\n\t}\n\t\n\trequire('filters').add('t', function(tree) {\n\t\tvar re = new RegExp(require('preferences').get('filter.trimRegexp'));\n\t\treturn process(tree, re);\n\t});\n});\n/**\n * Filter for trimming \"select\" attributes from some tags that contains\n * child elements\n * @author Sergey Chikuyonok (serge.che@gmail.com)\n * @link http://chikuyonok.ru\n * \n * @constructor\n * @memberOf __xslFilterDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\tvar tags = {\n\t\t'xsl:variable': 1,\n\t\t'xsl:with-param': 1\n\t};\n\t\n\t/**\n\t * Removes \"select\" attribute from node\n\t * @param {AbbreviationNode} node\n\t */\n\tfunction trimAttribute(node) {\n\t\tnode.start = node.start.replace(/\\s+select\\s*=\\s*(['\"]).*?\\1/, '');\n\t}\n\t\n\trequire('filters').add('xsl', function process(tree) {\n\t\tvar abbrUtils = require('abbreviationUtils');\n\t\t_.each(tree.children, function(item) {\n\t\t\tif (!abbrUtils.isSnippet(item)\n\t\t\t\t\t&& (item.name() || '').toLowerCase() in tags \n\t\t\t\t\t&& item.children.length)\n\t\t\t\ttrimAttribute(item);\n\t\t\tprocess(item);\n\t\t});\n\t\t\n\t\treturn tree;\n\t});\n});/**\n * \"Lorem ipsum\" text generator. Matches <code>lipsum(num)?</code> or \n * <code>lorem(num)?</code> abbreviation.\n * This code is based on Django's contribution: \n * https://code.djangoproject.com/browser/django/trunk/django/contrib/webdesign/lorem_ipsum.py\n * <br><br>\n * Examples to test:<br>\n * <code>lipsum</code> – generates 30 words text.<br>\n * <code>lipsum*6</code> – generates 6 paragraphs (autowrapped with &lt;p&gt; element) of text.<br>\n * <code>ol>lipsum10*5</code> — generates ordered list with 5 list items (autowrapped with &lt;li&gt; tag)\n * with text of 10 words on each line<br>\n * <code>span*3>lipsum20</code> – generates 3 paragraphs of 20-words text, each wrapped with &lt;span&gt; element .\n * Each paragraph phrase is unique   \n * @param {Function} require\n * @param {Underscore} _ \n * @constructor\n * @memberOf __loremIpsumGeneratorDefine\n */\nemmet.define('lorem', function(require, _) {\n\tvar langs = {\n\t\ten: {\n\t\t\tcommon: ['lorem', 'ipsum', 'dolor', 'sit', 'amet', 'consectetur', 'adipisicing', 'elit'],\n\t\t\twords: ['exercitationem', 'perferendis', 'perspiciatis', 'laborum', 'eveniet',\n\t             'sunt', 'iure', 'nam', 'nobis', 'eum', 'cum', 'officiis', 'excepturi',\n\t             'odio', 'consectetur', 'quasi', 'aut', 'quisquam', 'vel', 'eligendi',\n\t             'itaque', 'non', 'odit', 'tempore', 'quaerat', 'dignissimos',\n\t             'facilis', 'neque', 'nihil', 'expedita', 'vitae', 'vero', 'ipsum',\n\t             'nisi', 'animi', 'cumque', 'pariatur', 'velit', 'modi', 'natus',\n\t             'iusto', 'eaque', 'sequi', 'illo', 'sed', 'ex', 'et', 'voluptatibus',\n\t             'tempora', 'veritatis', 'ratione', 'assumenda', 'incidunt', 'nostrum',\n\t             'placeat', 'aliquid', 'fuga', 'provident', 'praesentium', 'rem',\n\t             'necessitatibus', 'suscipit', 'adipisci', 'quidem', 'possimus',\n\t             'voluptas', 'debitis', 'sint', 'accusantium', 'unde', 'sapiente',\n\t             'voluptate', 'qui', 'aspernatur', 'laudantium', 'soluta', 'amet',\n\t             'quo', 'aliquam', 'saepe', 'culpa', 'libero', 'ipsa', 'dicta',\n\t             'reiciendis', 'nesciunt', 'doloribus', 'autem', 'impedit', 'minima',\n\t             'maiores', 'repudiandae', 'ipsam', 'obcaecati', 'ullam', 'enim',\n\t             'totam', 'delectus', 'ducimus', 'quis', 'voluptates', 'dolores',\n\t             'molestiae', 'harum', 'dolorem', 'quia', 'voluptatem', 'molestias',\n\t             'magni', 'distinctio', 'omnis', 'illum', 'dolorum', 'voluptatum', 'ea',\n\t             'quas', 'quam', 'corporis', 'quae', 'blanditiis', 'atque', 'deserunt',\n\t             'laboriosam', 'earum', 'consequuntur', 'hic', 'cupiditate',\n\t             'quibusdam', 'accusamus', 'ut', 'rerum', 'error', 'minus', 'eius',\n\t             'ab', 'ad', 'nemo', 'fugit', 'officia', 'at', 'in', 'id', 'quos',\n\t             'reprehenderit', 'numquam', 'iste', 'fugiat', 'sit', 'inventore',\n\t             'beatae', 'repellendus', 'magnam', 'recusandae', 'quod', 'explicabo',\n\t             'doloremque', 'aperiam', 'consequatur', 'asperiores', 'commodi',\n\t             'optio', 'dolor', 'labore', 'temporibus', 'repellat', 'veniam',\n\t             'architecto', 'est', 'esse', 'mollitia', 'nulla', 'a', 'similique',\n\t             'eos', 'alias', 'dolore', 'tenetur', 'deleniti', 'porro', 'facere',\n\t             'maxime', 'corrupti']\n\t\t},\n\t\tru: {\n\t\t\tcommon: ['далеко-далеко', 'за', 'словесными', 'горами', 'в стране', 'гласных', 'и согласных', 'живут', 'рыбные', 'тексты'],\n\t\t\twords: ['вдали', 'от всех', 'они', 'буквенных', 'домах', 'на берегу', 'семантика', \n\t\t            'большого', 'языкового', 'океана', 'маленький', 'ручеек', 'даль', \n\t\t            'журчит', 'по всей', 'обеспечивает', 'ее','всеми', 'необходимыми', \n\t\t            'правилами', 'эта', 'парадигматическая', 'страна', 'которой', 'жаренные', \n\t\t            'предложения', 'залетают', 'прямо', 'рот', 'даже', 'всемогущая', \n\t\t            'пунктуация', 'не', 'имеет', 'власти', 'над', 'рыбными', 'текстами', \n\t\t            'ведущими', 'безорфографичный', 'образ', 'жизни', 'однажды', 'одна', \n\t\t            'маленькая', 'строчка','рыбного', 'текста', 'имени', 'lorem', 'ipsum', \n\t\t            'решила', 'выйти', 'большой', 'мир', 'грамматики', 'великий', 'оксмокс', \n\t\t            'предупреждал', 'о', 'злых', 'запятых', 'диких', 'знаках', 'вопроса', \n\t\t            'коварных', 'точках', 'запятой', 'но', 'текст', 'дал', 'сбить', \n\t\t            'себя', 'толку', 'он', 'собрал', 'семь', 'своих', 'заглавных', 'букв', \n\t\t            'подпоясал', 'инициал', 'за', 'пояс', 'пустился', 'дорогу', \n\t\t            'взобравшись', 'первую', 'вершину', 'курсивных', 'гор', 'бросил', \n\t\t            'последний', 'взгляд', 'назад', 'силуэт', 'своего', 'родного', 'города', \n\t\t            'буквоград', 'заголовок', 'деревни', 'алфавит', 'подзаголовок', 'своего', \n\t\t            'переулка', 'грустный', 'реторический', 'вопрос', 'скатился', 'его', \n\t\t            'щеке', 'продолжил', 'свой', 'путь', 'дороге', 'встретил', 'рукопись', \n\t\t            'она', 'предупредила',  'моей', 'все', 'переписывается', 'несколько', \n\t\t            'раз', 'единственное', 'что', 'меня', 'осталось', 'это', 'приставка', \n\t\t            'возвращайся', 'ты', 'лучше', 'свою', 'безопасную', 'страну', 'послушавшись', \n\t\t            'рукописи', 'наш', 'продолжил', 'свой', 'путь', 'вскоре', 'ему', \n\t\t            'повстречался', 'коварный', 'составитель', 'рекламных', 'текстов', \n\t\t            'напоивший', 'языком', 'речью', 'заманивший', 'свое', 'агенство', \n\t\t            'которое', 'использовало', 'снова', 'снова', 'своих', 'проектах', \n\t\t            'если', 'переписали', 'то', 'живет', 'там', 'до', 'сих', 'пор']\n\t\t}\n\t};\n\n\tvar prefs = require('preferences');\n\tprefs.define('lorem.defaultLang', 'en');\n\n\t/**\n\t * @param {AbbreviationNode} tree\n\t * @param {Object} options\n\t */\n\trequire('abbreviationParser').addPreprocessor(function(tree, options) {\n\t\tvar re = /^(?:lorem|lipsum)([a-z]{2})?(\\d*)$/i, match;\n\t\t\n\t\t/** @param {AbbreviationNode} node */\n\t\ttree.findAll(function(node) {\n\t\t\tif (node._name && (match = node._name.match(re))) {\n\t\t\t\tvar wordCound = match[2] || 30;\n\t\t\t\tvar lang = match[1] || prefs.get('lorem.defaultLang') || 'en';\n\t\t\t\t\n\t\t\t\t// force node name resolving if node should be repeated\n\t\t\t\t// or contains attributes. In this case, node should be outputed\n\t\t\t\t// as tag, otherwise as text-only node\n\t\t\t\tnode._name = '';\n\t\t\t\tnode.data('forceNameResolving', node.isRepeating() || node.attributeList().length);\n\t\t\t\tnode.data('pasteOverwrites', true);\n\t\t\t\tnode.data('paste', function(i, content) {\n\t\t\t\t\treturn paragraph(lang, wordCound, !i);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t});\n\t\n\t/**\n\t * Returns random integer between <code>from</code> and <code>to</code> values\n\t * @param {Number} from\n\t * @param {Number} to\n\t * @returns {Number}\n\t */\n\tfunction randint(from, to) {\n\t\treturn Math.round(Math.random() * (to - from) + from);\n\t}\n\t\n\t/**\n\t * @param {Array} arr\n\t * @param {Number} count\n\t * @returns {Array}\n\t */\n\tfunction sample(arr, count) {\n\t\tvar len = arr.length;\n\t\tvar iterations = Math.min(len, count);\n\t\tvar result = [];\n\t\twhile (result.length < iterations) {\n\t\t\tvar randIx = randint(0, len - 1);\n\t\t\tif (!_.include(result, randIx))\n\t\t\t\tresult.push(randIx);\n\t\t}\n\t\t\n\t\treturn _.map(result, function(ix) {\n\t\t\treturn arr[ix];\n\t\t});\n\t}\n\t\n\tfunction choice(val) {\n\t\tif (_.isString(val))\n\t\t\treturn val.charAt(randint(0, val.length - 1));\n\t\t\n\t\treturn val[randint(0, val.length - 1)];\n\t}\n\t\n\tfunction sentence(words, end) {\n\t\tif (words.length) {\n\t\t\twords[0] = words[0].charAt(0).toUpperCase() + words[0].substring(1);\n\t\t}\n\t\t\n\t\treturn words.join(' ') + (end || choice('?!...')); // more dots that question marks\n\t}\n\t\n\t/**\n\t * Insert commas at randomly selected words. This function modifies values\n\t * inside <code>words</code> array \n\t * @param {Array} words\n\t */\n\tfunction insertCommas(words) {\n\t\tvar len = words.length;\n\t\tvar totalCommas = 0;\n\t\t\n\t\tif (len > 3 && len <= 6) {\n\t\t\ttotalCommas = randint(0, 1);\n\t\t} else if (len > 6 && len <= 12) {\n\t\t\ttotalCommas = randint(0, 2);\n\t\t} else {\n\t\t\ttotalCommas = randint(1, 4);\n\t\t}\n\n\t\t_.each(_.range(totalCommas), function(ix) {\n\t\t\tif (ix < words.length - 1) {\n\t\t\t\twords[ix] += ',';\n\t\t\t}\n\t\t});\n\t}\n\t\n\t/**\n\t * Generate a paragraph of \"Lorem ipsum\" text\n\t * @param {Number} wordCount Words count in paragraph\n\t * @param {Boolean} startWithCommon Should paragraph start with common \n\t * \"lorem ipsum\" sentence.\n\t * @returns {String}\n\t */\n\tfunction paragraph(lang, wordCount, startWithCommon) {\n\t\tvar data = langs[lang];\n\t\tif (!data) {\n\t\t\treturn '';\n\t\t}\n\n\t\tvar result = [];\n\t\tvar totalWords = 0;\n\t\tvar words;\n\t\t\n\t\twordCount = parseInt(wordCount, 10);\n\t\t\n\t\tif (startWithCommon && data.common) {\n\t\t\twords = data.common.slice(0, wordCount);\n\t\t\tif (words.length > 5)\n\t\t\t\twords[4] += ',';\n\t\t\ttotalWords += words.length;\n\t\t\tresult.push(sentence(words, '.'));\n\t\t}\n\t\t\n\t\twhile (totalWords < wordCount) {\n\t\t\twords = sample(data.words, Math.min(randint(3, 12) * randint(1, 5), wordCount - totalWords));\n\t\t\ttotalWords += words.length;\n\t\t\tinsertCommas(words);\n\t\t\tresult.push(sentence(words));\n\t\t}\n\t\t\n\t\treturn result.join(' ');\n\t}\n\n\treturn {\n\t\t/**\n\t\t * Adds new language words for Lorem Ipsum generator\n\t\t * @param {String} lang Two-letter lang definition\n\t\t * @param {Object} data Words for language. Maight be either a space-separated \n\t\t * list of words (String), Array of words or object with <code>text</code> and\n\t\t * <code>common</code> properties\n\t\t */\n\t\taddLang: function(lang, data) {\n\t\t\tif (_.isString(data)) {\n\t\t\t\tdata = {words: _.compact(data.split(' '))};\n\t\t\t} else if (_.isArray(data)) {\n\t\t\t\tdata = {words: data};\n\t\t\t}\n\n\t\t\tlangs[lang] = data;\n\t\t}\n\t}\n});/**\n * A back-end bootstrap module with commonly used methods for loading user data\n * @param {Function} require\n * @param {Underscore} _  \n */\nemmet.define('bootstrap', function(require, _) {\nvar snippets = {\n\t\"variables\": {\n\t\t\"lang\": \"en\",\n\t\t\"locale\": \"en-US\",\n\t\t\"charset\": \"UTF-8\",\n\t\t\"indentation\": \"\\t\",\n\t\t\"newline\": \"\\n\"\n\t},\n\t\n\t\"css\": {\n\t\t\"filters\": \"html\",\n\t\t\"snippets\": {\n\t\t\t\"@i\": \"@import url(|);\",\n\t\t\t\"@import\": \"@import url(|);\",\n\t\t\t\"@m\": \"@media ${1:screen} {\\n\\t|\\n}\",\n\t\t\t\"@media\": \"@media ${1:screen} {\\n\\t|\\n}\",\n\t\t\t\"@f\": \"@font-face {\\n\\tfont-family:|;\\n\\tsrc:url(|);\\n}\",\n\t\t\t\"@f+\": \"@font-face {\\n\\tfont-family: '${1:FontName}';\\n\\tsrc: url('${2:FileName}.eot');\\n\\tsrc: url('${2:FileName}.eot?#iefix') format('embedded-opentype'),\\n\\t\\t url('${2:FileName}.woff') format('woff'),\\n\\t\\t url('${2:FileName}.ttf') format('truetype'),\\n\\t\\t url('${2:FileName}.svg#${1:FontName}') format('svg');\\n\\tfont-style: ${3:normal};\\n\\tfont-weight: ${4:normal};\\n}\",\n\n\t\t\t\"@kf\": \"@-webkit-keyframes ${1:identifier} {\\n\\t${2:from} { ${3} }${6}\\n\\t${4:to} { ${5} }\\n}\\n@-o-keyframes ${1:identifier} {\\n\\t${2:from} { ${3} }${6}\\n\\t${4:to} { ${5} }\\n}\\n@-moz-keyframes ${1:identifier} {\\n\\t${2:from} { ${3} }${6}\\n\\t${4:to} { ${5} }\\n}\\n@keyframes ${1:identifier} {\\n\\t${2:from} { ${3} }${6}\\n\\t${4:to} { ${5} }\\n}\",\n\n\n\t\t\t\"anim\": \"animation:|;\",\n\t\t\t\"anim-\": \"animation:${1:name} ${2:duration} ${3:timing-function} ${4:delay} ${5:iteration-count} ${6:direction} ${7:fill-mode};\",\n\t\t\t\"animdel\": \"animation-delay:${1:time};\",\n\t\t\t\n\t\t\t\"animdir\": \"animation-direction:${1:normal};\",\n\t\t\t\"animdir:n\": \"animation-direction:normal;\",\n\t\t\t\"animdir:r\": \"animation-direction:reverse;\",\n\t\t\t\"animdir:a\": \"animation-direction:alternate;\",\n\t\t\t\"animdir:ar\": \"animation-direction:alternate-reverse;\",\n\t\t\t\n\t\t\t\"animdur\": \"animation-duration:${1:0}s;\",\n\t\t\t\n\t\t\t\"animfm\": \"animation-fill-mode:${1:both};\",\n\t\t\t\"animfm:f\": \"animation-fill-mode:forwards;\",\n\t\t\t\"animfm:b\": \"animation-fill-mode:backwards;\",\n\t\t\t\"animfm:bt\": \"animation-fill-mode:both;\",\n\t\t\t\"animfm:bh\": \"animation-fill-mode:both;\",\n\t\t\t\n\t\t\t\"animic\": \"animation-iteration-count:${1:1};\",\n\t\t\t\"animic:i\": \"animation-iteration-count:infinite;\",\n\t\t\t\n\t\t\t\"animn\": \"animation-name:${1:none};\",\n\n\t\t\t\"animps\": \"animation-play-state:${1:running};\",\n\t\t\t\"animps:p\": \"animation-play-state:paused;\",\n\t\t\t\"animps:r\": \"animation-play-state:running;\",\n\n\t\t\t\"animtf\": \"animation-timing-function:${1:linear};\",\n\t\t\t\"animtf:e\": \"animation-timing-function:ease;\",\n\t\t\t\"animtf:ei\": \"animation-timing-function:ease-in;\",\n\t\t\t\"animtf:eo\": \"animation-timing-function:ease-out;\",\n\t\t\t\"animtf:eio\": \"animation-timing-function:ease-in-out;\",\n\t\t\t\"animtf:l\": \"animation-timing-function:linear;\",\n\t\t\t\"animtf:cb\": \"animation-timing-function:cubic-bezier(${1:0.1}, ${2:0.7}, ${3:1.0}, ${3:0.1});\",\n\t\t\t\n\t\t\t\"ap\": \"appearance:${none};\",\n\n\t\t\t\"!\": \"!important\",\n\t\t\t\"pos\": \"position:${1:relative};\",\n\t\t\t\"pos:s\": \"position:static;\",\n\t\t\t\"pos:a\": \"position:absolute;\",\n\t\t\t\"pos:r\": \"position:relative;\",\n\t\t\t\"pos:f\": \"position:fixed;\",\n\t\t\t\"t\": \"top:|;\",\n\t\t\t\"t:a\": \"top:auto;\",\n\t\t\t\"r\": \"right:|;\",\n\t\t\t\"r:a\": \"right:auto;\",\n\t\t\t\"b\": \"bottom:|;\",\n\t\t\t\"b:a\": \"bottom:auto;\",\n\t\t\t\"l\": \"left:|;\",\n\t\t\t\"l:a\": \"left:auto;\",\n\t\t\t\"z\": \"z-index:|;\",\n\t\t\t\"z:a\": \"z-index:auto;\",\n\t\t\t\"fl\": \"float:${1:left};\",\n\t\t\t\"fl:n\": \"float:none;\",\n\t\t\t\"fl:l\": \"float:left;\",\n\t\t\t\"fl:r\": \"float:right;\",\n\t\t\t\"cl\": \"clear:${1:both};\",\n\t\t\t\"cl:n\": \"clear:none;\",\n\t\t\t\"cl:l\": \"clear:left;\",\n\t\t\t\"cl:r\": \"clear:right;\",\n\t\t\t\"cl:b\": \"clear:both;\",\n\n\t\t\t\"colm\": \"columns:|;\",\n\t\t\t\"colmc\": \"column-count:|;\",\n\t\t\t\"colmf\": \"column-fill:|;\",\n\t\t\t\"colmg\": \"column-gap:|;\",\n\t\t\t\"colmr\": \"column-rule:|;\",\n\t\t\t\"colmrc\": \"column-rule-color:|;\",\n\t\t\t\"colmrs\": \"column-rule-style:|;\",\n\t\t\t\"colmrw\": \"column-rule-width:|;\",\n\t\t\t\"colms\": \"column-span:|;\",\n\t\t\t\"colmw\": \"column-width:|;\",\n\n\t\t\t\"d\": \"display:${1:block};\",\n\t\t\t\"d:n\": \"display:none;\",\n\t\t\t\"d:b\": \"display:block;\",\n\t\t\t\"d:i\": \"display:inline;\",\n\t\t\t\"d:ib\": \"display:inline-block;\",\n\t\t\t\"d:ib+\": \"display: inline-block;\\n*display: inline;\\n*zoom: 1;\",\n\t\t\t\"d:li\": \"display:list-item;\",\n\t\t\t\"d:ri\": \"display:run-in;\",\n\t\t\t\"d:cp\": \"display:compact;\",\n\t\t\t\"d:tb\": \"display:table;\",\n\t\t\t\"d:itb\": \"display:inline-table;\",\n\t\t\t\"d:tbcp\": \"display:table-caption;\",\n\t\t\t\"d:tbcl\": \"display:table-column;\",\n\t\t\t\"d:tbclg\": \"display:table-column-group;\",\n\t\t\t\"d:tbhg\": \"display:table-header-group;\",\n\t\t\t\"d:tbfg\": \"display:table-footer-group;\",\n\t\t\t\"d:tbr\": \"display:table-row;\",\n\t\t\t\"d:tbrg\": \"display:table-row-group;\",\n\t\t\t\"d:tbc\": \"display:table-cell;\",\n\t\t\t\"d:rb\": \"display:ruby;\",\n\t\t\t\"d:rbb\": \"display:ruby-base;\",\n\t\t\t\"d:rbbg\": \"display:ruby-base-group;\",\n\t\t\t\"d:rbt\": \"display:ruby-text;\",\n\t\t\t\"d:rbtg\": \"display:ruby-text-group;\",\n\t\t\t\"v\": \"visibility:${1:hidden};\",\n\t\t\t\"v:v\": \"visibility:visible;\",\n\t\t\t\"v:h\": \"visibility:hidden;\",\n\t\t\t\"v:c\": \"visibility:collapse;\",\n\t\t\t\"ov\": \"overflow:${1:hidden};\",\n\t\t\t\"ov:v\": \"overflow:visible;\",\n\t\t\t\"ov:h\": \"overflow:hidden;\",\n\t\t\t\"ov:s\": \"overflow:scroll;\",\n\t\t\t\"ov:a\": \"overflow:auto;\",\n\t\t\t\"ovx\": \"overflow-x:${1:hidden};\",\n\t\t\t\"ovx:v\": \"overflow-x:visible;\",\n\t\t\t\"ovx:h\": \"overflow-x:hidden;\",\n\t\t\t\"ovx:s\": \"overflow-x:scroll;\",\n\t\t\t\"ovx:a\": \"overflow-x:auto;\",\n\t\t\t\"ovy\": \"overflow-y:${1:hidden};\",\n\t\t\t\"ovy:v\": \"overflow-y:visible;\",\n\t\t\t\"ovy:h\": \"overflow-y:hidden;\",\n\t\t\t\"ovy:s\": \"overflow-y:scroll;\",\n\t\t\t\"ovy:a\": \"overflow-y:auto;\",\n\t\t\t\"ovs\": \"overflow-style:${1:scrollbar};\",\n\t\t\t\"ovs:a\": \"overflow-style:auto;\",\n\t\t\t\"ovs:s\": \"overflow-style:scrollbar;\",\n\t\t\t\"ovs:p\": \"overflow-style:panner;\",\n\t\t\t\"ovs:m\": \"overflow-style:move;\",\n\t\t\t\"ovs:mq\": \"overflow-style:marquee;\",\n\t\t\t\"zoo\": \"zoom:1;\",\n\t\t\t\"zm\": \"zoom:1;\",\n\t\t\t\"cp\": \"clip:|;\",\n\t\t\t\"cp:a\": \"clip:auto;\",\n\t\t\t\"cp:r\": \"clip:rect(${1:top} ${2:right} ${3:bottom} ${4:left});\",\n\t\t\t\"bxz\": \"box-sizing:${1:border-box};\",\n\t\t\t\"bxz:cb\": \"box-sizing:content-box;\",\n\t\t\t\"bxz:bb\": \"box-sizing:border-box;\",\n\t\t\t\"bxsh\": \"box-shadow:${1:inset }${2:hoff} ${3:voff} ${4:blur} ${5:color};\",\n\t\t\t\"bxsh:r\": \"box-shadow:${1:inset }${2:hoff} ${3:voff} ${4:blur} ${5:spread }rgb(${6:0}, ${7:0}, ${8:0});\",\n\t\t\t\"bxsh:ra\": \"box-shadow:${1:inset }${2:h} ${3:v} ${4:blur} ${5:spread }rgba(${6:0}, ${7:0}, ${8:0}, .${9:5});\",\n\t\t\t\"bxsh:n\": \"box-shadow:none;\",\n\t\t\t\"m\": \"margin:|;\",\n\t\t\t\"m:a\": \"margin:auto;\",\n\t\t\t\"mt\": \"margin-top:|;\",\n\t\t\t\"mt:a\": \"margin-top:auto;\",\n\t\t\t\"mr\": \"margin-right:|;\",\n\t\t\t\"mr:a\": \"margin-right:auto;\",\n\t\t\t\"mb\": \"margin-bottom:|;\",\n\t\t\t\"mb:a\": \"margin-bottom:auto;\",\n\t\t\t\"ml\": \"margin-left:|;\",\n\t\t\t\"ml:a\": \"margin-left:auto;\",\n\t\t\t\"p\": \"padding:|;\",\n\t\t\t\"pt\": \"padding-top:|;\",\n\t\t\t\"pr\": \"padding-right:|;\",\n\t\t\t\"pb\": \"padding-bottom:|;\",\n\t\t\t\"pl\": \"padding-left:|;\",\n\t\t\t\"w\": \"width:|;\",\n\t\t\t\"w:a\": \"width:auto;\",\n\t\t\t\"h\": \"height:|;\",\n\t\t\t\"h:a\": \"height:auto;\",\n\t\t\t\"maw\": \"max-width:|;\",\n\t\t\t\"maw:n\": \"max-width:none;\",\n\t\t\t\"mah\": \"max-height:|;\",\n\t\t\t\"mah:n\": \"max-height:none;\",\n\t\t\t\"miw\": \"min-width:|;\",\n\t\t\t\"mih\": \"min-height:|;\",\n\t\t\t\"mar\": \"max-resolution:${1:res};\",\n\t\t\t\"mir\": \"min-resolution:${1:res};\",\n\t\t\t\"ori\": \"orientation:|;\",\n\t\t\t\"ori:l\": \"orientation:landscape;\",\n\t\t\t\"ori:p\": \"orientation:portrait;\",\n\t\t\t\"ol\": \"outline:|;\",\n\t\t\t\"ol:n\": \"outline:none;\",\n\t\t\t\"olo\": \"outline-offset:|;\",\n\t\t\t\"olw\": \"outline-width:|;\",\n\t\t\t\"olw:tn\": \"outline-width:thin;\",\n\t\t\t\"olw:m\": \"outline-width:medium;\",\n\t\t\t\"olw:tc\": \"outline-width:thick;\",\n\t\t\t\"ols\": \"outline-style:|;\",\n\t\t\t\"ols:n\": \"outline-style:none;\",\n\t\t\t\"ols:dt\": \"outline-style:dotted;\",\n\t\t\t\"ols:ds\": \"outline-style:dashed;\",\n\t\t\t\"ols:s\": \"outline-style:solid;\",\n\t\t\t\"ols:db\": \"outline-style:double;\",\n\t\t\t\"ols:g\": \"outline-style:groove;\",\n\t\t\t\"ols:r\": \"outline-style:ridge;\",\n\t\t\t\"ols:i\": \"outline-style:inset;\",\n\t\t\t\"ols:o\": \"outline-style:outset;\",\n\t\t\t\"olc\": \"outline-color:#${1:000};\",\n\t\t\t\"olc:i\": \"outline-color:invert;\",\n\t\t\t\"bd\": \"border:|;\",\n\t\t\t\"bd+\": \"border:${1:1px} ${2:solid} ${3:#000};\",\n\t\t\t\"bd:n\": \"border:none;\",\n\t\t\t\"bdbk\": \"border-break:${1:close};\",\n\t\t\t\"bdbk:c\": \"border-break:close;\",\n\t\t\t\"bdcl\": \"border-collapse:|;\",\n\t\t\t\"bdcl:c\": \"border-collapse:collapse;\",\n\t\t\t\"bdcl:s\": \"border-collapse:separate;\",\n\t\t\t\"bdc\": \"border-color:#${1:000};\",\n\t\t\t\"bdc:t\": \"border-color:transparent;\",\n\t\t\t\"bdi\": \"border-image:url(|);\",\n\t\t\t\"bdi:n\": \"border-image:none;\",\n\t\t\t\"bdti\": \"border-top-image:url(|);\",\n\t\t\t\"bdti:n\": \"border-top-image:none;\",\n\t\t\t\"bdri\": \"border-right-image:url(|);\",\n\t\t\t\"bdri:n\": \"border-right-image:none;\",\n\t\t\t\"bdbi\": \"border-bottom-image:url(|);\",\n\t\t\t\"bdbi:n\": \"border-bottom-image:none;\",\n\t\t\t\"bdli\": \"border-left-image:url(|);\",\n\t\t\t\"bdli:n\": \"border-left-image:none;\",\n\t\t\t\"bdci\": \"border-corner-image:url(|);\",\n\t\t\t\"bdci:n\": \"border-corner-image:none;\",\n\t\t\t\"bdci:c\": \"border-corner-image:continue;\",\n\t\t\t\"bdtli\": \"border-top-left-image:url(|);\",\n\t\t\t\"bdtli:n\": \"border-top-left-image:none;\",\n\t\t\t\"bdtli:c\": \"border-top-left-image:continue;\",\n\t\t\t\"bdtri\": \"border-top-right-image:url(|);\",\n\t\t\t\"bdtri:n\": \"border-top-right-image:none;\",\n\t\t\t\"bdtri:c\": \"border-top-right-image:continue;\",\n\t\t\t\"bdbri\": \"border-bottom-right-image:url(|);\",\n\t\t\t\"bdbri:n\": \"border-bottom-right-image:none;\",\n\t\t\t\"bdbri:c\": \"border-bottom-right-image:continue;\",\n\t\t\t\"bdbli\": \"border-bottom-left-image:url(|);\",\n\t\t\t\"bdbli:n\": \"border-bottom-left-image:none;\",\n\t\t\t\"bdbli:c\": \"border-bottom-left-image:continue;\",\n\t\t\t\"bdf\": \"border-fit:${1:repeat};\",\n\t\t\t\"bdf:c\": \"border-fit:clip;\",\n\t\t\t\"bdf:r\": \"border-fit:repeat;\",\n\t\t\t\"bdf:sc\": \"border-fit:scale;\",\n\t\t\t\"bdf:st\": \"border-fit:stretch;\",\n\t\t\t\"bdf:ow\": \"border-fit:overwrite;\",\n\t\t\t\"bdf:of\": \"border-fit:overflow;\",\n\t\t\t\"bdf:sp\": \"border-fit:space;\",\n\t\t\t\"bdlen\": \"border-length:|;\",\n\t\t\t\"bdlen:a\": \"border-length:auto;\",\n\t\t\t\"bdsp\": \"border-spacing:|;\",\n\t\t\t\"bds\": \"border-style:|;\",\n\t\t\t\"bds:n\": \"border-style:none;\",\n\t\t\t\"bds:h\": \"border-style:hidden;\",\n\t\t\t\"bds:dt\": \"border-style:dotted;\",\n\t\t\t\"bds:ds\": \"border-style:dashed;\",\n\t\t\t\"bds:s\": \"border-style:solid;\",\n\t\t\t\"bds:db\": \"border-style:double;\",\n\t\t\t\"bds:dtds\": \"border-style:dot-dash;\",\n\t\t\t\"bds:dtdtds\": \"border-style:dot-dot-dash;\",\n\t\t\t\"bds:w\": \"border-style:wave;\",\n\t\t\t\"bds:g\": \"border-style:groove;\",\n\t\t\t\"bds:r\": \"border-style:ridge;\",\n\t\t\t\"bds:i\": \"border-style:inset;\",\n\t\t\t\"bds:o\": \"border-style:outset;\",\n\t\t\t\"bdw\": \"border-width:|;\",\n\t\t\t\"bdtw\": \"border-top-width:|;\",\n\t\t\t\"bdrw\": \"border-right-width:|;\",\n\t\t\t\"bdbw\": \"border-bottom-width:|;\",\n\t\t\t\"bdlw\": \"border-left-width:|;\",\n\t\t\t\"bdt\": \"border-top:|;\",\n\t\t\t\"bt\": \"border-top:|;\",\n\t\t\t\"bdt+\": \"border-top:${1:1px} ${2:solid} ${3:#000};\",\n\t\t\t\"bdt:n\": \"border-top:none;\",\n\t\t\t\"bdts\": \"border-top-style:|;\",\n\t\t\t\"bdts:n\": \"border-top-style:none;\",\n\t\t\t\"bdtc\": \"border-top-color:#${1:000};\",\n\t\t\t\"bdtc:t\": \"border-top-color:transparent;\",\n\t\t\t\"bdr\": \"border-right:|;\",\n\t\t\t\"br\": \"border-right:|;\",\n\t\t\t\"bdr+\": \"border-right:${1:1px} ${2:solid} ${3:#000};\",\n\t\t\t\"bdr:n\": \"border-right:none;\",\n\t\t\t\"bdrst\": \"border-right-style:|;\",\n\t\t\t\"bdrst:n\": \"border-right-style:none;\",\n\t\t\t\"bdrc\": \"border-right-color:#${1:000};\",\n\t\t\t\"bdrc:t\": \"border-right-color:transparent;\",\n\t\t\t\"bdb\": \"border-bottom:|;\",\n\t\t\t\"bb\": \"border-bottom:|;\",\n\t\t\t\"bdb+\": \"border-bottom:${1:1px} ${2:solid} ${3:#000};\",\n\t\t\t\"bdb:n\": \"border-bottom:none;\",\n\t\t\t\"bdbs\": \"border-bottom-style:|;\",\n\t\t\t\"bdbs:n\": \"border-bottom-style:none;\",\n\t\t\t\"bdbc\": \"border-bottom-color:#${1:000};\",\n\t\t\t\"bdbc:t\": \"border-bottom-color:transparent;\",\n\t\t\t\"bdl\": \"border-left:|;\",\n\t\t\t\"bl\": \"border-left:|;\",\n\t\t\t\"bdl+\": \"border-left:${1:1px} ${2:solid} ${3:#000};\",\n\t\t\t\"bdl:n\": \"border-left:none;\",\n\t\t\t\"bdls\": \"border-left-style:|;\",\n\t\t\t\"bdls:n\": \"border-left-style:none;\",\n\t\t\t\"bdlc\": \"border-left-color:#${1:000};\",\n\t\t\t\"bdlc:t\": \"border-left-color:transparent;\",\n\t\t\t\"bdrs\": \"border-radius:|;\",\n\t\t\t\"bdtrrs\": \"border-top-right-radius:|;\",\n\t\t\t\"bdtlrs\": \"border-top-left-radius:|;\",\n\t\t\t\"bdbrrs\": \"border-bottom-right-radius:|;\",\n\t\t\t\"bdblrs\": \"border-bottom-left-radius:|;\",\n\t\t\t\"bg\": \"background:#${1:000};\",\n\t\t\t\"bg+\": \"background:${1:#fff} url(${2}) ${3:0} ${4:0} ${5:no-repeat};\",\n\t\t\t\"bg:n\": \"background:none;\",\n\t\t\t\"bg:ie\": \"filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src='${1:x}.png',sizingMethod='${2:crop}');\",\n\t\t\t\"bgc\": \"background-color:#${1:fff};\",\n\t\t\t\"bgc:t\": \"background-color:transparent;\",\n\t\t\t\"bgi\": \"background-image:url(|);\",\n\t\t\t\"bgi:n\": \"background-image:none;\",\n\t\t\t\"bgr\": \"background-repeat:|;\",\n\t\t\t\"bgr:n\": \"background-repeat:no-repeat;\",\n\t\t\t\"bgr:x\": \"background-repeat:repeat-x;\",\n\t\t\t\"bgr:y\": \"background-repeat:repeat-y;\",\n\t\t\t\"bgr:sp\": \"background-repeat:space;\",\n\t\t\t\"bgr:rd\": \"background-repeat:round;\",\n\t\t\t\"bga\": \"background-attachment:|;\",\n\t\t\t\"bga:f\": \"background-attachment:fixed;\",\n\t\t\t\"bga:s\": \"background-attachment:scroll;\",\n\t\t\t\"bgp\": \"background-position:${1:0} ${2:0};\",\n\t\t\t\"bgpx\": \"background-position-x:|;\",\n\t\t\t\"bgpy\": \"background-position-y:|;\",\n\t\t\t\"bgbk\": \"background-break:|;\",\n\t\t\t\"bgbk:bb\": \"background-break:bounding-box;\",\n\t\t\t\"bgbk:eb\": \"background-break:each-box;\",\n\t\t\t\"bgbk:c\": \"background-break:continuous;\",\n\t\t\t\"bgcp\": \"background-clip:${1:padding-box};\",\n\t\t\t\"bgcp:bb\": \"background-clip:border-box;\",\n\t\t\t\"bgcp:pb\": \"background-clip:padding-box;\",\n\t\t\t\"bgcp:cb\": \"background-clip:content-box;\",\n\t\t\t\"bgcp:nc\": \"background-clip:no-clip;\",\n\t\t\t\"bgo\": \"background-origin:|;\",\n\t\t\t\"bgo:pb\": \"background-origin:padding-box;\",\n\t\t\t\"bgo:bb\": \"background-origin:border-box;\",\n\t\t\t\"bgo:cb\": \"background-origin:content-box;\",\n\t\t\t\"bgsz\": \"background-size:|;\",\n\t\t\t\"bgsz:a\": \"background-size:auto;\",\n\t\t\t\"bgsz:ct\": \"background-size:contain;\",\n\t\t\t\"bgsz:cv\": \"background-size:cover;\",\n\t\t\t\"c\": \"color:#${1:000};\",\n\t\t\t\"c:r\": \"color:rgb(${1:0}, ${2:0}, ${3:0});\",\n\t\t\t\"c:ra\": \"color:rgba(${1:0}, ${2:0}, ${3:0}, .${4:5});\",\n\t\t\t\"cm\": \"/* |${child} */\",\n\t\t\t\"cnt\": \"content:'|';\",\n\t\t\t\"cnt:n\": \"content:normal;\",\n\t\t\t\"cnt:oq\": \"content:open-quote;\",\n\t\t\t\"cnt:noq\": \"content:no-open-quote;\",\n\t\t\t\"cnt:cq\": \"content:close-quote;\",\n\t\t\t\"cnt:ncq\": \"content:no-close-quote;\",\n\t\t\t\"cnt:a\": \"content:attr(|);\",\n\t\t\t\"cnt:c\": \"content:counter(|);\",\n\t\t\t\"cnt:cs\": \"content:counters(|);\",\n\n\n\t\t\t\"tbl\": \"table-layout:|;\",\n\t\t\t\"tbl:a\": \"table-layout:auto;\",\n\t\t\t\"tbl:f\": \"table-layout:fixed;\",\n\t\t\t\"cps\": \"caption-side:|;\",\n\t\t\t\"cps:t\": \"caption-side:top;\",\n\t\t\t\"cps:b\": \"caption-side:bottom;\",\n\t\t\t\"ec\": \"empty-cells:|;\",\n\t\t\t\"ec:s\": \"empty-cells:show;\",\n\t\t\t\"ec:h\": \"empty-cells:hide;\",\n\t\t\t\"lis\": \"list-style:|;\",\n\t\t\t\"lis:n\": \"list-style:none;\",\n\t\t\t\"lisp\": \"list-style-position:|;\",\n\t\t\t\"lisp:i\": \"list-style-position:inside;\",\n\t\t\t\"lisp:o\": \"list-style-position:outside;\",\n\t\t\t\"list\": \"list-style-type:|;\",\n\t\t\t\"list:n\": \"list-style-type:none;\",\n\t\t\t\"list:d\": \"list-style-type:disc;\",\n\t\t\t\"list:c\": \"list-style-type:circle;\",\n\t\t\t\"list:s\": \"list-style-type:square;\",\n\t\t\t\"list:dc\": \"list-style-type:decimal;\",\n\t\t\t\"list:dclz\": \"list-style-type:decimal-leading-zero;\",\n\t\t\t\"list:lr\": \"list-style-type:lower-roman;\",\n\t\t\t\"list:ur\": \"list-style-type:upper-roman;\",\n\t\t\t\"lisi\": \"list-style-image:|;\",\n\t\t\t\"lisi:n\": \"list-style-image:none;\",\n\t\t\t\"q\": \"quotes:|;\",\n\t\t\t\"q:n\": \"quotes:none;\",\n\t\t\t\"q:ru\": \"quotes:'\\\\00AB' '\\\\00BB' '\\\\201E' '\\\\201C';\",\n\t\t\t\"q:en\": \"quotes:'\\\\201C' '\\\\201D' '\\\\2018' '\\\\2019';\",\n\t\t\t\"ct\": \"content:|;\",\n\t\t\t\"ct:n\": \"content:normal;\",\n\t\t\t\"ct:oq\": \"content:open-quote;\",\n\t\t\t\"ct:noq\": \"content:no-open-quote;\",\n\t\t\t\"ct:cq\": \"content:close-quote;\",\n\t\t\t\"ct:ncq\": \"content:no-close-quote;\",\n\t\t\t\"ct:a\": \"content:attr(|);\",\n\t\t\t\"ct:c\": \"content:counter(|);\",\n\t\t\t\"ct:cs\": \"content:counters(|);\",\n\t\t\t\"coi\": \"counter-increment:|;\",\n\t\t\t\"cor\": \"counter-reset:|;\",\n\t\t\t\"va\": \"vertical-align:${1:top};\",\n\t\t\t\"va:sup\": \"vertical-align:super;\",\n\t\t\t\"va:t\": \"vertical-align:top;\",\n\t\t\t\"va:tt\": \"vertical-align:text-top;\",\n\t\t\t\"va:m\": \"vertical-align:middle;\",\n\t\t\t\"va:bl\": \"vertical-align:baseline;\",\n\t\t\t\"va:b\": \"vertical-align:bottom;\",\n\t\t\t\"va:tb\": \"vertical-align:text-bottom;\",\n\t\t\t\"va:sub\": \"vertical-align:sub;\",\n\t\t\t\"ta\": \"text-align:${1:left};\",\n\t\t\t\"ta:l\": \"text-align:left;\",\n\t\t\t\"ta:c\": \"text-align:center;\",\n\t\t\t\"ta:r\": \"text-align:right;\",\n\t\t\t\"ta:j\": \"text-align:justify;\",\n\t\t\t\"ta-lst\": \"text-align-last:|;\",\n\t\t\t\"tal:a\": \"text-align-last:auto;\",\n\t\t\t\"tal:l\": \"text-align-last:left;\",\n\t\t\t\"tal:c\": \"text-align-last:center;\",\n\t\t\t\"tal:r\": \"text-align-last:right;\",\n\t\t\t\"td\": \"text-decoration:${1:none};\",\n\t\t\t\"td:n\": \"text-decoration:none;\",\n\t\t\t\"td:u\": \"text-decoration:underline;\",\n\t\t\t\"td:o\": \"text-decoration:overline;\",\n\t\t\t\"td:l\": \"text-decoration:line-through;\",\n\t\t\t\"te\": \"text-emphasis:|;\",\n\t\t\t\"te:n\": \"text-emphasis:none;\",\n\t\t\t\"te:ac\": \"text-emphasis:accent;\",\n\t\t\t\"te:dt\": \"text-emphasis:dot;\",\n\t\t\t\"te:c\": \"text-emphasis:circle;\",\n\t\t\t\"te:ds\": \"text-emphasis:disc;\",\n\t\t\t\"te:b\": \"text-emphasis:before;\",\n\t\t\t\"te:a\": \"text-emphasis:after;\",\n\t\t\t\"th\": \"text-height:|;\",\n\t\t\t\"th:a\": \"text-height:auto;\",\n\t\t\t\"th:f\": \"text-height:font-size;\",\n\t\t\t\"th:t\": \"text-height:text-size;\",\n\t\t\t\"th:m\": \"text-height:max-size;\",\n\t\t\t\"ti\": \"text-indent:|;\",\n\t\t\t\"ti:-\": \"text-indent:-9999px;\",\n\t\t\t\"tj\": \"text-justify:|;\",\n\t\t\t\"tj:a\": \"text-justify:auto;\",\n\t\t\t\"tj:iw\": \"text-justify:inter-word;\",\n\t\t\t\"tj:ii\": \"text-justify:inter-ideograph;\",\n\t\t\t\"tj:ic\": \"text-justify:inter-cluster;\",\n\t\t\t\"tj:d\": \"text-justify:distribute;\",\n\t\t\t\"tj:k\": \"text-justify:kashida;\",\n\t\t\t\"tj:t\": \"text-justify:tibetan;\",\n\t\t\t\"tov\": \"text-overflow:${ellipsis};\",\n\t\t\t\"tov:e\": \"text-overflow:ellipsis;\",\n\t\t\t\"tov:c\": \"text-overflow:clip;\",\n\t\t\t\"to\": \"text-outline:|;\",\n\t\t\t\"to+\": \"text-outline:${1:0} ${2:0} ${3:#000};\",\n\t\t\t\"to:n\": \"text-outline:none;\",\n\t\t\t\"tr\": \"text-replace:|;\",\n\t\t\t\"tr:n\": \"text-replace:none;\",\n\t\t\t\"tt\": \"text-transform:${1:uppercase};\",\n\t\t\t\"tt:n\": \"text-transform:none;\",\n\t\t\t\"tt:c\": \"text-transform:capitalize;\",\n\t\t\t\"tt:u\": \"text-transform:uppercase;\",\n\t\t\t\"tt:l\": \"text-transform:lowercase;\",\n\t\t\t\"tw\": \"text-wrap:|;\",\n\t\t\t\"tw:n\": \"text-wrap:normal;\",\n\t\t\t\"tw:no\": \"text-wrap:none;\",\n\t\t\t\"tw:u\": \"text-wrap:unrestricted;\",\n\t\t\t\"tw:s\": \"text-wrap:suppress;\",\n\t\t\t\"tsh\": \"text-shadow:${1:hoff} ${2:voff} ${3:blur} ${4:#000};\",\n\t\t\t\"tsh:r\": \"text-shadow:${1:h} ${2:v} ${3:blur} rgb(${4:0}, ${5:0}, ${6:0});\",\n\t\t\t\"tsh:ra\": \"text-shadow:${1:h} ${2:v} ${3:blur} rgba(${4:0}, ${5:0}, ${6:0}, .${7:5});\",\n\t\t\t\"tsh+\": \"text-shadow:${1:0} ${2:0} ${3:0} ${4:#000};\",\n\t\t\t\"tsh:n\": \"text-shadow:none;\",\n\t\t\t\"trf\": \"transform:|;\",\n\t\t\t\"trf:skx\": \"transform: skewX(${1:angle});\",\n\t\t\t\"trf:sky\": \"transform: skewY(${1:angle});\",\n\t\t\t\"trf:sc\": \"transform: scale(${1:x}, ${2:y});\",\n\t\t\t\"trf:scx\": \"transform: scaleX(${1:x});\",\n\t\t\t\"trf:scy\": \"transform: scaleY(${1:y});\",\n\t\t\t\"trf:r\": \"transform: rotate(${1:angle});\",\n\t\t\t\"trf:t\": \"transform: translate(${1:x}, ${2:y});\",\n\t\t\t\"trf:tx\": \"transform: translateX(${1:x});\",\n\t\t\t\"trf:ty\": \"transform: translateY(${1:y});\",\n\t\t\t\"trfo\": \"transform-origin:|;\",\n\t\t\t\"trfs\": \"transform-style:${1:preserve-3d};\",\n\t\t\t\"trs\": \"transition:${1:prop} ${2:time};\",\n\t\t\t\"trsde\": \"transition-delay:${1:time};\",\n\t\t\t\"trsdu\": \"transition-duration:${1:time};\",\n\t\t\t\"trsp\": \"transition-property:${1:prop};\",\n\t\t\t\"trstf\": \"transition-timing-function:${1:tfunc};\",\n\t\t\t\"lh\": \"line-height:|;\",\n\t\t\t\"whs\": \"white-space:|;\",\n\t\t\t\"whs:n\": \"white-space:normal;\",\n\t\t\t\"whs:p\": \"white-space:pre;\",\n\t\t\t\"whs:nw\": \"white-space:nowrap;\",\n\t\t\t\"whs:pw\": \"white-space:pre-wrap;\",\n\t\t\t\"whs:pl\": \"white-space:pre-line;\",\n\t\t\t\"whsc\": \"white-space-collapse:|;\",\n\t\t\t\"whsc:n\": \"white-space-collapse:normal;\",\n\t\t\t\"whsc:k\": \"white-space-collapse:keep-all;\",\n\t\t\t\"whsc:l\": \"white-space-collapse:loose;\",\n\t\t\t\"whsc:bs\": \"white-space-collapse:break-strict;\",\n\t\t\t\"whsc:ba\": \"white-space-collapse:break-all;\",\n\t\t\t\"wob\": \"word-break:|;\",\n\t\t\t\"wob:n\": \"word-break:normal;\",\n\t\t\t\"wob:k\": \"word-break:keep-all;\",\n\t\t\t\"wob:ba\": \"word-break:break-all;\",\n\t\t\t\"wos\": \"word-spacing:|;\",\n\t\t\t\"wow\": \"word-wrap:|;\",\n\t\t\t\"wow:nm\": \"word-wrap:normal;\",\n\t\t\t\"wow:n\": \"word-wrap:none;\",\n\t\t\t\"wow:u\": \"word-wrap:unrestricted;\",\n\t\t\t\"wow:s\": \"word-wrap:suppress;\",\n\t\t\t\"wow:b\": \"word-wrap:break-word;\",\n\t\t\t\"wm\": \"writing-mode:${1:lr-tb};\",\n\t\t\t\"wm:lrt\": \"writing-mode:lr-tb;\",\n\t\t\t\"wm:lrb\": \"writing-mode:lr-bt;\",\n\t\t\t\"wm:rlt\": \"writing-mode:rl-tb;\",\n\t\t\t\"wm:rlb\": \"writing-mode:rl-bt;\",\n\t\t\t\"wm:tbr\": \"writing-mode:tb-rl;\",\n\t\t\t\"wm:tbl\": \"writing-mode:tb-lr;\",\n\t\t\t\"wm:btl\": \"writing-mode:bt-lr;\",\n\t\t\t\"wm:btr\": \"writing-mode:bt-rl;\",\n\t\t\t\"lts\": \"letter-spacing:|;\",\n\t\t\t\"lts-n\": \"letter-spacing:normal;\",\n\t\t\t\"f\": \"font:|;\",\n\t\t\t\"f+\": \"font:${1:1em} ${2:Arial,sans-serif};\",\n\t\t\t\"fw\": \"font-weight:|;\",\n\t\t\t\"fw:n\": \"font-weight:normal;\",\n\t\t\t\"fw:b\": \"font-weight:bold;\",\n\t\t\t\"fw:br\": \"font-weight:bolder;\",\n\t\t\t\"fw:lr\": \"font-weight:lighter;\",\n\t\t\t\"fs\": \"font-style:${italic};\",\n\t\t\t\"fs:n\": \"font-style:normal;\",\n\t\t\t\"fs:i\": \"font-style:italic;\",\n\t\t\t\"fs:o\": \"font-style:oblique;\",\n\t\t\t\"fv\": \"font-variant:|;\",\n\t\t\t\"fv:n\": \"font-variant:normal;\",\n\t\t\t\"fv:sc\": \"font-variant:small-caps;\",\n\t\t\t\"fz\": \"font-size:|;\",\n\t\t\t\"fza\": \"font-size-adjust:|;\",\n\t\t\t\"fza:n\": \"font-size-adjust:none;\",\n\t\t\t\"ff\": \"font-family:|;\",\n\t\t\t\"ff:s\": \"font-family:serif;\",\n\t\t\t\"ff:ss\": \"font-family:sans-serif;\",\n\t\t\t\"ff:c\": \"font-family:cursive;\",\n\t\t\t\"ff:f\": \"font-family:fantasy;\",\n\t\t\t\"ff:m\": \"font-family:monospace;\",\n\t\t\t\"ff:a\": \"font-family: Arial, \\\"Helvetica Neue\\\", Helvetica, sans-serif;\",\n\t\t\t\"ff:t\": \"font-family: \\\"Times New Roman\\\", Times, Baskerville, Georgia, serif;\",\n\t\t\t\"ff:v\": \"font-family: Verdana, Geneva, sans-serif;\",\n\t\t\t\"fef\": \"font-effect:|;\",\n\t\t\t\"fef:n\": \"font-effect:none;\",\n\t\t\t\"fef:eg\": \"font-effect:engrave;\",\n\t\t\t\"fef:eb\": \"font-effect:emboss;\",\n\t\t\t\"fef:o\": \"font-effect:outline;\",\n\t\t\t\"fem\": \"font-emphasize:|;\",\n\t\t\t\"femp\": \"font-emphasize-position:|;\",\n\t\t\t\"femp:b\": \"font-emphasize-position:before;\",\n\t\t\t\"femp:a\": \"font-emphasize-position:after;\",\n\t\t\t\"fems\": \"font-emphasize-style:|;\",\n\t\t\t\"fems:n\": \"font-emphasize-style:none;\",\n\t\t\t\"fems:ac\": \"font-emphasize-style:accent;\",\n\t\t\t\"fems:dt\": \"font-emphasize-style:dot;\",\n\t\t\t\"fems:c\": \"font-emphasize-style:circle;\",\n\t\t\t\"fems:ds\": \"font-emphasize-style:disc;\",\n\t\t\t\"fsm\": \"font-smooth:|;\",\n\t\t\t\"fsm:a\": \"font-smooth:auto;\",\n\t\t\t\"fsm:n\": \"font-smooth:never;\",\n\t\t\t\"fsm:aw\": \"font-smooth:always;\",\n\t\t\t\"fst\": \"font-stretch:|;\",\n\t\t\t\"fst:n\": \"font-stretch:normal;\",\n\t\t\t\"fst:uc\": \"font-stretch:ultra-condensed;\",\n\t\t\t\"fst:ec\": \"font-stretch:extra-condensed;\",\n\t\t\t\"fst:c\": \"font-stretch:condensed;\",\n\t\t\t\"fst:sc\": \"font-stretch:semi-condensed;\",\n\t\t\t\"fst:se\": \"font-stretch:semi-expanded;\",\n\t\t\t\"fst:e\": \"font-stretch:expanded;\",\n\t\t\t\"fst:ee\": \"font-stretch:extra-expanded;\",\n\t\t\t\"fst:ue\": \"font-stretch:ultra-expanded;\",\n\t\t\t\"op\": \"opacity:|;\",\n\t\t\t\"op+\": \"opacity: $1;\\nfilter: alpha(opacity=$2);\",\n\t\t\t\"op:ie\": \"filter:progid:DXImageTransform.Microsoft.Alpha(Opacity=100);\",\n\t\t\t\"op:ms\": \"-ms-filter:'progid:DXImageTransform.Microsoft.Alpha(Opacity=100)';\",\n\t\t\t\"rsz\": \"resize:|;\",\n\t\t\t\"rsz:n\": \"resize:none;\",\n\t\t\t\"rsz:b\": \"resize:both;\",\n\t\t\t\"rsz:h\": \"resize:horizontal;\",\n\t\t\t\"rsz:v\": \"resize:vertical;\",\n\t\t\t\"cur\": \"cursor:${pointer};\",\n\t\t\t\"cur:a\": \"cursor:auto;\",\n\t\t\t\"cur:d\": \"cursor:default;\",\n\t\t\t\"cur:c\": \"cursor:crosshair;\",\n\t\t\t\"cur:ha\": \"cursor:hand;\",\n\t\t\t\"cur:he\": \"cursor:help;\",\n\t\t\t\"cur:m\": \"cursor:move;\",\n\t\t\t\"cur:p\": \"cursor:pointer;\",\n\t\t\t\"cur:t\": \"cursor:text;\",\n\t\t\t\"pgbb\": \"page-break-before:|;\",\n\t\t\t\"pgbb:au\": \"page-break-before:auto;\",\n\t\t\t\"pgbb:al\": \"page-break-before:always;\",\n\t\t\t\"pgbb:l\": \"page-break-before:left;\",\n\t\t\t\"pgbb:r\": \"page-break-before:right;\",\n\t\t\t\"pgbi\": \"page-break-inside:|;\",\n\t\t\t\"pgbi:au\": \"page-break-inside:auto;\",\n\t\t\t\"pgbi:av\": \"page-break-inside:avoid;\",\n\t\t\t\"pgba\": \"page-break-after:|;\",\n\t\t\t\"pgba:au\": \"page-break-after:auto;\",\n\t\t\t\"pgba:al\": \"page-break-after:always;\",\n\t\t\t\"pgba:l\": \"page-break-after:left;\",\n\t\t\t\"pgba:r\": \"page-break-after:right;\",\n\t\t\t\"orp\": \"orphans:|;\",\n\t\t\t\"us\": \"user-select:${none};\",\n\t\t\t\"wid\": \"widows:|;\",\n\t\t\t\"wfsm\": \"-webkit-font-smoothing:${antialiased};\",\n\t\t\t\"wfsm:a\": \"-webkit-font-smoothing:antialiased;\",\n\t\t\t\"wfsm:s\": \"-webkit-font-smoothing:subpixel-antialiased;\",\n\t\t\t\"wfsm:sa\": \"-webkit-font-smoothing:subpixel-antialiased;\",\n\t\t\t\"wfsm:n\": \"-webkit-font-smoothing:none;\"\n\t\t}\n\t},\n\t\n\t\"html\": {\n\t\t\"filters\": \"html\",\n\t\t\"profile\": \"html\",\n\t\t\"snippets\": {\n\t\t\t\"!!!\":    \"<!doctype html>\",\n\t\t\t\"!!!4t\":  \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.01 Transitional//EN\\\" \\\"http://www.w3.org/TR/html4/loose.dtd\\\">\",\n\t\t\t\"!!!4s\":  \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.01//EN\\\" \\\"http://www.w3.org/TR/html4/strict.dtd\\\">\",\n\t\t\t\"!!!xt\":  \"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\" \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\",\n\t\t\t\"!!!xs\":  \"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Strict//EN\\\" \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\\\">\",\n\t\t\t\"!!!xxs\": \"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.1//EN\\\" \\\"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\\\">\",\n\n\t\t\t\"c\": \"<!-- |${child} -->\",\n\t\t\t\"cc:ie6\": \"<!--[if lte IE 6]>\\n\\t${child}|\\n<![endif]-->\",\n\t\t\t\"cc:ie\": \"<!--[if IE]>\\n\\t${child}|\\n<![endif]-->\",\n\t\t\t\"cc:noie\": \"<!--[if !IE]><!-->\\n\\t${child}|\\n<!--<![endif]-->\"\n\t\t},\n\t\t\n\t\t\"abbreviations\": {\n\t\t\t\"!\": \"html:5\",\n\t\t\t\"a\": \"<a href=\\\"\\\">\",\n\t\t\t\"a:link\": \"<a href=\\\"http://|\\\">\",\n\t\t\t\"a:mail\": \"<a href=\\\"mailto:|\\\">\",\n\t\t\t\"abbr\": \"<abbr title=\\\"\\\">\",\n\t\t\t\"acronym\": \"<acronym title=\\\"\\\">\",\n\t\t\t\"base\": \"<base href=\\\"\\\" />\",\n\t\t\t\"basefont\": \"<basefont/>\",\n\t\t\t\"br\": \"<br/>\",\n\t\t\t\"frame\": \"<frame/>\",\n\t\t\t\"hr\": \"<hr/>\",\n\t\t\t\"bdo\": \"<bdo dir=\\\"\\\">\",\n\t\t\t\"bdo:r\": \"<bdo dir=\\\"rtl\\\">\",\n\t\t\t\"bdo:l\": \"<bdo dir=\\\"ltr\\\">\",\n\t\t\t\"col\": \"<col/>\",\n\t\t\t\"link\": \"<link rel=\\\"stylesheet\\\" href=\\\"\\\" />\",\n\t\t\t\"link:css\": \"<link rel=\\\"stylesheet\\\" href=\\\"${1:style}.css\\\" />\",\n\t\t\t\"link:print\": \"<link rel=\\\"stylesheet\\\" href=\\\"${1:print}.css\\\" media=\\\"print\\\" />\",\n\t\t\t\"link:favicon\": \"<link rel=\\\"shortcut icon\\\" type=\\\"image/x-icon\\\" href=\\\"${1:favicon.ico}\\\" />\",\n\t\t\t\"link:touch\": \"<link rel=\\\"apple-touch-icon\\\" href=\\\"${1:favicon.png}\\\" />\",\n\t\t\t\"link:rss\": \"<link rel=\\\"alternate\\\" type=\\\"application/rss+xml\\\" title=\\\"RSS\\\" href=\\\"${1:rss.xml}\\\" />\",\n\t\t\t\"link:atom\": \"<link rel=\\\"alternate\\\" type=\\\"application/atom+xml\\\" title=\\\"Atom\\\" href=\\\"${1:atom.xml}\\\" />\",\n\t\t\t\"meta\": \"<meta/>\",\n\t\t\t\"meta:utf\": \"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html;charset=UTF-8\\\" />\",\n\t\t\t\"meta:win\": \"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html;charset=windows-1251\\\" />\",\n\t\t\t\"meta:vp\": \"<meta name=\\\"viewport\\\" content=\\\"width=${1:device-width}, user-scalable=${2:no}, initial-scale=${3:1.0}, maximum-scale=${4:1.0}, minimum-scale=${5:1.0}\\\" />\",\n\t\t\t\"meta:compat\": \"<meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"${1:IE=7}\\\" />\",\n\t\t\t\"style\": \"<style>\",\n\t\t\t\"script\": \"<script>\",\n\t\t\t\"script:src\": \"<script src=\\\"\\\">\",\n\t\t\t\"img\": \"<img src=\\\"\\\" alt=\\\"\\\" />\",\n\t\t\t\"iframe\": \"<iframe src=\\\"\\\" frameborder=\\\"0\\\">\",\n\t\t\t\"embed\": \"<embed src=\\\"\\\" type=\\\"\\\" />\",\n\t\t\t\"object\": \"<object data=\\\"\\\" type=\\\"\\\">\",\n\t\t\t\"param\": \"<param name=\\\"\\\" value=\\\"\\\" />\",\n\t\t\t\"map\": \"<map name=\\\"\\\">\",\n\t\t\t\"area\": \"<area shape=\\\"\\\" coords=\\\"\\\" href=\\\"\\\" alt=\\\"\\\" />\",\n\t\t\t\"area:d\": \"<area shape=\\\"default\\\" href=\\\"\\\" alt=\\\"\\\" />\",\n\t\t\t\"area:c\": \"<area shape=\\\"circle\\\" coords=\\\"\\\" href=\\\"\\\" alt=\\\"\\\" />\",\n\t\t\t\"area:r\": \"<area shape=\\\"rect\\\" coords=\\\"\\\" href=\\\"\\\" alt=\\\"\\\" />\",\n\t\t\t\"area:p\": \"<area shape=\\\"poly\\\" coords=\\\"\\\" href=\\\"\\\" alt=\\\"\\\" />\",\n\t\t\t\"form\": \"<form action=\\\"\\\">\",\n\t\t\t\"form:get\": \"<form action=\\\"\\\" method=\\\"get\\\">\",\n\t\t\t\"form:post\": \"<form action=\\\"\\\" method=\\\"post\\\">\",\n\t\t\t\"label\": \"<label for=\\\"\\\">\",\n\t\t\t\"input\": \"<input type=\\\"${1:text}\\\" />\",\n\t\t\t\"inp\": \"<input type=\\\"${1:text}\\\" name=\\\"\\\" id=\\\"\\\" />\",\n\t\t\t\"input:hidden\": \"input[type=hidden name]\",\n\t\t\t\"input:h\": \"input:hidden\",\n\t\t\t\"input:text\": \"inp\",\n\t\t\t\"input:t\": \"inp\",\n\t\t\t\"input:search\": \"inp[type=search]\",\n\t\t\t\"input:email\": \"inp[type=email]\",\n\t\t\t\"input:url\": \"inp[type=url]\",\n\t\t\t\"input:password\": \"inp[type=password]\",\n\t\t\t\"input:p\": \"input:password\",\n\t\t\t\"input:datetime\": \"inp[type=datetime]\",\n\t\t\t\"input:date\": \"inp[type=date]\",\n\t\t\t\"input:datetime-local\": \"inp[type=datetime-local]\",\n\t\t\t\"input:month\": \"inp[type=month]\",\n\t\t\t\"input:week\": \"inp[type=week]\",\n\t\t\t\"input:time\": \"inp[type=time]\",\n\t\t\t\"input:number\": \"inp[type=number]\",\n\t\t\t\"input:color\": \"inp[type=color]\",\n\t\t\t\"input:checkbox\": \"inp[type=checkbox]\",\n\t\t\t\"input:c\": \"input:checkbox\",\n\t\t\t\"input:radio\": \"inp[type=radio]\",\n\t\t\t\"input:r\": \"input:radio\",\n\t\t\t\"input:range\": \"inp[type=range]\",\n\t\t\t\"input:file\": \"inp[type=file]\",\n\t\t\t\"input:f\": \"input:file\",\n\t\t\t\"input:submit\": \"<input type=\\\"submit\\\" value=\\\"\\\" />\",\n\t\t\t\"input:s\": \"input:submit\",\n\t\t\t\"input:image\": \"<input type=\\\"image\\\" src=\\\"\\\" alt=\\\"\\\" />\",\n\t\t\t\"input:i\": \"input:image\",\n\t\t\t\"input:button\": \"<input type=\\\"button\\\" value=\\\"\\\" />\",\n\t\t\t\"input:b\": \"input:button\",\n\t\t\t\"isindex\": \"<isindex/>\",\n\t\t\t\"input:reset\": \"input:button[type=reset]\",\n\t\t\t\"select\": \"<select name=\\\"\\\" id=\\\"\\\">\",\n\t\t\t\"select:disabled\": \"select[disabled]\",\n\t\t\t\"select:d\": \"select[disabled]\",\n\t\t\t\"option\": \"<option value=\\\"\\\">\",\n\t\t\t\"textarea\": \"<textarea name=\\\"\\\" id=\\\"\\\" cols=\\\"${1:30}\\\" rows=\\\"${2:10}\\\">\",\n\t\t\t\"marquee\": \"<marquee behavior=\\\"\\\" direction=\\\"\\\">\",\n\t\t\t\"menu:context\": \"menu[type=context]>\",\n\t\t\t\"menu:c\": \"menu:context\",\n\t\t\t\"menu:toolbar\": \"menu[type=toolbar]>\",\n\t\t\t\"menu:t\": \"menu:toolbar\",\n\t\t\t\"video\": \"<video src=\\\"\\\">\",\n\t\t\t\"audio\": \"<audio src=\\\"\\\">\",\n\t\t\t\"html:xml\": \"<html xmlns=\\\"http://www.w3.org/1999/xhtml\\\">\",\n\t\t\t\"keygen\": \"<keygen/>\",\n\t\t\t\"command\": \"<command/>\",\n\t\t\t\"button:submit\" : \"button[type=submit]\",\n\t\t\t\"button:s\" : \"button[type=submit]\",\n\t\t\t\"button:reset\" : \"button[type=reset]\",\n\t\t\t\"button:r\" : \"button[type=reset]\",\n\t\t\t\"button:disabled\" : \"button[disabled]\",\n\t\t\t\"button:d\" : \"button[disabled]\",\n\t\t\t\"fieldset:disabled\" : \"fieldset[disabled]\",\n\t\t\t\"fieldset:d\" : \"fieldset[disabled]\",\n\t\t\t\n\t\t\t\"bq\": \"blockquote\",\n\t\t\t\"acr\": \"acronym\",\n\t\t\t\"fig\": \"figure\",\n\t\t\t\"figc\": \"figcaption\",\n\t\t\t\"ifr\": \"iframe\",\n\t\t\t\"emb\": \"embed\",\n\t\t\t\"obj\": \"object\",\n\t\t\t\"src\": \"source\",\n\t\t\t\"cap\": \"caption\",\n\t\t\t\"colg\": \"colgroup\",\n\t\t\t\"fst\": \"fieldset\",\n\t\t\t\"fst:d\": \"fieldset[disabled]\",\n\t\t\t\"btn\": \"button\",\n\t\t\t\"btn:b\": \"button[type=button]\",\n\t\t\t\"btn:r\": \"button[type=reset]\",\n\t\t\t\"btn:s\": \"button[type=submit]\",\n\t\t\t\"btn:d\": \"button[disabled]\",\n\t\t\t\"optg\": \"optgroup\",\n\t\t\t\"opt\": \"option\",\n\t\t\t\"tarea\": \"textarea\",\n\t\t\t\"leg\": \"legend\",\n\t\t\t\"sect\": \"section\",\n\t\t\t\"art\": \"article\",\n\t\t\t\"hdr\": \"header\",\n\t\t\t\"ftr\": \"footer\",\n\t\t\t\"adr\": \"address\",\n\t\t\t\"dlg\": \"dialog\",\n\t\t\t\"str\": \"strong\",\n\t\t\t\"prog\": \"progress\",\n\t\t\t\"fset\": \"fieldset\",\n\t\t\t\"fset:d\": \"fieldset[disabled]\",\n\t\t\t\"datag\": \"datagrid\",\n\t\t\t\"datal\": \"datalist\",\n\t\t\t\"kg\": \"keygen\",\n\t\t\t\"out\": \"output\",\n\t\t\t\"det\": \"details\",\n\t\t\t\"cmd\": \"command\",\n\t\t\t\"doc\": \"html>(head>meta[charset=UTF-8]+title{${1:Document}})+body\",\n\t\t\t\"doc4\": \"html>(head>meta[http-equiv=\\\"Content-Type\\\" content=\\\"text/html;charset=${charset}\\\"]+title{${1:Document}})+body\",\n\n\t\t\t\"html:4t\":  \"!!!4t+doc4[lang=${lang}]\",\n\t\t\t\"html:4s\":  \"!!!4s+doc4[lang=${lang}]\",\n\t\t\t\"html:xt\":  \"!!!xt+doc4[xmlns=http://www.w3.org/1999/xhtml xml:lang=${lang}]\",\n\t\t\t\"html:xs\":  \"!!!xs+doc4[xmlns=http://www.w3.org/1999/xhtml xml:lang=${lang}]\",\n\t\t\t\"html:xxs\": \"!!!xxs+doc4[xmlns=http://www.w3.org/1999/xhtml xml:lang=${lang}]\",\n\t\t\t\"html:5\":   \"!!!+doc[lang=${lang}]\",\n\t\t\t\n\t\t\t\"ol+\": \"ol>li\",\n\t\t\t\"ul+\": \"ul>li\",\n\t\t\t\"dl+\": \"dl>dt+dd\",\n\t\t\t\"map+\": \"map>area\",\n\t\t\t\"table+\": \"table>tr>td\",\n\t\t\t\"colgroup+\": \"colgroup>col\",\n\t\t\t\"colg+\": \"colgroup>col\",\n\t\t\t\"tr+\": \"tr>td\",\n\t\t\t\"select+\": \"select>option\",\n\t\t\t\"optgroup+\": \"optgroup>option\",\n\t\t\t\"optg+\": \"optgroup>option\"\n\t\t}\n\t},\n\t\n\t\"xml\": {\n\t\t\"extends\": \"html\",\n\t\t\"profile\": \"xml\",\n\t\t\"filters\": \"html\"\n\t},\n\t\n\t\"xsl\": {\n\t\t\"extends\": \"html\",\n\t\t\"profile\": \"xml\",\n\t\t\"filters\": \"html, xsl\",\n\t\t\"abbreviations\": {\n\t\t\t\"tm\": \"<xsl:template match=\\\"\\\" mode=\\\"\\\">\",\n\t\t\t\"tmatch\": \"tm\",\n\t\t\t\"tn\": \"<xsl:template name=\\\"\\\">\",\n\t\t\t\"tname\": \"tn\",\n\t\t\t\"call\": \"<xsl:call-template name=\\\"\\\"/>\",\n\t\t\t\"ap\": \"<xsl:apply-templates select=\\\"\\\" mode=\\\"\\\"/>\",\n\t\t\t\"api\": \"<xsl:apply-imports/>\",\n\t\t\t\"imp\": \"<xsl:import href=\\\"\\\"/>\",\n\t\t\t\"inc\": \"<xsl:include href=\\\"\\\"/>\",\n\n\t\t\t\"ch\": \"<xsl:choose>\",\n\t\t\t\"xsl:when\": \"<xsl:when test=\\\"\\\">\",\n\t\t\t\"wh\": \"xsl:when\",\n\t\t\t\"ot\": \"<xsl:otherwise>\",\n\t\t\t\"if\": \"<xsl:if test=\\\"\\\">\",\n\n\t\t\t\"par\": \"<xsl:param name=\\\"\\\">\",\n\t\t\t\"pare\": \"<xsl:param name=\\\"\\\" select=\\\"\\\"/>\",\n\t\t\t\"var\": \"<xsl:variable name=\\\"\\\">\",\n\t\t\t\"vare\": \"<xsl:variable name=\\\"\\\" select=\\\"\\\"/>\",\n\t\t\t\"wp\": \"<xsl:with-param name=\\\"\\\" select=\\\"\\\"/>\",\n\t\t\t\"key\": \"<xsl:key name=\\\"\\\" match=\\\"\\\" use=\\\"\\\"/>\",\n\n\t\t\t\"elem\": \"<xsl:element name=\\\"\\\">\",\n\t\t\t\"attr\": \"<xsl:attribute name=\\\"\\\">\",\n\t\t\t\"attrs\": \"<xsl:attribute-set name=\\\"\\\">\",\n\n\t\t\t\"cp\": \"<xsl:copy select=\\\"\\\"/>\",\n\t\t\t\"co\": \"<xsl:copy-of select=\\\"\\\"/>\",\n\t\t\t\"val\": \"<xsl:value-of select=\\\"\\\"/>\",\n\t\t\t\"each\": \"<xsl:for-each select=\\\"\\\">\",\n\t\t\t\"for\": \"each\",\n\t\t\t\"tex\": \"<xsl:text></xsl:text>\",\n\n\t\t\t\"com\": \"<xsl:comment>\",\n\t\t\t\"msg\": \"<xsl:message terminate=\\\"no\\\">\",\n\t\t\t\"fall\": \"<xsl:fallback>\",\n\t\t\t\"num\": \"<xsl:number value=\\\"\\\"/>\",\n\t\t\t\"nam\": \"<namespace-alias stylesheet-prefix=\\\"\\\" result-prefix=\\\"\\\"/>\",\n\t\t\t\"pres\": \"<xsl:preserve-space elements=\\\"\\\"/>\",\n\t\t\t\"strip\": \"<xsl:strip-space elements=\\\"\\\"/>\",\n\t\t\t\"proc\": \"<xsl:processing-instruction name=\\\"\\\">\",\n\t\t\t\"sort\": \"<xsl:sort select=\\\"\\\" order=\\\"\\\"/>\",\n\n\t\t\t\"choose+\": \"xsl:choose>xsl:when+xsl:otherwise\",\n\t\t\t\"xsl\": \"!!!+xsl:stylesheet[version=1.0 xmlns:xsl=http://www.w3.org/1999/XSL/Transform]>{\\n|}\"\n\t\t}, \n\t\t\"snippets\": {\n\t\t\t\"!!!\": \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\"\n\t\t}\n\t},\n\t\n\t\"haml\": {\n\t\t\"filters\": \"haml\",\n\t\t\"extends\": \"html\",\n\t\t\"profile\": \"xml\"\n\t},\n\t\n\t\"scss\": {\n\t\t\"extends\": \"css\"\n\t},\n\t\n\t\"sass\": {\n\t\t\"extends\": \"css\"\n\t},\n\t\n\t\"less\": {\n\t\t\"extends\": \"css\"\n\t},\n\t\n\t\"stylus\": {\n\t\t\"extends\": \"css\"\n\t},\n\n\t\"styl\": {\n\t\t\"extends\": \"stylus\"\n\t}\n}\n;\nvar res = require('resources');\nvar userData = res.getVocabulary('user') || {};\nres.setVocabulary(require('utils').deepMerge(userData, snippets), 'user');\n});\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9)))\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// static/js/29.4dc8604e60c093c3cae0.js","//     Underscore.js 1.3.3\n//     (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.\n//     Underscore is freely distributable under the MIT license.\n//     Portions of Underscore are inspired or borrowed from Prototype,\n//     Oliver Steele's Functional, and John Resig's Micro-Templating.\n//     For all details and documentation:\n//     http://documentcloud.github.com/underscore\n\nvar _ = (function() {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` in the browser, or `global` on the server.\n  var root = this;\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Establish the object that gets returned to break out of a loop iteration.\n  var breaker = {};\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var slice            = ArrayProto.slice,\n      unshift          = ArrayProto.unshift,\n      toString         = ObjProto.toString,\n      hasOwnProperty   = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var\n    nativeForEach      = ArrayProto.forEach,\n    nativeMap          = ArrayProto.map,\n    nativeReduce       = ArrayProto.reduce,\n    nativeReduceRight  = ArrayProto.reduceRight,\n    nativeFilter       = ArrayProto.filter,\n    nativeEvery        = ArrayProto.every,\n    nativeSome         = ArrayProto.some,\n    nativeIndexOf      = ArrayProto.indexOf,\n    nativeLastIndexOf  = ArrayProto.lastIndexOf,\n    nativeIsArray      = Array.isArray,\n    nativeKeys         = Object.keys,\n    nativeBind         = FuncProto.bind;\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) { return new wrapper(obj); };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for the old `require()` API. If we're in\n  // the browser, add `_` as a global object via a string identifier,\n  // for Closure Compiler \"advanced\" mode.\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root['_'] = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.3.3';\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles objects with the built-in `forEach`, arrays, and raw objects.\n  // Delegates to **ECMAScript 5**'s native `forEach` if available.\n  var each = _.each = _.forEach = function(obj, iterator, context) {\n    if (obj == null) return;\n    if (nativeForEach && obj.forEach === nativeForEach) {\n      obj.forEach(iterator, context);\n    } else if (obj.length === +obj.length) {\n      for (var i = 0, l = obj.length; i < l; i++) {\n        if (i in obj && iterator.call(context, obj[i], i, obj) === breaker) return;\n      }\n    } else {\n      for (var key in obj) {\n        if (_.has(obj, key)) {\n          if (iterator.call(context, obj[key], key, obj) === breaker) return;\n        }\n      }\n    }\n  };\n\n  // Return the results of applying the iterator to each element.\n  // Delegates to **ECMAScript 5**'s native `map` if available.\n  _.map = _.collect = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);\n    each(obj, function(value, index, list) {\n      results[results.length] = iterator.call(context, value, index, list);\n    });\n    if (obj.length === +obj.length) results.length = obj.length;\n    return results;\n  };\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.\n  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduce && obj.reduce === nativeReduce) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);\n    }\n    each(obj, function(value, index, list) {\n      if (!initial) {\n        memo = value;\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, value, index, list);\n      }\n    });\n    if (!initial) throw new TypeError('Reduce of empty array with no initial value');\n    return memo;\n  };\n\n  // The right-associative version of reduce, also known as `foldr`.\n  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.\n  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);\n    }\n    var reversed = _.toArray(obj).reverse();\n    if (context && !initial) iterator = _.bind(iterator, context);\n    return initial ? _.reduce(reversed, iterator, memo, context) : _.reduce(reversed, iterator);\n  };\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, iterator, context) {\n    var result;\n    any(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) {\n        result = value;\n        return true;\n      }\n    });\n    return result;\n  };\n\n  // Return all the elements that pass a truth test.\n  // Delegates to **ECMAScript 5**'s native `filter` if available.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);\n    each(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) results[results.length] = value;\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    each(obj, function(value, index, list) {\n      if (!iterator.call(context, value, index, list)) results[results.length] = value;\n    });\n    return results;\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Delegates to **ECMAScript 5**'s native `every` if available.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, iterator, context) {\n    var result = true;\n    if (obj == null) return result;\n    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);\n    each(obj, function(value, index, list) {\n      if (!(result = result && iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Delegates to **ECMAScript 5**'s native `some` if available.\n  // Aliased as `any`.\n  var any = _.some = _.any = function(obj, iterator, context) {\n    iterator || (iterator = _.identity);\n    var result = false;\n    if (obj == null) return result;\n    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);\n    each(obj, function(value, index, list) {\n      if (result || (result = iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if a given value is included in the array or object using `===`.\n  // Aliased as `contains`.\n  _.include = _.contains = function(obj, target) {\n    var found = false;\n    if (obj == null) return found;\n    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;\n    found = any(obj, function(value) {\n      return value === target;\n    });\n    return found;\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = function(obj, method) {\n    var args = slice.call(arguments, 2);\n    return _.map(obj, function(value) {\n      return (_.isFunction(method) ? method || value : value[method]).apply(value, args);\n    });\n  };\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, function(value){ return value[key]; });\n  };\n\n  // Return the maximum element or (element-based computation).\n  _.max = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0]) return Math.max.apply(Math, obj);\n    if (!iterator && _.isEmpty(obj)) return -Infinity;\n    var result = {computed : -Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed >= result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0]) return Math.min.apply(Math, obj);\n    if (!iterator && _.isEmpty(obj)) return Infinity;\n    var result = {computed : Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed < result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Shuffle an array.\n  _.shuffle = function(obj) {\n    var shuffled = [], rand;\n    each(obj, function(value, index, list) {\n      rand = Math.floor(Math.random() * (index + 1));\n      shuffled[index] = shuffled[rand];\n      shuffled[rand] = value;\n    });\n    return shuffled;\n  };\n\n  // Sort the object's values by a criterion produced by an iterator.\n  _.sortBy = function(obj, val, context) {\n    var iterator = _.isFunction(val) ? val : function(obj) { return obj[val]; };\n    return _.pluck(_.map(obj, function(value, index, list) {\n      return {\n        value : value,\n        criteria : iterator.call(context, value, index, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria, b = right.criteria;\n      if (a === void 0) return 1;\n      if (b === void 0) return -1;\n      return a < b ? -1 : a > b ? 1 : 0;\n    }), 'value');\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = function(obj, val) {\n    var result = {};\n    var iterator = _.isFunction(val) ? val : function(obj) { return obj[val]; };\n    each(obj, function(value, index) {\n      var key = iterator(value, index);\n      (result[key] || (result[key] = [])).push(value);\n    });\n    return result;\n  };\n\n  // Use a comparator function to figure out at what index an object should\n  // be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iterator) {\n    iterator || (iterator = _.identity);\n    var low = 0, high = array.length;\n    while (low < high) {\n      var mid = (low + high) >> 1;\n      iterator(array[mid]) < iterator(obj) ? low = mid + 1 : high = mid;\n    }\n    return low;\n  };\n\n  // Safely convert anything iterable into a real, live array.\n  _.toArray = function(obj) {\n    if (!obj)                                     return [];\n    if (_.isArray(obj))                           return slice.call(obj);\n    if (_.isArguments(obj))                       return slice.call(obj);\n    if (obj.toArray && _.isFunction(obj.toArray)) return obj.toArray();\n    return _.values(obj);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    return _.isArray(obj) ? obj.length : _.keys(obj).length;\n  };\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n  _.first = _.head = _.take = function(array, n, guard) {\n    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];\n  };\n\n  // Returns everything but the last entry of the array. Especcialy useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N. The **guard** check allows it to work with\n  // `_.map`.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array. The **guard** check allows it to work with `_.map`.\n  _.last = function(array, n, guard) {\n    if ((n != null) && !guard) {\n      return slice.call(array, Math.max(array.length - n, 0));\n    } else {\n      return array[array.length - 1];\n    }\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail`.\n  // Especially useful on the arguments object. Passing an **index** will return\n  // the rest of the values in the array from that index onward. The **guard**\n  // check allows it to work with `_.map`.\n  _.rest = _.tail = function(array, index, guard) {\n    return slice.call(array, (index == null) || guard ? 1 : index);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, function(value){ return !!value; });\n  };\n\n  // Return a completely flattened version of an array.\n  _.flatten = function(array, shallow) {\n    return _.reduce(array, function(memo, value) {\n      if (_.isArray(value)) return memo.concat(shallow ? value : _.flatten(value));\n      memo[memo.length] = value;\n      return memo;\n    }, []);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = function(array) {\n    return _.difference(array, slice.call(arguments, 1));\n  };\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iterator) {\n    var initial = iterator ? _.map(array, iterator) : array;\n    var results = [];\n    // The `isSorted` flag is irrelevant if the array only contains two elements.\n    if (array.length < 3) isSorted = true;\n    _.reduce(initial, function (memo, value, index) {\n      if (isSorted ? _.last(memo) !== value || !memo.length : !_.include(memo, value)) {\n        memo.push(value);\n        results.push(array[index]);\n      }\n      return memo;\n    }, []);\n    return results;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = function() {\n    return _.uniq(_.flatten(arguments, true));\n  };\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays. (Aliased as \"intersect\" for back-compat.)\n  _.intersection = _.intersect = function(array) {\n    var rest = slice.call(arguments, 1);\n    return _.filter(_.uniq(array), function(item) {\n      return _.every(rest, function(other) {\n        return _.indexOf(other, item) >= 0;\n      });\n    });\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = function(array) {\n    var rest = _.flatten(slice.call(arguments, 1), true);\n    return _.filter(array, function(value){ return !_.include(rest, value); });\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = function() {\n    var args = slice.call(arguments);\n    var length = _.max(_.pluck(args, 'length'));\n    var results = new Array(length);\n    for (var i = 0; i < length; i++) results[i] = _.pluck(args, \"\" + i);\n    return results;\n  };\n\n  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),\n  // we need this function. Return the position of the first occurrence of an\n  // item in an array, or -1 if the item is not included in the array.\n  // Delegates to **ECMAScript 5**'s native `indexOf` if available.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = function(array, item, isSorted) {\n    if (array == null) return -1;\n    var i, l;\n    if (isSorted) {\n      i = _.sortedIndex(array, item);\n      return array[i] === item ? i : -1;\n    }\n    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item);\n    for (i = 0, l = array.length; i < l; i++) if (i in array && array[i] === item) return i;\n    return -1;\n  };\n\n  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.\n  _.lastIndexOf = function(array, item) {\n    if (array == null) return -1;\n    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) return array.lastIndexOf(item);\n    var i = array.length;\n    while (i--) if (i in array && array[i] === item) return i;\n    return -1;\n  };\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (arguments.length <= 1) {\n      stop = start || 0;\n      start = 0;\n    }\n    step = arguments[2] || 1;\n\n    var len = Math.max(Math.ceil((stop - start) / step), 0);\n    var idx = 0;\n    var range = new Array(len);\n\n    while(idx < len) {\n      range[idx++] = start;\n      start += step;\n    }\n\n    return range;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Reusable constructor function for prototype setting.\n  var ctor = function(){};\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Binding with arguments is also known as `curry`.\n  // Delegates to **ECMAScript 5**'s native `Function.bind` if available.\n  // We check for `func.bind` first, to fail fast when `func` is undefined.\n  _.bind = function bind(func, context) {\n    var bound, args;\n    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n    if (!_.isFunction(func)) throw new TypeError;\n    args = slice.call(arguments, 2);\n    return bound = function() {\n      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));\n      ctor.prototype = func.prototype;\n      var self = new ctor;\n      var result = func.apply(self, args.concat(slice.call(arguments)));\n      if (Object(result) === result) return result;\n      return self;\n    };\n  };\n\n  // Bind all of an object's methods to that object. Useful for ensuring that\n  // all callbacks defined on an object belong to it.\n  _.bindAll = function(obj) {\n    var funcs = slice.call(arguments, 1);\n    if (funcs.length == 0) funcs = _.functions(obj);\n    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });\n    return obj;\n  };\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memo = {};\n    hasher || (hasher = _.identity);\n    return function() {\n      var key = hasher.apply(this, arguments);\n      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));\n    };\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = function(func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function(){ return func.apply(null, args); }, wait);\n  };\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = function(func) {\n    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));\n  };\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time.\n  _.throttle = function(func, wait) {\n    var context, args, timeout, throttling, more, result;\n    var whenDone = _.debounce(function(){ more = throttling = false; }, wait);\n    return function() {\n      context = this; args = arguments;\n      var later = function() {\n        timeout = null;\n        if (more) func.apply(context, args);\n        whenDone();\n      };\n      if (!timeout) timeout = setTimeout(later, wait);\n      if (throttling) {\n        more = true;\n      } else {\n        result = func.apply(context, args);\n      }\n      whenDone();\n      throttling = true;\n      return result;\n    };\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout;\n    return function() {\n      var context = this, args = arguments;\n      var later = function() {\n        timeout = null;\n        if (!immediate) func.apply(context, args);\n      };\n      if (immediate && !timeout) func.apply(context, args);\n      clearTimeout(timeout);\n      timeout = setTimeout(later, wait);\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = function(func) {\n    var ran = false, memo;\n    return function() {\n      if (ran) return memo;\n      ran = true;\n      return memo = func.apply(this, arguments);\n    };\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return function() {\n      var args = [func].concat(slice.call(arguments, 0));\n      return wrapper.apply(this, args);\n    };\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var funcs = arguments;\n    return function() {\n      var args = arguments;\n      for (var i = funcs.length - 1; i >= 0; i--) {\n        args = [funcs[i].apply(this, args)];\n      }\n      return args[0];\n    };\n  };\n\n  // Returns a function that will only be executed after being called N times.\n  _.after = function(times, func) {\n    if (times <= 0) return func();\n    return function() {\n      if (--times < 1) { return func.apply(this, arguments); }\n    };\n  };\n\n  // Object Functions\n  // ----------------\n\n  // Retrieve the names of an object's properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\n  _.keys = nativeKeys || function(obj) {\n    if (obj !== Object(obj)) throw new TypeError('Invalid object');\n    var keys = [];\n    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    return _.map(obj, _.identity);\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      for (var prop in source) {\n        obj[prop] = source[prop];\n      }\n    });\n    return obj;\n  };\n\n  // Return a copy of the object only containing the whitelisted properties.\n  _.pick = function(obj) {\n    var result = {};\n    each(_.flatten(slice.call(arguments, 1)), function(key) {\n      if (key in obj) result[key] = obj[key];\n    });\n    return result;\n  };\n\n  // Fill in a given object with default properties.\n  _.defaults = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      for (var prop in source) {\n        if (obj[prop] == null) obj[prop] = source[prop];\n      }\n    });\n    return obj;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Internal recursive comparison function.\n  function eq(a, b, stack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.\n    if (a === b) return a !== 0 || 1 / a == 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if (a == null || b == null) return a === b;\n    // Unwrap any wrapped objects.\n    if (a._chain) a = a._wrapped;\n    if (b._chain) b = b._wrapped;\n    // Invoke a custom `isEqual` method if one is provided.\n    if (a.isEqual && _.isFunction(a.isEqual)) return a.isEqual(b);\n    if (b.isEqual && _.isFunction(b.isEqual)) return b.isEqual(a);\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className != toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, dates, and booleans are compared by value.\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return a == String(b);\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\n        // other numeric values.\n        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a == +b;\n      // RegExps are compared by their source patterns and flags.\n      case '[object RegExp]':\n        return a.source == b.source &&\n               a.global == b.global &&\n               a.multiline == b.multiline &&\n               a.ignoreCase == b.ignoreCase;\n    }\n    if (typeof a != 'object' || typeof b != 'object') return false;\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n    var length = stack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (stack[length] == a) return true;\n    }\n    // Add the first object to the stack of traversed objects.\n    stack.push(a);\n    var size = 0, result = true;\n    // Recursively compare objects and arrays.\n    if (className == '[object Array]') {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      size = a.length;\n      result = size == b.length;\n      if (result) {\n        // Deep compare the contents, ignoring non-numeric properties.\n        while (size--) {\n          // Ensure commutative equality for sparse arrays.\n          if (!(result = size in a == size in b && eq(a[size], b[size], stack))) break;\n        }\n      }\n    } else {\n      // Objects with different constructors are not equivalent.\n      if ('constructor' in a != 'constructor' in b || a.constructor != b.constructor) return false;\n      // Deep compare objects.\n      for (var key in a) {\n        if (_.has(a, key)) {\n          // Count the expected number of properties.\n          size++;\n          // Deep compare each member.\n          if (!(result = _.has(b, key) && eq(a[key], b[key], stack))) break;\n        }\n      }\n      // Ensure that both objects contain the same number of properties.\n      if (result) {\n        for (key in b) {\n          if (_.has(b, key) && !(size--)) break;\n        }\n        result = !size;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    stack.pop();\n    return result;\n  }\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b, []);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (obj == null) return true;\n    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;\n    for (var key in obj) if (_.has(obj, key)) return false;\n    return true;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType == 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) == '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    return obj === Object(obj);\n  };\n\n  // Is a given variable an arguments object?\n  _.isArguments = function(obj) {\n    return toString.call(obj) == '[object Arguments]';\n  };\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function(obj) {\n      return !!(obj && _.has(obj, 'callee'));\n    };\n  }\n\n  // Is a given value a function?\n  _.isFunction = function(obj) {\n    return toString.call(obj) == '[object Function]';\n  };\n\n  // Is a given value a string?\n  _.isString = function(obj) {\n    return toString.call(obj) == '[object String]';\n  };\n\n  // Is a given value a number?\n  _.isNumber = function(obj) {\n    return toString.call(obj) == '[object Number]';\n  };\n\n  // Is a given object a finite number?\n  _.isFinite = function(obj) {\n    return _.isNumber(obj) && isFinite(obj);\n  };\n\n  // Is the given value `NaN`?\n  _.isNaN = function(obj) {\n    // `NaN` is the only value for which `===` is not reflexive.\n    return obj !== obj;\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n  };\n\n  // Is a given value a date?\n  _.isDate = function(obj) {\n    return toString.call(obj) == '[object Date]';\n  };\n\n  // Is the given value a regular expression?\n  _.isRegExp = function(obj) {\n    return toString.call(obj) == '[object RegExp]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Has own property?\n  _.has = function(obj, key) {\n    return hasOwnProperty.call(obj, key);\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iterators.\n  _.identity = function(value) {\n    return value;\n  };\n\n  // Run a function **n** times.\n  _.times = function (n, iterator, context) {\n    for (var i = 0; i < n; i++) iterator.call(context, i);\n  };\n\n  // Escape a string for HTML interpolation.\n  _.escape = function(string) {\n    return (''+string).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;').replace(/'/g, '&#x27;').replace(/\\//g,'&#x2F;');\n  };\n\n  // If the value of the named property is a function then invoke it;\n  // otherwise, return it.\n  _.result = function(object, property) {\n    if (object == null) return null;\n    var value = object[property];\n    return _.isFunction(value) ? value.call(object) : value;\n  };\n\n  // Add your own custom functions to the Underscore object, ensuring that\n  // they're correctly added to the OOP wrapper as well.\n  _.mixin = function(obj) {\n    each(_.functions(obj), function(name){\n      addToWrapper(name, _[name] = obj[name]);\n    });\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = idCounter++;\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate    : /<%([\\s\\S]+?)%>/g,\n    interpolate : /<%=([\\s\\S]+?)%>/g,\n    escape      : /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /.^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    '\\\\': '\\\\',\n    \"'\": \"'\",\n    'r': '\\r',\n    'n': '\\n',\n    't': '\\t',\n    'u2028': '\\u2028',\n    'u2029': '\\u2029'\n  };\n\n  for (var p in escapes) escapes[escapes[p]] = p;\n  var escaper = /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g;\n  var unescaper = /\\\\(\\\\|'|r|n|t|u2028|u2029)/g;\n\n  // Within an interpolation, evaluation, or escaping, remove HTML escaping\n  // that had been previously added.\n  var unescape = function(code) {\n    return code.replace(unescaper, function(match, escape) {\n      return escapes[escape];\n    });\n  };\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  _.template = function(text, data, settings) {\n    settings = _.defaults(settings || {}, _.templateSettings);\n\n    // Compile the template source, taking care to escape characters that\n    // cannot be included in a string literal and then unescape them in code\n    // blocks.\n    var source = \"__p+='\" + text\n      .replace(escaper, function(match) {\n        return '\\\\' + escapes[match];\n      })\n      .replace(settings.escape || noMatch, function(match, code) {\n        return \"'+\\n_.escape(\" + unescape(code) + \")+\\n'\";\n      })\n      .replace(settings.interpolate || noMatch, function(match, code) {\n        return \"'+\\n(\" + unescape(code) + \")+\\n'\";\n      })\n      .replace(settings.evaluate || noMatch, function(match, code) {\n        return \"';\\n\" + unescape(code) + \"\\n;__p+='\";\n      }) + \"';\\n\";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n    source = \"var __p='';\" +\n      \"var print=function(){__p+=Array.prototype.join.call(arguments, '')};\\n\" +\n      source + \"return __p;\\n\";\n\n    var render = new Function(settings.variable || 'obj', '_', source);\n    if (data) return render(data, _);\n    var template = function(data) {\n      return render.call(this, data, _);\n    };\n\n    // Provide the compiled function source as a convenience for build time\n    // precompilation.\n    template.source = 'function(' + (settings.variable || 'obj') + '){\\n' +\n      source + '}';\n\n    return template;\n  };\n\n  // Add a \"chain\" function, which will delegate to the wrapper.\n  _.chain = function(obj) {\n    return _(obj).chain();\n  };\n\n  // The OOP Wrapper\n  // ---------------\n\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n  var wrapper = function(obj) { this._wrapped = obj; };\n\n  // Expose `wrapper.prototype` as `_.prototype`\n  _.prototype = wrapper.prototype;\n\n  // Helper function to continue chaining intermediate results.\n  var result = function(obj, chain) {\n    return chain ? _(obj).chain() : obj;\n  };\n\n  // A method to easily add functions to the OOP wrapper.\n  var addToWrapper = function(name, func) {\n    wrapper.prototype[name] = function() {\n      var args = slice.call(arguments);\n      unshift.call(args, this._wrapped);\n      return result(func.apply(_, args), this._chain);\n    };\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    wrapper.prototype[name] = function() {\n      var wrapped = this._wrapped;\n      method.apply(wrapped, arguments);\n      var length = wrapped.length;\n      if ((name == 'shift' || name == 'splice') && length === 0) delete wrapped[0];\n      return result(wrapped, this._chain);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    wrapper.prototype[name] = function() {\n      return result(method.apply(this._wrapped, arguments), this._chain);\n    };\n  });\n\n  // Start chaining a wrapped Underscore object.\n  wrapper.prototype.chain = function() {\n    this._chain = true;\n    return this;\n  };\n\n  // Extracts the result from a wrapped and chained object.\n  wrapper.prototype.value = function() {\n    return this._wrapped;\n  };\n  return _;\n}).call({});\n/**\n * Core Emmet object, available in global scope\n */\nvar emmet = (function(global) {\n\tvar defaultSyntax = 'html';\n\tvar defaultProfile = 'plain';\n\t\n\tif (typeof _ == 'undefined') {\n\t\ttry {\n\t\t\t// avoid collisions with RequireJS loader\n\t\t\t// also, JS obfuscators tends to translate\n\t\t\t// a[\"name\"] to a.name, which also breaks RequireJS\n\t\t\t_ = global[['require'][0]]('underscore'); // node.js\n\t\t} catch (e) {}\n\t}\n\n\tif (typeof _ == 'undefined') {\n\t\tthrow 'Cannot access to Underscore.js lib';\n\t}\n\n\t/** List of registered modules */\n\tvar modules = {\n\t\t_ : _\n\t};\n\t\n\t/**\n\t * Shared empty constructor function to aid in prototype-chain creation.\n\t */\n\tvar ctor = function(){};\n\t\n\t/**\n\t * Helper function to correctly set up the prototype chain, for subclasses.\n\t * Similar to `goog.inherits`, but uses a hash of prototype properties and\n\t * class properties to be extended.\n\t * Took it from Backbone.\n\t * @param {Object} parent\n\t * @param {Object} protoProps\n\t * @param {Object} staticProps\n\t * @returns {Object}\n\t */\n\tfunction inherits(parent, protoProps, staticProps) {\n\t\tvar child;\n\n\t\t// The constructor function for the new subclass is either defined by\n\t\t// you (the \"constructor\" property in your `extend` definition), or\n\t\t// defaulted by us to simply call the parent's constructor.\n\t\tif (protoProps && protoProps.hasOwnProperty('constructor')) {\n\t\t\tchild = protoProps.constructor;\n\t\t} else {\n\t\t\tchild = function() {\n\t\t\t\tparent.apply(this, arguments);\n\t\t\t};\n\t\t}\n\n\t\t// Inherit class (static) properties from parent.\n\t\t_.extend(child, parent);\n\n\t\t// Set the prototype chain to inherit from `parent`, without calling\n\t\t// `parent`'s constructor function.\n\t\tctor.prototype = parent.prototype;\n\t\tchild.prototype = new ctor();\n\n\t\t// Add prototype properties (instance properties) to the subclass,\n\t\t// if supplied.\n\t\tif (protoProps)\n\t\t\t_.extend(child.prototype, protoProps);\n\n\t\t// Add static properties to the constructor function, if supplied.\n\t\tif (staticProps)\n\t\t\t_.extend(child, staticProps);\n\n\t\t// Correctly set child's `prototype.constructor`.\n\t\tchild.prototype.constructor = child;\n\n\t\t// Set a convenience property in case the parent's prototype is needed\n\t\t// later.\n\t\tchild.__super__ = parent.prototype;\n\n\t\treturn child;\n\t};\n\t\n\t/**\n\t * @type Function Function that loads module definition if it's not defined\n\t */\n\tvar moduleLoader = null;\n\t\n\t/**\n\t * Generic Emmet module loader (actually, it doesn’t load anything, just \n\t * returns module reference). Not using `require` name to avoid conflicts\n\t * with Node.js and RequireJS\n\t */\n\tfunction r(name) {\n\t\tif (!(name in modules) && moduleLoader)\n\t\t\tmoduleLoader(name);\n\t\t\n\t\treturn modules[name];\n\t}\n\t\n\treturn {\n\t\t/**\n\t\t * Simple, AMD-like module definition. The module will be added into\n\t\t * <code>emmet</code> object and will be available via\n\t\t * <code>emmet.require(name)</code> or <code>emmet[name]</code>\n\t\t * @param {String} name\n\t\t * @param {Function} factory\n\t\t * @memberOf emmet\n\t\t */\n\t\tdefine: function(name, factory) {\n\t\t\t// do not let redefine existing properties\n\t\t\tif (!(name in modules)) {\n\t\t\t\tmodules[name] = _.isFunction(factory) \n\t\t\t\t\t? this.exec(factory)\n\t\t\t\t\t: factory;\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns reference to Emmet module\n\t\t * @param {String} name Module name\n\t\t */\n\t\trequire: r,\n\t\t\n\t\t/**\n\t\t * Helper method that just executes passed function but with all \n\t\t * important arguments like 'require' and '_'\n\t\t * @param {Function} fn\n\t\t * @param {Object} context Execution context\n\t\t */\n\t\texec: function(fn, context) {\n\t\t\treturn fn.call(context || global, _.bind(r, this), _, this);\n\t\t},\n\t\t\n\t\t/**\n\t\t * The self-propagating extend function for classes.\n\t\t * Took it from Backbone \n\t\t * @param {Object} protoProps\n\t\t * @param {Object} classProps\n\t\t * @returns {Object}\n\t\t */\n\t\textend: function(protoProps, classProps) {\n\t\t\tvar child = inherits(this, protoProps, classProps);\n\t\t\tchild.extend = this.extend;\n\t\t\t// a hack required to WSH inherit `toString` method\n\t\t\tif (protoProps.hasOwnProperty('toString'))\n\t\t\t\tchild.prototype.toString = protoProps.toString;\n\t\t\treturn child;\n\t\t},\n\t\t\n\t\t/**\n\t\t * The essential function that expands Emmet abbreviation\n\t\t * @param {String} abbr Abbreviation to parse\n\t\t * @param {String} syntax Abbreviation's context syntax\n\t\t * @param {String} profile Output profile (or its name)\n\t\t * @param {Object} contextNode Contextual node where abbreviation is\n\t\t * written\n\t\t * @return {String}\n\t\t */\n\t\texpandAbbreviation: function(abbr, syntax, profile, contextNode) {\n\t\t\tif (!abbr) return '';\n\t\t\t\n\t\t\tsyntax = syntax || defaultSyntax;\n//\t\t\tprofile = profile || defaultProfile;\n\t\t\t\n\t\t\tvar filters = r('filters');\n\t\t\tvar parser = r('abbreviationParser');\n\t\t\t\n\t\t\tprofile = r('profile').get(profile, syntax);\n\t\t\tr('tabStops').resetTabstopIndex();\n\t\t\t\n\t\t\tvar data = filters.extractFromAbbreviation(abbr);\n\t\t\tvar outputTree = parser.parse(data[0], {\n\t\t\t\tsyntax: syntax, \n\t\t\t\tcontextNode: contextNode\n\t\t\t});\n\t\t\t\n\t\t\tvar filtersList = filters.composeList(syntax, profile, data[1]);\n\t\t\tfilters.apply(outputTree, filtersList, profile);\n\t\t\treturn outputTree.toString();\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns default syntax name used in abbreviation engine\n\t\t * @returns {String}\n\t\t */\n\t\tdefaultSyntax: function() {\n\t\t\treturn defaultSyntax;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns default profile name used in abbreviation engine\n\t\t * @returns {String}\n\t\t */\n\t\tdefaultProfile: function() {\n\t\t\treturn defaultProfile;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Log message into console if it exists\n\t\t */\n\t\tlog: function() {\n\t\t\tif (global.console && global.console.log)\n\t\t\t\tglobal.console.log.apply(global.console, arguments);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Setups function that should synchronously load undefined modules\n\t\t * @param {Function} fn\n\t\t */\n\t\tsetModuleLoader: function(fn) {\n\t\t\tmoduleLoader = fn;\n\t\t}\n\t};\n})(this);\n\n// export core for Node.JS\nif (typeof exports !== 'undefined') {\n\tif (typeof module !== 'undefined' && module.exports) {\n\t\texports = module.exports = emmet;\n\t}\n\texports.emmet = emmet;\n}\n\n// export as Require.js module\nif (typeof define !== 'undefined') {\n\tdefine('emmet', [], emmet);\n}/**\n * Emmet abbreviation parser.\n * Takes string abbreviation and recursively parses it into a tree. The parsed \n * tree can be transformed into a string representation with \n * <code>toString()</code> method. Note that string representation is defined\n * by custom processors (called <i>filters</i>), not by abbreviation parser \n * itself.\n * \n * This module can be extended with custom pre-/post-processors to shape-up\n * final tree or its representation. Actually, many features of abbreviation \n * engine are defined in other modules as tree processors\n * \n * \n * @author Sergey Chikuyonok (serge.che@gmail.com)\n * @link http://chikuyonok.ru\n * @memberOf __abbreviationParser\n * @constructor\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.define('abbreviationParser', function(require, _) {\n\tvar reValidName = /^[\\w\\-\\$\\:@\\!%]+\\+?$/i;\n\tvar reWord = /[\\w\\-:\\$@]/;\n\t\n\tvar pairs = {\n\t\t'[': ']',\n\t\t'(': ')',\n\t\t'{': '}'\n\t};\n\t\n\tvar spliceFn = Array.prototype.splice;\n\t\n\tvar preprocessors = [];\n\tvar postprocessors = [];\n\tvar outputProcessors = [];\n\t\n\t/**\n\t * @type AbbreviationNode\n\t */\n\tfunction AbbreviationNode(parent) {\n\t\t/** @type AbbreviationNode */\n\t\tthis.parent = null;\n\t\tthis.children = [];\n\t\tthis._attributes = [];\n\t\t\n\t\t/** @type String Raw abbreviation for current node */\n\t\tthis.abbreviation = '';\n\t\tthis.counter = 1;\n\t\tthis._name = null;\n\t\tthis._text = '';\n\t\tthis.repeatCount = 1;\n\t\tthis.hasImplicitRepeat = false;\n\t\t\n\t\t/** Custom data dictionary */\n\t\tthis._data = {};\n\t\t\n\t\t// output properties\n\t\tthis.start = '';\n\t\tthis.end = '';\n\t\tthis.content = '';\n\t\tthis.padding = '';\n\t}\n\t\n\tAbbreviationNode.prototype = {\n\t\t/**\n\t\t * Adds passed node as child or creates new child\n\t\t * @param {AbbreviationNode} child\n\t\t * @param {Number} position Index in children array where child should \n\t\t * be inserted\n\t\t * @return {AbbreviationNode}\n\t\t */\n\t\taddChild: function(child, position) {\n\t\t\tchild = child || new AbbreviationNode;\n\t\t\tchild.parent = this;\n\t\t\t\n\t\t\tif (_.isUndefined(position)) {\n\t\t\t\tthis.children.push(child);\n\t\t\t} else {\n\t\t\t\tthis.children.splice(position, 0, child);\n\t\t\t}\n\t\t\t\n\t\t\treturn child;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Creates a deep copy of current node\n\t\t * @returns {AbbreviationNode}\n\t\t */\n\t\tclone: function() {\n\t\t\tvar node = new AbbreviationNode();\n\t\t\tvar attrs = ['abbreviation', 'counter', '_name', '_text', 'repeatCount', 'hasImplicitRepeat', 'start', 'end', 'content', 'padding'];\n\t\t\t_.each(attrs, function(a) {\n\t\t\t\tnode[a] = this[a];\n\t\t\t}, this);\n\t\t\t\n\t\t\t// clone attributes\n\t\t\tnode._attributes = _.map(this._attributes, function(attr) {\n\t\t\t\treturn _.clone(attr);\n\t\t\t});\n\t\t\t\n\t\t\tnode._data = _.clone(this._data);\n\t\t\t\n\t\t\t// clone children\n\t\t\tnode.children = _.map(this.children, function(child) {\n\t\t\t\tchild = child.clone();\n\t\t\t\tchild.parent = node;\n\t\t\t\treturn child;\n\t\t\t});\n\t\t\t\n\t\t\treturn node;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Removes current node from parent‘s child list\n\t\t * @returns {AbbreviationNode} Current node itself\n\t\t */\n\t\tremove: function() {\n\t\t\tif (this.parent) {\n\t\t\t\tthis.parent.children = _.without(this.parent.children, this);\n\t\t\t}\n\t\t\t\n\t\t\treturn this;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Replaces current node in parent‘s children list with passed nodes\n\t\t * @param {AbbreviationNode} node Replacement node or array of nodes\n\t\t */\n\t\treplace: function() {\n\t\t\tvar parent = this.parent;\n\t\t\tvar ix = _.indexOf(parent.children, this);\n\t\t\tvar items = _.flatten(arguments);\n\t\t\tspliceFn.apply(parent.children, [ix, 1].concat(items));\n\t\t\t\n\t\t\t// update parent\n\t\t\t_.each(items, function(item) {\n\t\t\t\titem.parent = parent;\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Recursively sets <code>property</code> to <code>value</code> of current\n\t\t * node and its children \n\t\t * @param {String} name Property to update\n\t\t * @param {Object} value New property value\n\t\t */\n\t\tupdateProperty: function(name, value) {\n\t\t\tthis[name] = value;\n\t\t\t_.each(this.children, function(child) {\n\t\t\t\tchild.updateProperty(name, value);\n\t\t\t});\n\t\t\t\n\t\t\treturn this;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Finds first child node that matches truth test for passed \n\t\t * <code>fn</code> function\n\t\t * @param {Function} fn\n\t\t * @returns {AbbreviationNode}\n\t\t */\n\t\tfind: function(fn) {\n\t\t\treturn this.findAll(fn)[0];\n//\t\t\tif (!_.isFunction(fn)) {\n//\t\t\t\tvar elemName = fn.toLowerCase();\n//\t\t\t\tfn = function(item) {return item.name().toLowerCase() == elemName;};\n//\t\t\t}\n//\t\t\t\n//\t\t\tvar result = null;\n//\t\t\t_.find(this.children, function(child) {\n//\t\t\t\tif (fn(child)) {\n//\t\t\t\t\treturn result = child;\n//\t\t\t\t}\n//\t\t\t\t\n//\t\t\t\treturn result = child.find(fn);\n//\t\t\t});\n//\t\t\t\n//\t\t\treturn result;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Finds all child nodes that matches truth test for passed \n\t\t * <code>fn</code> function\n\t\t * @param {Function} fn\n\t\t * @returns {Array}\n\t\t */\n\t\tfindAll: function(fn) {\n\t\t\tif (!_.isFunction(fn)) {\n\t\t\t\tvar elemName = fn.toLowerCase();\n\t\t\t\tfn = function(item) {return item.name().toLowerCase() == elemName;};\n\t\t\t}\n\t\t\t\t\n\t\t\tvar result = [];\n\t\t\t_.each(this.children, function(child) {\n\t\t\t\tif (fn(child))\n\t\t\t\t\tresult.push(child);\n\t\t\t\t\n\t\t\t\tresult = result.concat(child.findAll(fn));\n\t\t\t});\n\t\t\t\n\t\t\treturn _.compact(result);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Sets/gets custom data\n\t\t * @param {String} name\n\t\t * @param {Object} value\n\t\t * @returns {Object}\n\t\t */\n\t\tdata: function(name, value) {\n\t\t\tif (arguments.length == 2) {\n\t\t\t\tthis._data[name] = value;\n\t\t\t\t\n\t\t\t\tif (name == 'resource' && require('elements').is(value, 'snippet')) {\n\t\t\t\t\t// setting snippet as matched resource: update `content`\n\t\t\t\t\t// property with snippet value\n\t\t\t\t\tthis.content = value.data;\n\t\t\t\t\tif (this._text) {\n\t\t\t\t\t\tthis.content = require('abbreviationUtils')\n\t\t\t\t\t\t\t.insertChildContent(value.data, this._text);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn this._data[name];\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns name of current node\n\t\t * @returns {String}\n\t\t */\n\t\tname: function() {\n\t\t\tvar res = this.matchedResource();\n\t\t\tif (require('elements').is(res, 'element')) {\n\t\t\t\treturn res.name;\n\t\t\t}\n\t\t\t\n\t\t\treturn this._name;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns list of attributes for current node\n\t\t * @returns {Array}\n\t\t */\n\t\tattributeList: function() {\n\t\t\tvar attrs = [];\n\t\t\t\n\t\t\tvar res = this.matchedResource();\n\t\t\tif (require('elements').is(res, 'element') && _.isArray(res.attributes)) {\n\t\t\t\tattrs = attrs.concat(res.attributes);\n\t\t\t}\n\t\t\t\n\t\t\treturn optimizeAttributes(attrs.concat(this._attributes));\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns or sets attribute value\n\t\t * @param {String} name Attribute name\n\t\t * @param {String} value New attribute value\n\t\t * @returns {String}\n\t\t */\n\t\tattribute: function(name, value) {\n\t\t\tif (arguments.length == 2) {\n\t\t\t\t// modifying attribute\n\t\t\t\tvar ix = _.indexOf(_.pluck(this._attributes, 'name'), name.toLowerCase());\n\t\t\t\tif (~ix) {\n\t\t\t\t\tthis._attributes[ix].value = value;\n\t\t\t\t} else {\n\t\t\t\t\tthis._attributes.push({\n\t\t\t\t\t\tname: name,\n\t\t\t\t\t\tvalue: value\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn (_.find(this.attributeList(), function(attr) {\n\t\t\t\treturn attr.name == name;\n\t\t\t}) || {}).value;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns reference to the matched <code>element</code>, if any.\n\t\t * See {@link elements} module for a list of available elements\n\t\t * @returns {Object}\n\t\t */\n\t\tmatchedResource: function() {\n\t\t\treturn this.data('resource');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns index of current node in parent‘s children list\n\t\t * @returns {Number}\n\t\t */\n\t\tindex: function() {\n\t\t\treturn this.parent ? _.indexOf(this.parent.children, this) : -1;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Sets how many times current element should be repeated\n\t\t * @private\n\t\t */\n\t\t_setRepeat: function(count) {\n\t\t\tif (count) {\n\t\t\t\tthis.repeatCount = parseInt(count, 10) || 1;\n\t\t\t} else {\n\t\t\t\tthis.hasImplicitRepeat = true;\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Sets abbreviation that belongs to current node\n\t\t * @param {String} abbr\n\t\t */\n\t\tsetAbbreviation: function(abbr) {\n\t\t\tabbr = abbr || '';\n\t\t\t\n\t\t\tvar that = this;\n\t\t\t\n\t\t\t// find multiplier\n\t\t\tabbr = abbr.replace(/\\*(\\d+)?$/, function(str, repeatCount) {\n\t\t\t\tthat._setRepeat(repeatCount);\n\t\t\t\treturn '';\n\t\t\t});\n\t\t\t\n\t\t\tthis.abbreviation = abbr;\n\t\t\t\n\t\t\tvar abbrText = extractText(abbr);\n\t\t\tif (abbrText) {\n\t\t\t\tabbr = abbrText.element;\n\t\t\t\tthis.content = this._text = abbrText.text;\n\t\t\t}\n\t\t\t\n\t\t\tvar abbrAttrs = parseAttributes(abbr);\n\t\t\tif (abbrAttrs) {\n\t\t\t\tabbr = abbrAttrs.element;\n\t\t\t\tthis._attributes = abbrAttrs.attributes;\n\t\t\t}\n\t\t\t\n\t\t\tthis._name = abbr;\n\t\t\t\n\t\t\t// validate name\n\t\t\tif (this._name && !reValidName.test(this._name)) {\n\t\t\t\tthrow 'Invalid abbreviation';\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns string representation of current node\n\t\t * @return {String}\n\t\t */\n\t\ttoString: function() {\n\t\t\tvar utils = require('utils');\n\t\t\t\n\t\t\tvar start = this.start;\n\t\t\tvar end = this.end;\n\t\t\tvar content = this.content;\n\t\t\t\n\t\t\t// apply output processors\n\t\t\tvar node = this;\n\t\t\t_.each(outputProcessors, function(fn) {\n\t\t\t\tstart = fn(start, node, 'start');\n\t\t\t\tcontent = fn(content, node, 'content');\n\t\t\t\tend = fn(end, node, 'end');\n\t\t\t});\n\t\t\t\n\t\t\t\n\t\t\tvar innerContent = _.map(this.children, function(child) {\n\t\t\t\treturn child.toString();\n\t\t\t}).join('');\n\t\t\t\n\t\t\tcontent = require('abbreviationUtils').insertChildContent(content, innerContent, {\n\t\t\t\tkeepVariable: false\n\t\t\t});\n\t\t\t\n\t\t\treturn start + utils.padString(content, this.padding) + end;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if current node contains children with empty <code>expr</code>\n\t\t * property\n\t\t * @return {Boolean}\n\t\t */\n\t\thasEmptyChildren: function() {\n\t\t\treturn !!_.find(this.children, function(child) {\n\t\t\t\treturn child.isEmpty();\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if current node has implied name that should be resolved\n\t\t * @returns {Boolean}\n\t\t */\n\t\thasImplicitName: function() {\n\t\t\treturn !this._name && !this.isTextNode();\n\t\t},\n\t\t\n\t\t/**\n\t\t * Indicates that current element is a grouping one, e.g. has no \n\t\t * representation but serves as a container for other nodes\n\t\t * @returns {Boolean}\n\t\t */\n\t\tisGroup: function() {\n\t\t\treturn !this.abbreviation;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Indicates empty node (i.e. without abbreviation). It may be a \n\t\t * grouping node and should not be outputted\n\t\t * @return {Boolean}\n\t\t */\n\t\tisEmpty: function() {\n\t\t\treturn !this.abbreviation && !this.children.length;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Indicates that current node should be repeated\n\t\t * @returns {Boolean}\n\t\t */\n\t\tisRepeating: function() {\n\t\t\treturn this.repeatCount > 1 || this.hasImplicitRepeat;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if current node is a text-only node\n\t\t * @return {Boolean}\n\t\t */\n\t\tisTextNode: function() {\n\t\t\treturn !this.name() && !this.attributeList().length;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Indicates whether this node may be used to build elements or snippets\n\t\t * @returns {Boolean}\n\t\t */\n\t\tisElement: function() {\n\t\t\treturn !this.isEmpty() && !this.isTextNode();\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns latest and deepest child of current tree\n\t\t * @returns {AbbreviationNode}\n\t\t */\n\t\tdeepestChild: function() {\n\t\t\tif (!this.children.length)\n\t\t\t\treturn null;\n\t\t\t\t\n\t\t\tvar deepestChild = this;\n\t\t\twhile (deepestChild.children.length) {\n\t\t\t\tdeepestChild = _.last(deepestChild.children);\n\t\t\t}\n\t\t\t\n\t\t\treturn deepestChild;\n\t\t}\n\t};\n\t\n\t/**\n\t * Returns stripped string: a string without first and last character.\n\t * Used for “unquoting” strings\n\t * @param {String} str\n\t * @returns {String}\n\t */\n\tfunction stripped(str) {\n\t\treturn str.substring(1, str.length - 1);\n\t}\n\t\n\tfunction consumeQuotedValue(stream, quote) {\n\t\tvar ch;\n\t\twhile (ch = stream.next()) {\n\t\t\tif (ch === quote)\n\t\t\t\treturn true;\n\t\t\t\n\t\t\tif (ch == '\\\\')\n\t\t\t\tcontinue;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * Parses abbreviation into a tree\n\t * @param {String} abbr\n\t * @returns {AbbreviationNode}\n\t */\n\tfunction parseAbbreviation(abbr) {\n\t\tabbr = require('utils').trim(abbr);\n\t\t\n\t\tvar root = new AbbreviationNode;\n\t\tvar context = root.addChild(), ch;\n\t\t\n\t\t/** @type StringStream */\n\t\tvar stream = require('stringStream').create(abbr);\n\t\tvar loopProtector = 1000, multiplier;\n\t\t\n\t\twhile (!stream.eol() && --loopProtector > 0) {\n\t\t\tch = stream.peek();\n\t\t\t\n\t\t\tswitch (ch) {\n\t\t\t\tcase '(': // abbreviation group\n\t\t\t\t\tstream.start = stream.pos;\n\t\t\t\t\tif (stream.skipToPair('(', ')')) {\n\t\t\t\t\t\tvar inner = parseAbbreviation(stripped(stream.current()));\n\t\t\t\t\t\tif (multiplier = stream.match(/^\\*(\\d+)?/, true)) {\n\t\t\t\t\t\t\tcontext._setRepeat(multiplier[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t_.each(inner.children, function(child) {\n\t\t\t\t\t\t\tcontext.addChild(child);\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow 'Invalid abbreviation: mo matching \")\" found for character at ' + stream.pos;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase '>': // child operator\n\t\t\t\t\tcontext = context.addChild();\n\t\t\t\t\tstream.next();\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase '+': // sibling operator\n\t\t\t\t\tcontext = context.parent.addChild();\n\t\t\t\t\tstream.next();\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase '^': // climb up operator\n\t\t\t\t\tvar parent = context.parent || context;\n\t\t\t\t\tcontext = (parent.parent || parent).addChild();\n\t\t\t\t\tstream.next();\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tdefault: // consume abbreviation\n\t\t\t\t\tstream.start = stream.pos;\n\t\t\t\t\tstream.eatWhile(function(c) {\n\t\t\t\t\t\tif (c == '[' || c == '{') {\n\t\t\t\t\t\t\tif (stream.skipToPair(c, pairs[c])) {\n\t\t\t\t\t\t\t\tstream.backUp(1);\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tthrow 'Invalid abbreviation: mo matching \"' + pairs[c] + '\" found for character at ' + stream.pos;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (c == '+') {\n\t\t\t\t\t\t\t// let's see if this is an expando marker\n\t\t\t\t\t\t\tstream.next();\n\t\t\t\t\t\t\tvar isMarker = stream.eol() ||  ~'+>^*'.indexOf(stream.peek());\n\t\t\t\t\t\t\tstream.backUp(1);\n\t\t\t\t\t\t\treturn isMarker;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\treturn c != '(' && isAllowedChar(c);\n\t\t\t\t\t});\n\t\t\t\t\t\n\t\t\t\t\tcontext.setAbbreviation(stream.current());\n\t\t\t\t\tstream.start = stream.pos;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (loopProtector < 1)\n\t\t\tthrow 'Endless loop detected';\n\t\t\n\t\treturn root;\n\t}\n\t\n\t/**\n\t * Extract attributes and their values from attribute set: \n\t * <code>[attr col=3 title=\"Quoted string\"]</code>\n\t * @param {String} attrSet\n\t * @returns {Array}\n\t */\n\tfunction extractAttributes(attrSet, attrs) {\n\t\tattrSet = require('utils').trim(attrSet);\n\t\tvar result = [];\n\t\t\n\t\t/** @type StringStream */\n\t\tvar stream = require('stringStream').create(attrSet);\n\t\tstream.eatSpace();\n\t\t\n\t\twhile (!stream.eol()) {\n\t\t\tstream.start = stream.pos;\n\t\t\tif (stream.eatWhile(reWord)) {\n\t\t\t\tvar attrName = stream.current();\n\t\t\t\tvar attrValue = '';\n\t\t\t\tif (stream.peek() == '=') {\n\t\t\t\t\tstream.next();\n\t\t\t\t\tstream.start = stream.pos;\n\t\t\t\t\tvar quote = stream.peek();\n\t\t\t\t\t\n\t\t\t\t\tif (quote == '\"' || quote == \"'\") {\n\t\t\t\t\t\tstream.next();\n\t\t\t\t\t\tif (consumeQuotedValue(stream, quote)) {\n\t\t\t\t\t\t\tattrValue = stream.current();\n\t\t\t\t\t\t\t// strip quotes\n\t\t\t\t\t\t\tattrValue = attrValue.substring(1, attrValue.length - 1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow 'Invalid attribute value';\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (stream.eatWhile(/[^\\s\\]]/)) {\n\t\t\t\t\t\tattrValue = stream.current();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow 'Invalid attribute value';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tresult.push({\n\t\t\t\t\tname: attrName, \n\t\t\t\t\tvalue: attrValue\n\t\t\t\t});\n\t\t\t\tstream.eatSpace();\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn result;\n\t}\n\t\n\t/**\n\t * Parses tag attributes extracted from abbreviation. If attributes found, \n\t * returns object with <code>element</code> and <code>attributes</code>\n\t * properties\n\t * @param {String} abbr\n\t * @returns {Object} Returns <code>null</code> if no attributes found in \n\t * abbreviation\n\t */\n\tfunction parseAttributes(abbr) {\n\t\t/*\n\t\t * Example of incoming data:\n\t\t * #header\n\t\t * .some.data\n\t\t * .some.data#header\n\t\t * [attr]\n\t\t * #item[attr=Hello other=\"World\"].class\n\t\t */\n\t\tvar result = [];\n\t\tvar attrMap = {'#': 'id', '.': 'class'};\n\t\tvar nameEnd = null;\n\t\t\n\t\t/** @type StringStream */\n\t\tvar stream = require('stringStream').create(abbr);\n\t\twhile (!stream.eol()) {\n\t\t\tswitch (stream.peek()) {\n\t\t\t\tcase '#': // id\n\t\t\t\tcase '.': // class\n\t\t\t\t\tif (nameEnd === null)\n\t\t\t\t\t\tnameEnd = stream.pos;\n\t\t\t\t\t\n\t\t\t\t\tvar attrName = attrMap[stream.peek()];\n\t\t\t\t\t\n\t\t\t\t\tstream.next();\n\t\t\t\t\tstream.start = stream.pos;\n\t\t\t\t\tstream.eatWhile(reWord);\n\t\t\t\t\tresult.push({\n\t\t\t\t\t\tname: attrName, \n\t\t\t\t\t\tvalue: stream.current()\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\t\t\t\tcase '[': //begin attribute set\n\t\t\t\t\tif (nameEnd === null)\n\t\t\t\t\t\tnameEnd = stream.pos;\n\t\t\t\t\t\n\t\t\t\t\tstream.start = stream.pos;\n\t\t\t\t\tif (!stream.skipToPair('[', ']')) \n\t\t\t\t\t\tthrow 'Invalid attribute set definition';\n\t\t\t\t\t\n\t\t\t\t\tresult = result.concat(\n\t\t\t\t\t\textractAttributes(stripped(stream.current()))\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tstream.next();\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (!result.length)\n\t\t\treturn null;\n\t\t\n\t\treturn {\n\t\t\telement: abbr.substring(0, nameEnd),\n\t\t\tattributes: optimizeAttributes(result)\n\t\t};\n\t}\n\t\n\t/**\n\t * Optimize attribute set: remove duplicates and merge class attributes\n\t * @param attrs\n\t */\n\tfunction optimizeAttributes(attrs) {\n\t\t// clone all attributes to make sure that original objects are \n\t\t// not modified\n\t\tattrs  = _.map(attrs, function(attr) {\n\t\t\treturn _.clone(attr);\n\t\t});\n\t\t\n\t\tvar lookup = {};\n\t\treturn _.filter(attrs, function(attr) {\n\t\t\tif (!(attr.name in lookup)) {\n\t\t\t\treturn lookup[attr.name] = attr;\n\t\t\t}\n\t\t\t\n\t\t\tvar la = lookup[attr.name];\n\t\t\t\n\t\t\tif (attr.name.toLowerCase() == 'class') {\n\t\t\t\tla.value += (la.value.length ? ' ' : '') + attr.value;\n\t\t\t} else {\n\t\t\t\tla.value = attr.value;\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\t\t});\n\t}\n\t\n\t/**\n\t * Extract text data from abbreviation: if <code>a{hello}</code> abbreviation\n\t * is passed, returns object <code>{element: 'a', text: 'hello'}</code>.\n\t * If nothing found, returns <code>null</code>\n\t * @param {String} abbr\n\t * \n\t */\n\tfunction extractText(abbr) {\n\t\tif (!~abbr.indexOf('{'))\n\t\t\treturn null;\n\t\t\n\t\t/** @type StringStream */\n\t\tvar stream = require('stringStream').create(abbr);\n\t\twhile (!stream.eol()) {\n\t\t\tswitch (stream.peek()) {\n\t\t\t\tcase '[':\n\t\t\t\tcase '(':\n\t\t\t\t\tstream.skipToPair(stream.peek(), pairs[stream.peek()]); break;\n\t\t\t\t\t\n\t\t\t\tcase '{':\n\t\t\t\t\tstream.start = stream.pos;\n\t\t\t\t\tstream.skipToPair('{', '}');\n\t\t\t\t\treturn {\n\t\t\t\t\t\telement: abbr.substring(0, stream.start),\n\t\t\t\t\t\ttext: stripped(stream.current())\n\t\t\t\t\t};\n\t\t\t\t\t\n\t\t\t\tdefault:\n\t\t\t\t\tstream.next();\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * “Un-rolls“ contents of current node: recursively replaces all repeating \n\t * children with their repeated clones\n\t * @param {AbbreviationNode} node\n\t * @returns {AbbreviationNode}\n\t */\n\tfunction unroll(node) {\n\t\tfor (var i = node.children.length - 1, j, child, maxCount; i >= 0; i--) {\n\t\t\tchild = node.children[i];\n\t\t\t\n\t\t\tif (child.isRepeating()) {\n\t\t\t\tmaxCount = j = child.repeatCount;\n\t\t\t\tchild.repeatCount = 1;\n\t\t\t\tchild.updateProperty('counter', 1);\n\t\t\t\tchild.updateProperty('maxCount', maxCount);\n\t\t\t\twhile (--j > 0) {\n\t\t\t\t\tchild.parent.addChild(child.clone(), i + 1)\n\t\t\t\t\t\t.updateProperty('counter', j + 1)\n\t\t\t\t\t\t.updateProperty('maxCount', maxCount);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// to keep proper 'counter' property, we need to walk\n\t\t// on children once again\n\t\t_.each(node.children, unroll);\n\t\t\n\t\treturn node;\n\t}\n\t\n\t/**\n\t * Optimizes tree node: replaces empty nodes with their children\n\t * @param {AbbreviationNode} node\n\t * @return {AbbreviationNode}\n\t */\n\tfunction squash(node) {\n\t\tfor (var i = node.children.length - 1; i >= 0; i--) {\n\t\t\t/** @type AbbreviationNode */\n\t\t\tvar n = node.children[i];\n\t\t\tif (n.isGroup()) {\n\t\t\t\tn.replace(squash(n).children);\n\t\t\t} else if (n.isEmpty()) {\n\t\t\t\tn.remove();\n\t\t\t}\n\t\t}\n\t\t\n\t\t_.each(node.children, squash);\n\t\t\n\t\treturn node;\n\t}\n\t\n\tfunction isAllowedChar(ch) {\n\t\tvar charCode = ch.charCodeAt(0);\n\t\tvar specialChars = '#.*:$-_!@|%';\n\t\t\n\t\treturn (charCode > 64 && charCode < 91)       // uppercase letter\n\t\t\t\t|| (charCode > 96 && charCode < 123)  // lowercase letter\n\t\t\t\t|| (charCode > 47 && charCode < 58)   // number\n\t\t\t\t|| specialChars.indexOf(ch) != -1;    // special character\n\t}\n\t\n\t// XXX add counter replacer function as output processor\n\toutputProcessors.push(function(text, node) {\n\t\treturn require('utils').replaceCounter(text, node.counter, node.maxCount);\n\t});\n\t\n\treturn {\n\t\t/**\n\t\t * Parses abbreviation into tree with respect of groups, \n\t\t * text nodes and attributes. Each node of the tree is a single \n\t\t * abbreviation. Tree represents actual structure of the outputted \n\t\t * result\n\t\t * @memberOf abbreviationParser\n\t\t * @param {String} abbr Abbreviation to parse\n\t\t * @param {Object} options Additional options for parser and processors\n\t\t * \n\t\t * @return {AbbreviationNode}\n\t\t */\n\t\tparse: function(abbr, options) {\n\t\t\toptions = options || {};\n\t\t\t\n\t\t\tvar tree = parseAbbreviation(abbr);\n\t\t\t\n\t\t\tif (options.contextNode) {\n\t\t\t\t// add info about context node –\n\t\t\t\t// a parent XHTML node in editor inside which abbreviation is \n\t\t\t\t// expanded\n\t\t\t\ttree._name = options.contextNode.name;\n\t\t\t\tvar attrLookup = {};\n\t\t\t\t_.each(tree._attributes, function(attr) {\n\t\t\t\t\tattrLookup[attr.name] = attr;\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\t_.each(options.contextNode.attributes, function(attr) {\n\t\t\t\t\tif (attr.name in attrLookup) {\n\t\t\t\t\t\tattrLookup[attr.name].value = attr.value;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tattr = _.clone(attr);\n\t\t\t\t\t\ttree._attributes.push(attr);\n\t\t\t\t\t\tattrLookup[attr.name] = attr;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t// apply preprocessors\n\t\t\t_.each(preprocessors, function(fn) {\n\t\t\t\tfn(tree, options);\n\t\t\t});\n\t\t\t\n\t\t\ttree = squash(unroll(tree));\n\t\t\t\n\t\t\t// apply postprocessors\n\t\t\t_.each(postprocessors, function(fn) {\n\t\t\t\tfn(tree, options);\n\t\t\t});\n\t\t\t\n\t\t\treturn tree;\n\t\t},\n\t\t\n\t\tAbbreviationNode: AbbreviationNode,\n\t\t\n\t\t/**\n\t\t * Add new abbreviation preprocessor. <i>Preprocessor</i> is a function\n\t\t * that applies to a parsed abbreviation tree right after it get parsed.\n\t\t * The passed tree is in unoptimized state.\n\t\t * @param {Function} fn Preprocessor function. This function receives\n\t\t * two arguments: parsed abbreviation tree (<code>AbbreviationNode</code>)\n\t\t * and <code>options</code> hash that was passed to <code>parse</code>\n\t\t * method\n\t\t */\n\t\taddPreprocessor: function(fn) {\n\t\t\tif (!_.include(preprocessors, fn))\n\t\t\t\tpreprocessors.push(fn);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Removes registered preprocessor\n\t\t */\n\t\tremoveFilter: function(fn) {\n\t\t\tpreprocessor = _.without(preprocessors, fn);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Adds new abbreviation postprocessor. <i>Postprocessor</i> is a \n\t\t * functinon that applies to <i>optimized</i> parsed abbreviation tree\n\t\t * right before it returns from <code>parse()</code> method\n\t\t * @param {Function} fn Postprocessor function. This function receives\n\t\t * two arguments: parsed abbreviation tree (<code>AbbreviationNode</code>)\n\t\t * and <code>options</code> hash that was passed to <code>parse</code>\n\t\t * method\n\t\t */\n\t\taddPostprocessor: function(fn) {\n\t\t\tif (!_.include(postprocessors, fn))\n\t\t\t\tpostprocessors.push(fn);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Removes registered postprocessor function\n\t\t */\n\t\tremovePostprocessor: function(fn) {\n\t\t\tpostprocessors = _.without(postprocessors, fn);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Registers output postprocessor. <i>Output processor</i> is a \n\t\t * function that applies to output part (<code>start</code>, \n\t\t * <code>end</code> and <code>content</code>) when \n\t\t * <code>AbbreviationNode.toString()</code> method is called\n\t\t */\n\t\taddOutputProcessor: function(fn) {\n\t\t\tif (!_.include(outputProcessors, fn))\n\t\t\t\toutputProcessors.push(fn);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Removes registered output processor\n\t\t */\n\t\tremoveOutputProcessor: function(fn) {\n\t\t\toutputProcessors = _.without(outputProcessors, fn);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if passed symbol is valid symbol for abbreviation expression\n\t\t * @param {String} ch\n\t\t * @return {Boolean}\n\t\t */\n\t\tisAllowedChar: function(ch) {\n\t\t\tch = String(ch); // convert Java object to JS\n\t\t\treturn isAllowedChar(ch) || ~'>+^[](){}'.indexOf(ch);\n\t\t}\n\t};\n});/**\n * Processor function that matches parsed <code>AbbreviationNode</code>\n * against resources defined in <code>resource</code> module\n * @param {Function} require\n * @param {Underscore} _\n */ \nemmet.exec(function(require, _) {\n\t/**\n\t * Finds matched resources for child nodes of passed <code>node</code> \n\t * element. A matched resource is a reference to <i>snippets.json</i> entry\n\t * that describes output of parsed node \n\t * @param {AbbreviationNode} node\n\t * @param {String} syntax\n\t */\n\tfunction matchResources(node, syntax) {\n\t\tvar resources = require('resources');\n\t\tvar elements = require('elements');\n\t\tvar parser = require('abbreviationParser');\n\t\t\n\t\t// do a shallow copy because the children list can be modified during\n\t\t// resource matching\n\t\t_.each(_.clone(node.children), /** @param {AbbreviationNode} child */ function(child) {\n\t\t\tvar r = resources.getMatchedResource(child, syntax);\n\t\t\tif (_.isString(r)) {\n\t\t\t\tchild.data('resource', elements.create('snippet', r));\n\t\t\t} else if (elements.is(r, 'reference')) {\n\t\t\t\t// it’s a reference to another abbreviation:\n\t\t\t\t// parse it and insert instead of current child\n\t\t\t\t/** @type AbbreviationNode */\n\t\t\t\tvar subtree = parser.parse(r.data, {\n\t\t\t\t\tsyntax: syntax\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\t// if context element should be repeated, check if we need to \n\t\t\t\t// transfer repeated element to specific child node\n\t\t\t\tif (child.repeatCount > 1) {\n\t\t\t\t\tvar repeatedChildren = subtree.findAll(function(node) {\n\t\t\t\t\t\treturn node.hasImplicitRepeat;\n\t\t\t\t\t});\n\t\t\t\t\t\n\t\t\t\t\t_.each(repeatedChildren, function(node) {\n\t\t\t\t\t\tnode.repeatCount = child.repeatCount;\n\t\t\t\t\t\tnode.hasImplicitRepeat = false;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// move child‘s children into the deepest child of new subtree\n\t\t\t\tvar deepestChild = subtree.deepestChild();\n\t\t\t\tif (deepestChild) {\n\t\t\t\t\t_.each(child.children, function(c) {\n\t\t\t\t\t\tdeepestChild.addChild(c);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// copy current attributes to children\n\t\t\t\t_.each(subtree.children, function(node) {\n\t\t\t\t\t_.each(child.attributeList(), function(attr) {\n\t\t\t\t\t\tnode.attribute(attr.name, attr.value);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tchild.replace(subtree.children);\n\t\t\t} else {\n\t\t\t\tchild.data('resource', r);\n\t\t\t}\n\t\t\t\n\t\t\tmatchResources(child, syntax);\n\t\t});\n\t}\n\t\n\t// XXX register abbreviation filter that creates references to resources\n\t// on abbreviation nodes\n\t/**\n\t * @param {AbbreviationNode} tree\n\t */\n\trequire('abbreviationParser').addPreprocessor(function(tree, options) {\n\t\tvar syntax = options.syntax || emmet.defaultSyntax();\n\t\tmatchResources(tree, syntax);\n\t});\n\t\n});/**\n * Pasted content abbreviation processor. A pasted content is a content that\n * should be inserted into implicitly repeated abbreviation nodes.\n * This processor powers “Wrap With Abbreviation” action\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\tvar parser = require('abbreviationParser');\n\tvar outputPlaceholder = '$#';\n\t\n\t/**\n\t * Locates output placeholders inside text\n\t * @param {String} text\n\t * @returns {Array} Array of ranges of output placeholder in text\n\t */\n\tfunction locateOutputPlaceholder(text) {\n\t\tvar range = require('range');\n\t\tvar result = [];\n\t\t\n\t\t/** @type StringStream */\n\t\tvar stream = require('stringStream').create(text);\n\t\t\n\t\twhile (!stream.eol()) {\n\t\t\tif (stream.peek() == '\\\\') {\n\t\t\t\tstream.next();\n\t\t\t} else {\n\t\t\t\tstream.start = stream.pos;\n\t\t\t\tif (stream.match(outputPlaceholder, true)) {\n\t\t\t\t\tresult.push(range.create(stream.start, outputPlaceholder));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstream.next();\n\t\t}\n\t\t\n\t\treturn result;\n\t}\n\t\n\t/**\n\t * Replaces output placeholders inside <code>source</code> with \n\t * <code>value</code>\n\t * @param {String} source\n\t * @param {String} value\n\t * @returns {String}\n\t */\n\tfunction replaceOutputPlaceholders(source, value) {\n\t\tvar utils = require('utils');\n\t\tvar ranges = locateOutputPlaceholder(source);\n\t\t\n\t\tranges.reverse();\n\t\t_.each(ranges, function(r) {\n\t\t\tsource = utils.replaceSubstring(source, value, r);\n\t\t});\n\t\t\n\t\treturn source;\n\t}\n\t\n\t/**\n\t * Check if parsed node contains output placeholder – a target where\n\t * pasted content should be inserted\n\t * @param {AbbreviationNode} node\n\t * @returns {Boolean}\n\t */\n\tfunction hasOutputPlaceholder(node) {\n\t\tif (locateOutputPlaceholder(node.content).length)\n\t\t\treturn true;\n\t\t\n\t\t// check if attributes contains placeholder\n\t\treturn !!_.find(node.attributeList(), function(attr) {\n\t\t\treturn !!locateOutputPlaceholder(attr.value).length;\n\t\t});\n\t}\n\t\n\t/**\n\t * Insert pasted content into correct positions of parsed node\n\t * @param {AbbreviationNode} node\n\t * @param {String} content\n\t * @param {Boolean} overwrite Overwrite node content if no value placeholders\n\t * found instead of appending to existing content\n\t */\n\tfunction insertPastedContent(node, content, overwrite) {\n\t\tvar nodesWithPlaceholders = node.findAll(function(item) {\n\t\t\treturn hasOutputPlaceholder(item);\n\t\t});\n\t\t\n\t\tif (hasOutputPlaceholder(node))\n\t\t\tnodesWithPlaceholders.unshift(node);\n\t\t\n\t\tif (nodesWithPlaceholders.length) {\n\t\t\t_.each(nodesWithPlaceholders, function(item) {\n\t\t\t\titem.content = replaceOutputPlaceholders(item.content, content);\n\t\t\t\t_.each(item._attributes, function(attr) {\n\t\t\t\t\tattr.value = replaceOutputPlaceholders(attr.value, content);\n\t\t\t\t});\n\t\t\t});\n\t\t} else {\n\t\t\t// on output placeholders in subtree, insert content in the deepest\n\t\t\t// child node\n\t\t\tvar deepest = node.deepestChild() || node;\n\t\t\tif (overwrite) {\n\t\t\t\tdeepest.content = content;\n\t\t\t} else {\n\t\t\t\tdeepest.content = require('abbreviationUtils').insertChildContent(deepest.content, content);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * @param {AbbreviationNode} tree\n\t * @param {Object} options\n\t */\n\tparser.addPreprocessor(function(tree, options) {\n\t\tif (options.pastedContent) {\n\t\t\tvar utils = require('utils');\n\t\t\tvar lines = _.map(utils.splitByLines(options.pastedContent, true), utils.trim);\n\t\t\t\n\t\t\t// set repeat count for implicitly repeated elements before\n\t\t\t// tree is unrolled\n\t\t\ttree.findAll(function(item) {\n\t\t\t\tif (item.hasImplicitRepeat) {\n\t\t\t\t\titem.data('paste', lines);\n\t\t\t\t\treturn item.repeatCount = lines.length;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t});\n\t\n\t/**\n\t * @param {AbbreviationNode} tree\n\t * @param {Object} options\n\t */\n\tparser.addPostprocessor(function(tree, options) {\n\t\t// for each node with pasted content, update text data\n\t\tvar targets = tree.findAll(function(item) {\n\t\t\tvar pastedContentObj = item.data('paste');\n\t\t\tvar pastedContent = '';\n\t\t\tif (_.isArray(pastedContentObj)) {\n\t\t\t\tpastedContent = pastedContentObj[item.counter - 1];\n\t\t\t} else if (_.isFunction(pastedContentObj)) {\n\t\t\t\tpastedContent = pastedContentObj(item.counter - 1, item.content);\n\t\t\t} else if (pastedContentObj) {\n\t\t\t\tpastedContent = pastedContentObj;\n\t\t\t}\n\t\t\t\n\t\t\tif (pastedContent) {\n\t\t\t\tinsertPastedContent(item, pastedContent, !!item.data('pasteOverwrites'));\n\t\t\t}\n\t\t\t\n\t\t\titem.data('paste', null);\n\t\t\treturn !!pastedContentObj;\n\t\t});\n\t\t\n\t\tif (!targets.length && options.pastedContent) {\n\t\t\t// no implicitly repeated elements, put pasted content in\n\t\t\t// the deepest child\n\t\t\tinsertPastedContent(tree, options.pastedContent);\n\t\t}\n\t});\n});/**\n * Resolves tag names in abbreviations with implied name\n */\nemmet.exec(function(require, _) {\n\t/**\n\t * Resolves implicit node names in parsed tree\n\t * @param {AbbreviationNode} tree\n\t */\n\tfunction resolveNodeNames(tree) {\n\t\tvar tagName = require('tagName');\n\t\t_.each(tree.children, function(node) {\n\t\t\tif (node.hasImplicitName() || node.data('forceNameResolving')) {\n\t\t\t\tnode._name = tagName.resolve(node.parent.name());\n\t\t\t}\n\t\t\tresolveNodeNames(node);\n\t\t});\n\t\t\n\t\treturn tree;\n\t}\n\t\n\trequire('abbreviationParser').addPostprocessor(resolveNodeNames);\n});/**\n * @author Stoyan Stefanov\n * @link https://github.com/stoyan/etc/tree/master/cssex\n */\n\nemmet.define('cssParser', function(require, _) {\nvar walker, tokens = [], isOp, isNameChar, isDigit;\n    \n    // walks around the source\n    walker = {\n        lines: null,\n        total_lines: 0,\n        linenum: -1,\n        line: '',\n        ch: '',\n        chnum: -1,\n        init: function (source) {\n            var me = walker;\n        \n            // source, yumm\n            me.lines = source\n                .replace(/\\r\\n/g, '\\n')\n                .replace(/\\r/g, '\\n')\n                .split('\\n');\n            me.total_lines = me.lines.length;\n        \n            // reset\n            me.chnum = -1;\n            me.linenum = -1;\n            me.ch = '';\n            me.line = '';\n        \n            // advance\n            me.nextLine();\n            me.nextChar();\n        },\n        nextLine: function () {\n            var me = this;\n            me.linenum += 1;\n            if (me.total_lines <= me.linenum) {\n                me.line = false;\n            } else {\n                me.line = me.lines[me.linenum];\n            }\n            if (me.chnum !== -1) {\n                me.chnum = 0;\n            }\n            return me.line;\n        }, \n        nextChar: function () {\n            var me = this;\n            me.chnum += 1;\n            while (me.line.charAt(me.chnum) === '') {\n                if (this.nextLine() === false) {\n                    me.ch = false;\n                    return false; // end of source\n                }\n                me.chnum = -1;\n                me.ch = '\\n';\n                return '\\n';\n            }\n            me.ch = me.line.charAt(me.chnum);\n            return me.ch;\n        },\n        peek: function() {\n            return this.line.charAt(this.chnum + 1);\n        }\n    };\n\n    // utility helpers\n    isNameChar = function (c) {\n    \t// be more tolerate for name tokens: allow & character for LESS syntax\n        return (c == '&' || c === '_' || c === '-' || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'));\n    };\n\n    isDigit = function (ch) {\n        return (ch !== false && ch >= '0' && ch <= '9');\n    };  \n\n    isOp = (function () {\n        var opsa = \"{}[]()+*=.,;:>~|\\\\%$#@^!\".split(''),\n            opsmatcha = \"*^|$~\".split(''),\n            ops = {},\n            opsmatch = {},\n            i = 0;\n        for (; i < opsa.length; i += 1) {\n            ops[opsa[i]] = true;\n        }\n        for (i = 0; i < opsmatcha.length; i += 1) {\n            opsmatch[opsmatcha[i]] = true;\n        }\n        return function (ch, matchattr) {\n            if (matchattr) {\n                return !!opsmatch[ch];\n            }\n            return !!ops[ch];\n        };\n    }());\n    \n    // shorthands\n    function isset(v) {\n        return typeof v !== 'undefined';\n    }\n    function getConf() {\n        return {\n            'char': walker.chnum,\n            line: walker.linenum\n        };\n    }\n\n\n    // creates token objects and pushes them to a list\n    function tokener(value, type, conf) {\n        var w = walker, c = conf || {};\n        tokens.push({\n            charstart: isset(c['char']) ? c['char'] : w.chnum,\n            charend:   isset(c.charend) ? c.charend : w.chnum,\n            linestart: isset(c.line)    ? c.line    : w.linenum,\n            lineend:   isset(c.lineend) ? c.lineend : w.linenum,\n            value:     value,\n            type:      type || value\n        });\n    }\n    \n    // oops\n    function error(m, config) { \n        var w = walker,\n            conf = config || {},\n            c = isset(conf['char']) ? conf['char'] : w.chnum,\n            l = isset(conf.line) ? conf.line : w.linenum;\n        return {\n            name: \"ParseError\",\n            message: m + \" at line \" + (l + 1) + ' char ' + (c + 1),\n            walker: w,\n            tokens: tokens\n        };\n    }\n\n\n    // token handlers follow for:\n    // white space, comment, string, identifier, number, operator\n    function white() {\n    \n        var c = walker.ch,\n            token = '',\n            conf = getConf();\n    \n        while (c === \" \" || c === \"\\t\") {\n            token += c;\n            c = walker.nextChar();\n        }\n    \n        tokener(token, 'white', conf);\n    \n    }\n\n    function comment() {\n    \n        var w = walker,\n            c = w.ch,\n            token = c,\n            cnext,\n            conf = getConf();    \n     \n        cnext = w.nextChar();\n\n        if (cnext === '/') {\n            // inline comment in SCSS and such\n            token += cnext;\n            var pk = w.peek();\n            while (pk && pk !== '\\n') {\n                token += cnext;\n                cnext = w.nextChar();\n                pk = w.peek();\n            }\n        } else if (cnext === '*') {\n            // multiline CSS commment\n            while (!(c === \"*\" && cnext === \"/\")) {\n                token += cnext;\n                c = cnext;\n                cnext = w.nextChar();        \n            }            \n        } else {\n            // oops, not a comment, just a /\n            conf.charend = conf['char'];\n            conf.lineend = conf.line;\n            return tokener(token, token, conf);\n        }\n        \n        token += cnext;\n        w.nextChar();\n        tokener(token, 'comment', conf);\n    }\n\n    function str() {\n        var w = walker,\n            c = w.ch,\n            q = c,\n            token = c,\n            cnext,\n            conf = getConf();\n    \n        c = w.nextChar();\n    \n        while (c !== q) {\n            \n            if (c === '\\n') {\n                cnext = w.nextChar();\n                if (cnext === \"\\\\\") {\n                    token += c + cnext;\n                } else {\n                    // end of line with no \\ escape = bad\n                    throw error(\"Unterminated string\", conf);\n                }\n            } else {\n                if (c === \"\\\\\") {\n                    token += c + w.nextChar();\n                } else {\n                    token += c;\n                }\n            }\n        \n            c = w.nextChar();\n        \n        }\n        token += c;\n        w.nextChar();\n        tokener(token, 'string', conf);\n    }\n    \n    function brace() {\n        var w = walker,\n            c = w.ch,\n            depth = 0,\n            token = c,\n            conf = getConf();\n    \n        c = w.nextChar();\n    \n        while (c !== ')' && !depth) {\n        \tif (c === '(') {\n        \t\tdepth++;\n        \t} else if (c === ')') {\n        \t\tdepth--;\n        \t} else if (c === false) {\n        \t\tthrow error(\"Unterminated brace\", conf);\n        \t}\n        \t\n        \ttoken += c;\n            c = w.nextChar();\n        }\n        \n        token += c;\n        w.nextChar();\n        tokener(token, 'brace', conf);\n    }\n\n    function identifier(pre) {\n        var w = walker,\n            c = w.ch,\n            conf = getConf(),\n            token = (pre) ? pre + c : c;\n            \n        c = w.nextChar();\n    \n        if (pre) { // adjust token position\n        \tconf['char'] -= pre.length;\n        }\n        \n        while (isNameChar(c) || isDigit(c)) {\n            token += c;\n            c = w.nextChar();\n        }\n    \n        tokener(token, 'identifier', conf);    \n    }\n\n    function num() {\n        var w = walker,\n            c = w.ch,\n            conf = getConf(),\n            token = c,\n            point = token === '.',\n            nondigit;\n        \n        c = w.nextChar();\n        nondigit = !isDigit(c);\n    \n        // .2px or .classname?\n        if (point && nondigit) {\n            // meh, NaN, could be a class name, so it's an operator for now\n            conf.charend = conf['char'];\n            conf.lineend = conf.line;\n            return tokener(token, '.', conf);    \n        }\n        \n        // -2px or -moz-something\n        if (token === '-' && nondigit) {\n            return identifier('-');\n        }\n    \n        while (c !== false && (isDigit(c) || (!point && c === '.'))) { // not end of source && digit or first instance of .\n            if (c === '.') {\n                point = true;\n            }\n            token += c;\n            c = w.nextChar();\n        }\n\n        tokener(token, 'number', conf);    \n    \n    }\n\n    function op() {\n        var w = walker,\n            c = w.ch,\n            conf = getConf(),\n            token = c,\n            next = w.nextChar();\n            \n        if (next === \"=\" && isOp(token, true)) {\n            token += next;\n            tokener(token, 'match', conf);\n            w.nextChar();\n            return;\n        } \n        \n        conf.charend = conf['char'] + 1;\n        conf.lineend = conf.line;    \n        tokener(token, token, conf);\n    }\n\n\n    // call the appropriate handler based on the first character in a token suspect\n    function tokenize() {\n\n        var ch = walker.ch;\n    \n        if (ch === \" \" || ch === \"\\t\") {\n            return white();\n        }\n\n        if (ch === '/') {\n            return comment();\n        } \n\n        if (ch === '\"' || ch === \"'\") {\n            return str();\n        }\n        \n        if (ch === '(') {\n            return brace();\n        }\n    \n        if (ch === '-' || ch === '.' || isDigit(ch)) { // tricky - char: minus (-1px) or dash (-moz-stuff)\n            return num();\n        }\n    \n        if (isNameChar(ch)) {\n            return identifier();\n        }\n\n        if (isOp(ch)) {\n            return op();\n        }\n        \n        if (ch === \"\\n\") {\n            tokener(\"line\");\n            walker.nextChar();\n            return;\n        }\n        \n        throw error(\"Unrecognized character\");\n    }\n    \n    /**\n\t * Returns newline character at specified position in content\n\t * @param {String} content\n\t * @param {Number} pos\n\t * @return {String}\n\t */\n\tfunction getNewline(content, pos) {\n\t\treturn content.charAt(pos) == '\\r' && content.charAt(pos + 1) == '\\n' \n\t\t\t? '\\r\\n' \n\t\t\t: content.charAt(pos);\n\t}\n\n    return {\n    \t/**\n    \t * @param source\n    \t * @returns\n    \t * @memberOf emmet.cssParser\n    \t */\n        lex: function (source) {\n            walker.init(source);\n            tokens = [];\n            while (walker.ch !== false) {\n                tokenize();            \n            }\n            return tokens;\n        },\n        \n        /**\n         * Tokenizes CSS source\n         * @param {String} source\n         * @returns {Array}\n         */\n        parse: function(source) {\n        \t// transform tokens\n\t \t\tvar pos = 0;\n\t \t\treturn _.map(this.lex(source), function(token) {\n\t \t\t\tif (token.type == 'line') {\n\t \t\t\t\ttoken.value = getNewline(source, pos);\n\t \t\t\t}\n\t \t\t\t\n\t \t\t\treturn {\n\t \t\t\t\ttype: token.type,\n\t \t\t\t\tstart: pos,\n\t \t\t\t\tend: (pos += token.value.length)\n\t \t\t\t};\n\t\t\t});\n\t\t},\n        \n        toSource: function (toks) {\n            var i = 0, max = toks.length, t, src = '';\n            for (; i < max; i += 1) {\n                t = toks[i];\n                if (t.type === 'line') {\n                    src += '\\n';\n                } else {\n                    src += t.value;\n                }\n            }\n            return src;\n        }\n    };\n});/**\n * HTML tokenizer by Marijn Haverbeke\n * http://codemirror.net/\n * @constructor\n * @memberOf __xmlParseDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.define('xmlParser', function(require, _) {\n\tvar Kludges = {\n\t\tautoSelfClosers : {},\n\t\timplicitlyClosed : {},\n\t\tcontextGrabbers : {},\n\t\tdoNotIndent : {},\n\t\tallowUnquoted : true,\n\t\tallowMissing : true\n\t};\n\n\t// Return variables for tokenizers\n\tvar tagName = null, type = null;\n\n\tfunction inText(stream, state) {\n\t\tfunction chain(parser) {\n\t\t\tstate.tokenize = parser;\n\t\t\treturn parser(stream, state);\n\t\t}\n\n\t\tvar ch = stream.next();\n\t\tif (ch == \"<\") {\n\t\t\tif (stream.eat(\"!\")) {\n\t\t\t\tif (stream.eat(\"[\")) {\n\t\t\t\t\tif (stream.match(\"CDATA[\"))\n\t\t\t\t\t\treturn chain(inBlock(\"atom\", \"]]>\"));\n\t\t\t\t\telse\n\t\t\t\t\t\treturn null;\n\t\t\t\t} else if (stream.match(\"--\"))\n\t\t\t\t\treturn chain(inBlock(\"comment\", \"-->\"));\n\t\t\t\telse if (stream.match(\"DOCTYPE\", true, true)) {\n\t\t\t\t\tstream.eatWhile(/[\\w\\._\\-]/);\n\t\t\t\t\treturn chain(doctype(1));\n\t\t\t\t} else\n\t\t\t\t\treturn null;\n\t\t\t} else if (stream.eat(\"?\")) {\n\t\t\t\tstream.eatWhile(/[\\w\\._\\-]/);\n\t\t\t\tstate.tokenize = inBlock(\"meta\", \"?>\");\n\t\t\t\treturn \"meta\";\n\t\t\t} else {\n\t\t\t\ttype = stream.eat(\"/\") ? \"closeTag\" : \"openTag\";\n\t\t\t\tstream.eatSpace();\n\t\t\t\ttagName = \"\";\n\t\t\t\tvar c;\n\t\t\t\twhile ((c = stream.eat(/[^\\s\\u00a0=<>\\\"\\'\\/?]/)))\n\t\t\t\t\ttagName += c;\n\t\t\t\tstate.tokenize = inTag;\n\t\t\t\treturn \"tag\";\n\t\t\t}\n\t\t} else if (ch == \"&\") {\n\t\t\tvar ok;\n\t\t\tif (stream.eat(\"#\")) {\n\t\t\t\tif (stream.eat(\"x\")) {\n\t\t\t\t\tok = stream.eatWhile(/[a-fA-F\\d]/) && stream.eat(\";\");\n\t\t\t\t} else {\n\t\t\t\t\tok = stream.eatWhile(/[\\d]/) && stream.eat(\";\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tok = stream.eatWhile(/[\\w\\.\\-:]/) && stream.eat(\";\");\n\t\t\t}\n\t\t\treturn ok ? \"atom\" : \"error\";\n\t\t} else {\n\t\t\tstream.eatWhile(/[^&<]/);\n\t\t\treturn \"text\";\n\t\t}\n\t}\n\n\tfunction inTag(stream, state) {\n\t\tvar ch = stream.next();\n\t\tif (ch == \">\" || (ch == \"/\" && stream.eat(\">\"))) {\n\t\t\tstate.tokenize = inText;\n\t\t\ttype = ch == \">\" ? \"endTag\" : \"selfcloseTag\";\n\t\t\treturn \"tag\";\n\t\t} else if (ch == \"=\") {\n\t\t\ttype = \"equals\";\n\t\t\treturn null;\n\t\t} else if (/[\\'\\\"]/.test(ch)) {\n\t\t\tstate.tokenize = inAttribute(ch);\n\t\t\treturn state.tokenize(stream, state);\n\t\t} else {\n\t\t\tstream.eatWhile(/[^\\s\\u00a0=<>\\\"\\'\\/?]/);\n\t\t\treturn \"word\";\n\t\t}\n\t}\n\n\tfunction inAttribute(quote) {\n\t\treturn function(stream, state) {\n\t\t\twhile (!stream.eol()) {\n\t\t\t\tif (stream.next() == quote) {\n\t\t\t\t\tstate.tokenize = inTag;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn \"string\";\n\t\t};\n\t}\n\n\tfunction inBlock(style, terminator) {\n\t\treturn function(stream, state) {\n\t\t\twhile (!stream.eol()) {\n\t\t\t\tif (stream.match(terminator)) {\n\t\t\t\t\tstate.tokenize = inText;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstream.next();\n\t\t\t}\n\t\t\treturn style;\n\t\t};\n\t}\n\t\n\tfunction doctype(depth) {\n\t\treturn function(stream, state) {\n\t\t\tvar ch;\n\t\t\twhile ((ch = stream.next()) != null) {\n\t\t\t\tif (ch == \"<\") {\n\t\t\t\t\tstate.tokenize = doctype(depth + 1);\n\t\t\t\t\treturn state.tokenize(stream, state);\n\t\t\t\t} else if (ch == \">\") {\n\t\t\t\t\tif (depth == 1) {\n\t\t\t\t\t\tstate.tokenize = inText;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstate.tokenize = doctype(depth - 1);\n\t\t\t\t\t\treturn state.tokenize(stream, state);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn \"meta\";\n\t\t};\n\t}\n\n\tvar curState = null, setStyle;\n\tfunction pass() {\n\t\tfor (var i = arguments.length - 1; i >= 0; i--)\n\t\t\tcurState.cc.push(arguments[i]);\n\t}\n\t\n\tfunction cont() {\n\t\tpass.apply(null, arguments);\n\t\treturn true;\n\t}\n\n\tfunction pushContext(tagName, startOfLine) {\n\t\tvar noIndent = Kludges.doNotIndent.hasOwnProperty(tagName) \n\t\t\t|| (curState.context && curState.context.noIndent);\n\t\tcurState.context = {\n\t\t\tprev : curState.context,\n\t\t\ttagName : tagName,\n\t\t\tindent : curState.indented,\n\t\t\tstartOfLine : startOfLine,\n\t\t\tnoIndent : noIndent\n\t\t};\n\t}\n\t\n\tfunction popContext() {\n\t\tif (curState.context)\n\t\t\tcurState.context = curState.context.prev;\n\t}\n\n\tfunction element(type) {\n\t\tif (type == \"openTag\") {\n\t\t\tcurState.tagName = tagName;\n\t\t\treturn cont(attributes, endtag(curState.startOfLine));\n\t\t} else if (type == \"closeTag\") {\n\t\t\tvar err = false;\n\t\t\tif (curState.context) {\n\t\t\t\tif (curState.context.tagName != tagName) {\n\t\t\t\t\tif (Kludges.implicitlyClosed.hasOwnProperty(curState.context.tagName.toLowerCase())) {\n\t\t\t\t\t\tpopContext();\n\t\t\t\t\t}\n\t\t\t\t\terr = !curState.context || curState.context.tagName != tagName;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\terr = true;\n\t\t\t}\n\t\t\t\n\t\t\tif (err)\n\t\t\t\tsetStyle = \"error\";\n\t\t\treturn cont(endclosetag(err));\n\t\t}\n\t\treturn cont();\n\t}\n\t\n\tfunction endtag(startOfLine) {\n\t\treturn function(type) {\n\t\t\tif (type == \"selfcloseTag\"\n\t\t\t\t\t|| (type == \"endTag\" && Kludges.autoSelfClosers\n\t\t\t\t\t\t\t.hasOwnProperty(curState.tagName\n\t\t\t\t\t\t\t\t\t.toLowerCase()))) {\n\t\t\t\tmaybePopContext(curState.tagName.toLowerCase());\n\t\t\t\treturn cont();\n\t\t\t}\n\t\t\tif (type == \"endTag\") {\n\t\t\t\tmaybePopContext(curState.tagName.toLowerCase());\n\t\t\t\tpushContext(curState.tagName, startOfLine);\n\t\t\t\treturn cont();\n\t\t\t}\n\t\t\treturn cont();\n\t\t};\n\t}\n\t\n\tfunction endclosetag(err) {\n\t\treturn function(type) {\n\t\t\tif (err)\n\t\t\t\tsetStyle = \"error\";\n\t\t\tif (type == \"endTag\") {\n\t\t\t\tpopContext();\n\t\t\t\treturn cont();\n\t\t\t}\n\t\t\tsetStyle = \"error\";\n\t\t\treturn cont(arguments.callee);\n\t\t};\n\t}\n\t\n\tfunction maybePopContext(nextTagName) {\n\t\tvar parentTagName;\n\t\twhile (true) {\n\t\t\tif (!curState.context) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tparentTagName = curState.context.tagName.toLowerCase();\n\t\t\tif (!Kludges.contextGrabbers.hasOwnProperty(parentTagName)\n\t\t\t\t\t|| !Kludges.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tpopContext();\n\t\t}\n\t}\n\n\tfunction attributes(type) {\n\t\tif (type == \"word\") {\n\t\t\tsetStyle = \"attribute\";\n\t\t\treturn cont(attribute, attributes);\n\t\t}\n\t\tif (type == \"endTag\" || type == \"selfcloseTag\")\n\t\t\treturn pass();\n\t\tsetStyle = \"error\";\n\t\treturn cont(attributes);\n\t}\n\t\n\tfunction attribute(type) {\n\t\tif (type == \"equals\")\n\t\t\treturn cont(attvalue, attributes);\n\t\tif (!Kludges.allowMissing)\n\t\t\tsetStyle = \"error\";\n\t\treturn (type == \"endTag\" || type == \"selfcloseTag\") ? pass()\n\t\t\t\t: cont();\n\t}\n\t\n\tfunction attvalue(type) {\n\t\tif (type == \"string\")\n\t\t\treturn cont(attvaluemaybe);\n\t\tif (type == \"word\" && Kludges.allowUnquoted) {\n\t\t\tsetStyle = \"string\";\n\t\t\treturn cont();\n\t\t}\n\t\tsetStyle = \"error\";\n\t\treturn (type == \"endTag\" || type == \"selfCloseTag\") ? pass()\n\t\t\t\t: cont();\n\t}\n\t\n\tfunction attvaluemaybe(type) {\n\t\tif (type == \"string\")\n\t\t\treturn cont(attvaluemaybe);\n\t\telse\n\t\t\treturn pass();\n\t}\n\t\n\tfunction startState() {\n\t\treturn {\n\t\t\ttokenize : inText,\n\t\t\tcc : [],\n\t\t\tindented : 0,\n\t\t\tstartOfLine : true,\n\t\t\ttagName : null,\n\t\t\tcontext : null\n\t\t};\n\t}\n\t\n\tfunction token(stream, state) {\n\t\tif (stream.sol()) {\n\t\t\tstate.startOfLine = true;\n\t\t\tstate.indented = 0;\n\t\t}\n\t\t\n\t\tif (stream.eatSpace())\n\t\t\treturn null;\n\n\t\tsetStyle = type = tagName = null;\n\t\tvar style = state.tokenize(stream, state);\n\t\tstate.type = type;\n\t\tif ((style || type) && style != \"comment\") {\n\t\t\tcurState = state;\n\t\t\twhile (true) {\n\t\t\t\tvar comb = state.cc.pop() || element;\n\t\t\t\tif (comb(type || style))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tstate.startOfLine = false;\n\t\treturn setStyle || style;\n\t}\n\n\treturn {\n\t\t/**\n\t\t * @memberOf emmet.xmlParser\n\t\t * @returns\n\t\t */\n\t\tparse: function(data, offset) {\n\t\t\toffset = offset || 0;\n\t\t\tvar state = startState();\n\t\t\tvar stream = require('stringStream').create(data);\n\t\t\tvar tokens = [];\n\t\t\twhile (!stream.eol()) {\n\t\t\t\ttokens.push({\n\t\t\t\t\ttype: token(stream, state),\n\t\t\t\t\tstart: stream.start + offset,\n\t\t\t\t\tend: stream.pos + offset\n\t\t\t\t});\n\t\t\t\tstream.start = stream.pos;\n\t\t\t}\n\t\t\t\n\t\t\treturn tokens;\n\t\t}\t\t\n\t};\n});\n/*!\n * string_score.js: String Scoring Algorithm 0.1.10 \n *\n * http://joshaven.com/string_score\n * https://github.com/joshaven/string_score\n *\n * Copyright (C) 2009-2011 Joshaven Potter <yourtech@gmail.com>\n * Special thanks to all of the contributors listed here https://github.com/joshaven/string_score\n * MIT license: http://www.opensource.org/licenses/mit-license.php\n *\n * Date: Tue Mar 1 2011\n*/\n\n/**\n * Scores a string against another string.\n *  'Hello World'.score('he');     //=> 0.5931818181818181\n *  'Hello World'.score('Hello');  //=> 0.7318181818181818\n */\nemmet.define('string-score', function(require, _) {\n\treturn {\n\t\tscore: function(string, abbreviation, fuzziness) {\n\t\t\t// If the string is equal to the abbreviation, perfect match.\n\t\t\t  if (string == abbreviation) {return 1;}\n\t\t\t  //if it's not a perfect match and is empty return 0\n\t\t\t  if(abbreviation == \"\") {return 0;}\n\n\t\t\t  var total_character_score = 0,\n\t\t\t      abbreviation_length = abbreviation.length,\n\t\t\t      string_length = string.length,\n\t\t\t      start_of_string_bonus,\n\t\t\t      abbreviation_score,\n\t\t\t      fuzzies=1,\n\t\t\t      final_score;\n\t\t\t  \n\t\t\t  // Walk through abbreviation and add up scores.\n\t\t\t  for (var i = 0,\n\t\t\t         character_score/* = 0*/,\n\t\t\t         index_in_string/* = 0*/,\n\t\t\t         c/* = ''*/,\n\t\t\t         index_c_lowercase/* = 0*/,\n\t\t\t         index_c_uppercase/* = 0*/,\n\t\t\t         min_index/* = 0*/;\n\t\t\t     i < abbreviation_length;\n\t\t\t     ++i) {\n\t\t\t    \n\t\t\t    // Find the first case-insensitive match of a character.\n\t\t\t    c = abbreviation.charAt(i);\n\t\t\t    \n\t\t\t    index_c_lowercase = string.indexOf(c.toLowerCase());\n\t\t\t    index_c_uppercase = string.indexOf(c.toUpperCase());\n\t\t\t    min_index = Math.min(index_c_lowercase, index_c_uppercase);\n\t\t\t    index_in_string = (min_index > -1) ? min_index : Math.max(index_c_lowercase, index_c_uppercase);\n\t\t\t    \n\t\t\t    if (index_in_string === -1) { \n\t\t\t      if (fuzziness) {\n\t\t\t        fuzzies += 1-fuzziness;\n\t\t\t        continue;\n\t\t\t      } else {\n\t\t\t        return 0;\n\t\t\t      }\n\t\t\t    } else {\n\t\t\t      character_score = 0.1;\n\t\t\t    }\n\t\t\t    \n\t\t\t    // Set base score for matching 'c'.\n\t\t\t    \n\t\t\t    // Same case bonus.\n\t\t\t    if (string[index_in_string] === c) { \n\t\t\t      character_score += 0.1; \n\t\t\t    }\n\t\t\t    \n\t\t\t    // Consecutive letter & start-of-string Bonus\n\t\t\t    if (index_in_string === 0) {\n\t\t\t      // Increase the score when matching first character of the remainder of the string\n\t\t\t      character_score += 0.6;\n\t\t\t      if (i === 0) {\n\t\t\t        // If match is the first character of the string\n\t\t\t        // & the first character of abbreviation, add a\n\t\t\t        // start-of-string match bonus.\n\t\t\t        start_of_string_bonus = 1; //true;\n\t\t\t      }\n\t\t\t    }\n\t\t\t    else {\n\t\t\t  // Acronym Bonus\n\t\t\t  // Weighing Logic: Typing the first character of an acronym is as if you\n\t\t\t  // preceded it with two perfect character matches.\n\t\t\t  if (string.charAt(index_in_string - 1) === ' ') {\n\t\t\t    character_score += 0.8; // * Math.min(index_in_string, 5); // Cap bonus at 0.4 * 5\n\t\t\t  }\n\t\t\t    }\n\t\t\t    \n\t\t\t    // Left trim the already matched part of the string\n\t\t\t    // (forces sequential matching).\n\t\t\t    string = string.substring(index_in_string + 1, string_length);\n\t\t\t    \n\t\t\t    total_character_score += character_score;\n\t\t\t  } // end of for loop\n\t\t\t  \n\t\t\t  // Uncomment to weigh smaller words higher.\n\t\t\t  // return total_character_score / string_length;\n\t\t\t  \n\t\t\t  abbreviation_score = total_character_score / abbreviation_length;\n\t\t\t  //percentage_of_matched_string = abbreviation_length / string_length;\n\t\t\t  //word_score = abbreviation_score * percentage_of_matched_string;\n\t\t\t  \n\t\t\t  // Reduce penalty for longer strings.\n\t\t\t  //final_score = (word_score + abbreviation_score) / 2;\n\t\t\t  final_score = ((abbreviation_score * (abbreviation_length / string_length)) + abbreviation_score) / 2;\n\t\t\t  \n\t\t\t  final_score = final_score / fuzzies;\n\t\t\t  \n\t\t\t  if (start_of_string_bonus && (final_score + 0.15 < 1)) {\n\t\t\t    final_score += 0.15;\n\t\t\t  }\n\t\t\t  \n\t\t\t  return final_score;\n\t\t}\n\t};\n});/**\n * Utility module for Emmet\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.define('utils', function(require, _) {\n\t/** \n\t * Special token used as a placeholder for caret positions inside \n\t * generated output \n\t */\n\tvar caretPlaceholder = '${0}';\n\t\n\t/**\n\t * A simple string builder, optimized for faster text concatenation\n\t * @param {String} value Initial value\n\t */\n\tfunction StringBuilder(value) {\n\t\tthis._data = [];\n\t\tthis.length = 0;\n\t\t\n\t\tif (value)\n\t\t\tthis.append(value);\n\t}\n\t\n\tStringBuilder.prototype = {\n\t\t/**\n\t\t * Append string\n\t\t * @param {String} text\n\t\t */\n\t\tappend: function(text) {\n\t\t\tthis._data.push(text);\n\t\t\tthis.length += text.length;\n\t\t},\n\t\t\n\t\t/**\n\t\t * @returns {String}\n\t\t */\n\t\ttoString: function() {\n\t\t\treturn this._data.join('');\n\t\t},\n\t\t\n\t\t/**\n\t\t * @returns {String}\n\t\t */\n\t\tvalueOf: function() {\n\t\t\treturn this.toString();\n\t\t}\n\t};\n\t\n\treturn {\n\t\t/** @memberOf utils */\n\t\treTag: /<\\/?[\\w:\\-]+(?:\\s+[\\w\\-:]+(?:\\s*=\\s*(?:(?:\"[^\"]*\")|(?:'[^']*')|[^>\\s]+))?)*\\s*(\\/?)>$/,\n\t\t\n\t\t/**\n\t\t * Test if passed string ends with XHTML tag. This method is used for testing\n\t\t * '>' character: it belongs to tag or it's a part of abbreviation? \n\t\t * @param {String} str\n\t\t * @return {Boolean}\n\t\t */\n\t\tendsWithTag: function(str) {\n\t\t\treturn this.reTag.test(str);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if passed symbol is a number\n\t\t * @param {String} ch\n\t\t * @returns {Boolean}\n\t\t */\n\t\tisNumeric: function(ch) {\n\t\t\tif (typeof(ch) == 'string')\n\t\t\t\tch = ch.charCodeAt(0);\n\t\t\t\t\n\t\t\treturn (ch && ch > 47 && ch < 58);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Trim whitespace from string\n\t\t * @param {String} text\n\t\t * @return {String}\n\t\t */\n\t\ttrim: function(text) {\n\t\t\treturn (text || \"\").replace(/^\\s+|\\s+$/g, \"\");\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns newline character\n\t\t * @returns {String}\n\t\t */\n\t\tgetNewline: function() {\n\t\t\tvar res = require('resources');\n\t\t\tif (!res) {\n\t\t\t\treturn '\\n';\n\t\t\t}\n\t\t\t\n\t\t\tvar nl = res.getVariable('newline');\n\t\t\treturn _.isString(nl) ? nl : '\\n';\n\t\t},\n\t\t\n\t\t/**\n\t\t * Sets new newline character that will be used in output\n\t\t * @param {String} str\n\t\t */\n\t\tsetNewline: function(str) {\n\t\t\tvar res = require('resources');\n\t\t\tres.setVariable('newline', str);\n\t\t\tres.setVariable('nl', str);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Split text into lines. Set <code>remove_empty</code> to true to filter\n\t\t * empty lines\n\t\t * @param {String} text Text to split\n\t\t * @param {Boolean} removeEmpty Remove empty lines from result\n\t\t * @return {Array}\n\t\t */\n\t\tsplitByLines: function(text, removeEmpty) {\n\t\t\t// IE fails to split string by regexp, \n\t\t\t// need to normalize newlines first\n\t\t\t// Also, Mozilla's Rhiho JS engine has a weird newline bug\n\t\t\tvar nl = this.getNewline();\n\t\t\tvar lines = (text || '')\n\t\t\t\t.replace(/\\r\\n/g, '\\n')\n\t\t\t\t.replace(/\\n\\r/g, '\\n')\n\t\t\t\t.replace(/\\r/g, '\\n')\n\t\t\t\t.replace(/\\n/g, nl)\n\t\t\t\t.split(nl);\n\t\t\t\n\t\t\tif (removeEmpty) {\n\t\t\t\tlines = _.filter(lines, function(line) {\n\t\t\t\t\treturn line.length && !!this.trim(line);\n\t\t\t\t}, this);\n\t\t\t}\n\t\t\t\n\t\t\treturn lines;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Normalizes newline character: replaces newlines in <code>text</code> \n\t\t * with newline defined in preferences\n\t\t * @param {String} text\n\t\t * @returns {String}\n\t\t */\n\t\tnormalizeNewline: function(text) {\n\t\t\treturn this.splitByLines(text).join(this.getNewline());\n\t\t},\n\t\t\n\t\t/**\n\t\t * Repeats string <code>howMany</code> times\n\t\t * @param {String} str\n\t\t * @param {Number} how_many\n\t\t * @return {String}\n\t\t */\n\t\trepeatString: function(str, howMany) {\n\t\t\tvar result = [];\n\t\t\t\n\t\t\tfor (var i = 0; i < howMany; i++) \n\t\t\t\tresult.push(str);\n\t\t\t\t\n\t\t\treturn result.join('');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns list of paddings that should be used to align passed string\n\t\t * @param {Array} strings\n\t\t * @returns {Array}\n\t\t */\n\t\tgetStringsPads: function(strings) {\n\t\t\tvar lengths = _.map(strings, function(s) {\n\t\t\t\treturn _.isString(s) ? s.length : +s;\n\t\t\t});\n\t\t\t\n\t\t\tvar max = _.max(lengths);\n\t\t\treturn _.map(lengths, function(l) {\n\t\t\t\tvar pad = max - l;\n\t\t\t\treturn pad ? this.repeatString(' ', pad) : '';\n\t\t\t}, this);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Indents text with padding\n\t\t * @param {String} text Text to indent\n\t\t * @param {String} pad Padding size (number) or padding itself (string)\n\t\t * @return {String}\n\t\t */\n\t\tpadString: function(text, pad) {\n\t\t\tvar padStr = (_.isNumber(pad)) \n\t\t\t\t? this.repeatString(require('resources').getVariable('indentation') || '\\t', pad) \n\t\t\t\t: pad;\n\t\t\t\t\n\t\t\tvar result = [];\n\t\t\t\n\t\t\tvar lines = this.splitByLines(text);\n\t\t\tvar nl = this.getNewline();\n\t\t\t\t\n\t\t\tresult.push(lines[0]);\n\t\t\tfor (var j = 1; j < lines.length; j++) \n\t\t\t\tresult.push(nl + padStr + lines[j]);\n\t\t\t\t\n\t\t\treturn result.join('');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Pad string with zeroes\n\t\t * @param {String} str String to pad\n\t\t * @param {Number} pad Desired string length\n\t\t * @return {String}\n\t\t */\n\t\tzeroPadString: function(str, pad) {\n\t\t\tvar padding = '';\n\t\t\tvar il = str.length;\n\t\t\t\t\n\t\t\twhile (pad > il++) padding += '0';\n\t\t\treturn padding + str; \n\t\t},\n\t\t\n\t\t/**\n\t\t * Removes padding at the beginning of each text's line\n\t\t * @param {String} text\n\t\t * @param {String} pad\n\t\t */\n\t\tunindentString: function(text, pad) {\n\t\t\tvar lines = this.splitByLines(text);\n\t\t\tfor (var i = 0; i < lines.length; i++) {\n\t\t\t\tif (lines[i].search(pad) == 0)\n\t\t\t\t\tlines[i] = lines[i].substr(pad.length);\n\t\t\t}\n\t\t\t\n\t\t\treturn lines.join(this.getNewline());\n\t\t},\n\t\t\n\t\t/**\n\t\t * Replaces unescaped symbols in <code>str</code>. For example, the '$' symbol\n\t\t * will be replaced in 'item$count', but not in 'item\\$count'.\n\t\t * @param {String} str Original string\n\t\t * @param {String} symbol Symbol to replace\n\t\t * @param {String} replace Symbol replacement. Might be a function that \n\t\t * returns new value\n\t\t * @return {String}\n\t\t */\n\t\treplaceUnescapedSymbol: function(str, symbol, replace) {\n\t\t\tvar i = 0;\n\t\t\tvar il = str.length;\n\t\t\tvar sl = symbol.length;\n\t\t\tvar matchCount = 0;\n\t\t\t\t\n\t\t\twhile (i < il) {\n\t\t\t\tif (str.charAt(i) == '\\\\') {\n\t\t\t\t\t// escaped symbol, skip next character\n\t\t\t\t\ti += sl + 1;\n\t\t\t\t} else if (str.substr(i, sl) == symbol) {\n\t\t\t\t\t// have match\n\t\t\t\t\tvar curSl = sl;\n\t\t\t\t\tmatchCount++;\n\t\t\t\t\tvar newValue = replace;\n\t\t\t\t\tif (_.isFunction(replace)) {\n\t\t\t\t\t\tvar replaceData = replace(str, symbol, i, matchCount);\n\t\t\t\t\t\tif (replaceData) {\n\t\t\t\t\t\t\tcurSl = replaceData[0].length;\n\t\t\t\t\t\t\tnewValue = replaceData[1];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnewValue = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (newValue === false) { // skip replacement\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tstr = str.substring(0, i) + newValue + str.substring(i + curSl);\n\t\t\t\t\t// adjust indexes\n\t\t\t\t\til = str.length;\n\t\t\t\t\ti += newValue.length;\n\t\t\t\t} else {\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn str;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Replace variables like ${var} in string\n\t\t * @param {String} str\n\t\t * @param {Object} vars Variable set (defaults to variables defined in \n\t\t * <code>snippets.json</code>) or variable resolver (<code>Function</code>)\n\t\t * @return {String}\n\t\t */\n\t\treplaceVariables: function(str, vars) {\n\t\t\tvars = vars || {};\n\t\t\tvar resolver = _.isFunction(vars) ? vars : function(str, p1) {\n\t\t\t\treturn p1 in vars ? vars[p1] : null;\n\t\t\t};\n\t\t\t\n\t\t\tvar res = require('resources');\n\t\t\treturn require('tabStops').processText(str, {\n\t\t\t\tvariable: function(data) {\n\t\t\t\t\tvar newValue = resolver(data.token, data.name, data);\n\t\t\t\t\tif (newValue === null) {\n\t\t\t\t\t\t// try to find variable in resources\n\t\t\t\t\t\tnewValue = res.getVariable(data.name);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (newValue === null || _.isUndefined(newValue))\n\t\t\t\t\t\t// nothing found, return token itself\n\t\t\t\t\t\tnewValue = data.token;\n\t\t\t\t\treturn newValue;\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Replaces '$' character in string assuming it might be escaped with '\\'\n\t\t * @param {String} str String where character should be replaced\n\t\t * @param {String} value New value\n\t\t * @return {String}\n\t\t */\n\t\treplaceCounter: function(str, value, total) {\n\t\t\tvar symbol = '$';\n\t\t\t// in case we received strings from Java, convert the to native strings\n\t\t\tstr = String(str);\n\t\t\tvalue = String(value);\n\t\t\t\n\t\t\tif (/^\\-?\\d+$/.test(value)) {\n\t\t\t\tvalue = +value;\n\t\t\t}\n\t\t\t\n\t\t\tvar that = this;\n\t\t\t\n\t\t\treturn this.replaceUnescapedSymbol(str, symbol, function(str, symbol, pos, matchNum){\n\t\t\t\tif (str.charAt(pos + 1) == '{' || that.isNumeric(str.charAt(pos + 1)) ) {\n\t\t\t\t\t// it's a variable, skip it\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// replace sequense of $ symbols with padded number  \n\t\t\t\tvar j = pos + 1;\n\t\t\t\twhile(str.charAt(j) == '$' && str.charAt(j + 1) != '{') j++;\n\t\t\t\tvar pad = j - pos;\n\t\t\t\t\n\t\t\t\t// get counter base\n\t\t\t\tvar base = 0, decrement = false, m;\n\t\t\t\tif (m = str.substr(j).match(/^@(\\-?)(\\d*)/)) {\n\t\t\t\t\tj += m[0].length;\n\t\t\t\t\t\n\t\t\t\t\tif (m[1]) {\n\t\t\t\t\t\tdecrement = true;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tbase = parseInt(m[2] || 1) - 1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (decrement && total && _.isNumber(value)) {\n\t\t\t\t\tvalue = total - value + 1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvalue += base;\n\t\t\t\t\n\t\t\t\treturn [str.substring(pos, j), that.zeroPadString(value + '', pad)];\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if string matches against <code>reTag</code> regexp. This \n\t\t * function may be used to test if provided string contains HTML tags\n\t\t * @param {String} str\n\t\t * @returns {Boolean}\n\t\t */\n\t\tmatchesTag: function(str) {\n\t\t\treturn this.reTag.test(str || '');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Escapes special characters used in Emmet, like '$', '|', etc.\n\t\t * Use this method before passing to actions like \"Wrap with Abbreviation\"\n\t\t * to make sure that existing special characters won't be altered\n\t\t * @param {String} text\n\t\t * @return {String}\n\t\t */\n\t\tescapeText: function(text) {\n\t\t\treturn text.replace(/([\\$\\\\])/g, '\\\\$1');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Unescapes special characters used in Emmet, like '$', '|', etc.\n\t\t * @param {String} text\n\t\t * @return {String}\n\t\t */\n\t\tunescapeText: function(text) {\n\t\t\treturn text.replace(/\\\\(.)/g, '$1');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns caret placeholder\n\t\t * @returns {String}\n\t\t */\n\t\tgetCaretPlaceholder: function() {\n\t\t\treturn _.isFunction(caretPlaceholder) \n\t\t\t\t? caretPlaceholder.apply(this, arguments)\n\t\t\t\t: caretPlaceholder;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Sets new representation for carets in generated output\n\t\t * @param {String} value New caret placeholder. Might be a \n\t\t * <code>Function</code>\n\t\t */\n\t\tsetCaretPlaceholder: function(value) {\n\t\t\tcaretPlaceholder = value;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns line padding\n\t\t * @param {String} line\n\t\t * @return {String}\n\t\t */\n\t\tgetLinePadding: function(line) {\n\t\t\treturn (line.match(/^(\\s+)/) || [''])[0];\n\t\t},\n\t\t\n\t\t/**\n\t\t * Helper function that returns padding of line of <code>pos</code>\n\t\t * position in <code>content</code>\n\t\t * @param {String} content\n\t\t * @param {Number} pos\n\t\t * @returns {String}\n\t\t */\n\t\tgetLinePaddingFromPosition: function(content, pos) {\n\t\t\tvar lineRange = this.findNewlineBounds(content, pos);\n\t\t\treturn this.getLinePadding(lineRange.substring(content));\n\t\t},\n\t\t\n\t\t/**\n\t\t * Escape special regexp chars in string, making it usable for creating dynamic\n\t\t * regular expressions\n\t\t * @param {String} str\n\t\t * @return {String}\n\t\t */\n\t\tescapeForRegexp: function(str) {\n\t\t\tvar specials = new RegExp(\"[.*+?|()\\\\[\\\\]{}\\\\\\\\]\", \"g\"); // .*+?|()[]{}\\\n\t\t\treturn str.replace(specials, \"\\\\$&\");\n\t\t},\n\t\t\n\t\t/**\n\t\t * Make decimal number look good: convert it to fixed precision end remove\n\t\t * traling zeroes \n\t\t * @param {Number} num\n\t\t * @param {Number} fracion Fraction numbers (default is 2)\n\t\t * @return {String}\n\t\t */\n\t\tprettifyNumber: function(num, fraction) {\n\t\t\treturn num.toFixed(typeof fraction == 'undefined' ? 2 : fraction).replace(/\\.?0+$/, '');\n\t\t},\n\t\t\n\t\t/**\n\t\t * A simple mutable string shim, optimized for faster text concatenation\n\t\t * @param {String} value Initial value\n\t\t * @returns {StringBuilder}\n\t\t */\n\t\tstringBuilder: function(value) {\n\t\t\treturn new StringBuilder(value);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Replace substring of <code>str</code> with <code>value</code>\n\t\t * @param {String} str String where to replace substring\n\t\t * @param {String} value New substring value\n\t\t * @param {Number} start Start index of substring to replace. May also\n\t\t * be a <code>Range</code> object: in this case, the <code>end</code>\n\t\t * argument is not required\n\t\t * @param {Number} end End index of substring to replace. If ommited, \n\t\t * <code>start</code> argument is used\n\t\t */\n\t\treplaceSubstring: function(str, value, start, end) {\n\t\t\tif (_.isObject(start) && 'end' in start) {\n\t\t\t\tend = start.end;\n\t\t\t\tstart = start.start;\n\t\t\t}\n\t\t\t\n\t\t\tif (_.isString(end))\n\t\t\t\tend = start + end.length;\n\t\t\t\n\t\t\tif (_.isUndefined(end))\n\t\t\t\tend = start;\n\t\t\t\n\t\t\tif (start < 0 || start > str.length)\n\t\t\t\treturn str;\n\t\t\t\n\t\t\treturn str.substring(0, start) + value + str.substring(end);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Narrows down text range, adjusting selection to non-space characters\n\t\t * @param {String} text\n\t\t * @param {Number} start Starting range in <code>text</code> where \n\t\t * slection should be adjusted. Can also be any object that is accepted\n\t\t * by <code>Range</code> class\n\t\t * @return {Range}\n\t\t */\n\t\tnarrowToNonSpace: function(text, start, end) {\n\t\t\tvar range = require('range').create(start, end);\n\t\t\t\n\t\t\tvar reSpace = /[\\s\\n\\r\\u00a0]/;\n\t\t\t// narrow down selection until first non-space character\n\t\t\twhile (range.start < range.end) {\n\t\t\t\tif (!reSpace.test(text.charAt(range.start)))\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\trange.start++;\n\t\t\t}\n\t\t\t\n\t\t\twhile (range.end > range.start) {\n\t\t\t\trange.end--;\n\t\t\t\tif (!reSpace.test(text.charAt(range.end))) {\n\t\t\t\t\trange.end++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn range;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Find start and end index of text line for <code>from</code> index\n\t\t * @param {String} text \n\t\t * @param {Number} from\n\t\t */\n\t\tfindNewlineBounds: function(text, from) {\n\t\t\tvar len = text.length,\n\t\t\t\tstart = 0,\n\t\t\t\tend = len - 1;\n\t\t\t\n\t\t\t// search left\n\t\t\tfor (var i = from - 1; i > 0; i--) {\n\t\t\t\tvar ch = text.charAt(i);\n\t\t\t\tif (ch == '\\n' || ch == '\\r') {\n\t\t\t\t\tstart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// search right\n\t\t\tfor (var j = from; j < len; j++) {\n\t\t\t\tvar ch = text.charAt(j);\n\t\t\t\tif (ch == '\\n' || ch == '\\r') {\n\t\t\t\t\tend = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn require('range').create(start, end - start);\n\t\t},\n\n\t\t/**\n\t\t * Deep merge of two or more objects. Taken from jQuery.extend()\n\t\t */\n\t\tdeepMerge: function() {\n\t\t\tvar options, name, src, copy, copyIsArray, clone,\n\t\t\t\ttarget = arguments[0] || {},\n\t\t\t\ti = 1,\n\t\t\t\tlength = arguments.length;\n\n\n\t\t\t// Handle case when target is a string or something (possible in deep copy)\n\t\t\tif (!_.isObject(target) && !_.isFunction(target)) {\n\t\t\t\ttarget = {};\n\t\t\t}\n\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t// Only deal with non-null/undefined values\n\t\t\t\tif ( (options = arguments[ i ]) != null ) {\n\t\t\t\t\t// Extend the base object\n\t\t\t\t\tfor ( name in options ) {\n\t\t\t\t\t\tsrc = target[ name ];\n\t\t\t\t\t\tcopy = options[ name ];\n\n\t\t\t\t\t\t// Prevent never-ending loop\n\t\t\t\t\t\tif ( target === copy ) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\t\t\tif ( copy && ( _.isObject(copy) || (copyIsArray = _.isArray(copy)) ) ) {\n\t\t\t\t\t\t\tif ( copyIsArray ) {\n\t\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\t\tclone = src && _.isArray(src) ? src : [];\n\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tclone = src && _.isObject(src) ? src : {};\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\t\ttarget[ name ] = this.deepMerge(clone, copy );\n\n\t\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Return the modified object\n\t\t\treturn target;\n\t\t}\n\t};\n});\n/**\n * Helper module to work with ranges\n * @constructor\n * @memberOf __rangeDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.define('range', function(require, _) {\n\tfunction cmp(a, b, op) {\n\t\tswitch (op) {\n\t\t\tcase 'eq':\n\t\t\tcase '==':\n\t\t\t\treturn a === b;\n\t\t\tcase 'lt':\n\t\t\tcase '<':\n\t\t\t\treturn a < b;\n\t\t\tcase 'lte':\n\t\t\tcase '<=':\n\t\t\t\treturn a <= b;\n\t\t\tcase 'gt':\n\t\t\tcase '>':\n\t\t\t\treturn a > b;\n\t\t\tcase 'gte':\n\t\t\tcase '>=':\n\t\t\t\treturn a >= b;\n\t\t}\n\t}\n\t\n\t\n\t/**\n\t * @type Range\n\t * @constructor\n\t * @param {Object} start\n\t * @param {Number} len\n\t */\n\tfunction Range(start, len) {\n\t\tif (_.isObject(start) && 'start' in start) {\n\t\t\t// create range from object stub\n\t\t\tthis.start = Math.min(start.start, start.end);\n\t\t\tthis.end = Math.max(start.start, start.end);\n\t\t} else if (_.isArray(start)) {\n\t\t\tthis.start = start[0];\n\t\t\tthis.end = start[1];\n\t\t} else {\n\t\t\tlen = _.isString(len) ? len.length : +len;\n\t\t\tthis.start = start;\n\t\t\tthis.end = start + len;\n\t\t}\n\t}\n\t\n\tRange.prototype = {\n\t\tlength: function() {\n\t\t\treturn Math.abs(this.end - this.start);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns <code>true</code> if passed range is equals to current one\n\t\t * @param {Range} range\n\t\t * @returns {Boolean}\n\t\t */\n\t\tequal: function(range) {\n\t\t\treturn this.cmp(range, 'eq', 'eq');\n//\t\t\treturn this.start === range.start && this.end === range.end;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Shifts indexes position with passed <code>delat</code>\n\t\t * @param {Number} delta\n\t\t * @returns {Range} range itself\n\t\t */\n\t\tshift: function(delta) {\n\t\t\tthis.start += delta;\n\t\t\tthis.end += delta;\n\t\t\treturn this;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if two ranges are overlapped\n\t\t * @param {Range} range\n\t\t * @returns {Boolean}\n\t\t */\n\t\toverlap: function(range) {\n\t\t\treturn range.start <= this.end && range.end >= this.start;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Finds intersection of two ranges\n\t\t * @param {Range} range\n\t\t * @returns {Range} <code>null</code> if ranges does not overlap\n\t\t */\n\t\tintersection: function(range) {\n\t\t\tif (this.overlap(range)) {\n\t\t\t\tvar start = Math.max(range.start, this.start);\n\t\t\t\tvar end = Math.min(range.end, this.end);\n\t\t\t\treturn new Range(start, end - start);\n\t\t\t}\n\t\t\t\n\t\t\treturn null;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns the union of the thow ranges.\n\t\t * @param {Range} range\n\t\t * @returns {Range} <code>null</code> if ranges are not overlapped\n\t\t */\n\t\tunion: function(range) {\n\t\t\tif (this.overlap(range)) {\n\t\t\t\tvar start = Math.min(range.start, this.start);\n\t\t\t\tvar end = Math.max(range.end, this.end);\n\t\t\t\treturn new Range(start, end - start);\n\t\t\t}\n\t\t\t\n\t\t\treturn null;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns a Boolean value that indicates whether a specified position \n\t\t * is in a given range.\n\t\t * @param {Number} loc\n\t\t */\n\t\tinside: function(loc) {\n\t\t\treturn this.cmp(loc, 'lte', 'gt');\n//\t\t\treturn this.start <= loc && this.end > loc;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns a Boolean value that indicates whether a specified position \n\t\t * is in a given range, but not equals bounds.\n\t\t * @param {Number} loc\n\t\t */\n\t\tcontains: function(loc) {\n\t\t\treturn this.cmp(loc, 'lt', 'gt');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if current range completely includes specified one\n\t\t * @param {Range} r\n\t\t * @returns {Boolean} \n\t\t */\n\t\tinclude: function(r) {\n\t\t\treturn this.cmp(loc, 'lte', 'gte');\n//\t\t\treturn this.start <= r.start && this.end >= r.end;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Low-level comparision method\n\t\t * @param {Number} loc\n\t\t * @param {String} left Left comparison operator\n\t\t * @param {String} right Right comaprison operator\n\t\t */\n\t\tcmp: function(loc, left, right) {\n\t\t\tvar a, b;\n\t\t\tif (loc instanceof Range) {\n\t\t\t\ta = loc.start;\n\t\t\t\tb = loc.end;\n\t\t\t} else {\n\t\t\t\ta = b = loc;\n\t\t\t}\n\t\t\t\n\t\t\treturn cmp(this.start, a, left || '<=') && cmp(this.end, b, right || '>');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns substring of specified <code>str</code> for current range\n\t\t * @param {String} str\n\t\t * @returns {String}\n\t\t */\n\t\tsubstring: function(str) {\n\t\t\treturn this.length() > 0 \n\t\t\t\t? str.substring(this.start, this.end) \n\t\t\t\t: '';\n\t\t},\n\t\t\n\t\t/**\n\t\t * Creates copy of current range\n\t\t * @returns {Range}\n\t\t */\n\t\tclone: function() {\n\t\t\treturn new Range(this.start, this.length());\n\t\t},\n\t\t\n\t\t/**\n\t\t * @returns {Array}\n\t\t */\n\t\ttoArray: function() {\n\t\t\treturn [this.start, this.end];\n\t\t},\n\t\t\n\t\ttoString: function() {\n\t\t\treturn '{' + this.start + ', ' + this.length() + '}';\n\t\t}\n\t};\n\t\n\treturn {\n\t\t/**\n\t\t * Creates new range object instance\n\t\t * @param {Object} start Range start or array with 'start' and 'end'\n\t\t * as two first indexes or object with 'start' and 'end' properties\n\t\t * @param {Number} len Range length or string to produce range from\n\t\t * @returns {Range}\n\t\t * @memberOf emmet.range\n\t\t */\n\t\tcreate: function(start, len) {\n\t\t\tif (_.isUndefined(start) || start === null)\n\t\t\t\treturn null;\n\t\t\t\n\t\t\tif (start instanceof Range)\n\t\t\t\treturn start;\n\t\t\t\n\t\t\tif (_.isObject(start) && 'start' in start && 'end' in start) {\n\t\t\t\tlen = start.end - start.start;\n\t\t\t\tstart = start.start;\n\t\t\t}\n\t\t\t\t\n\t\t\treturn new Range(start, len);\n\t\t},\n\t\t\n\t\t/**\n\t\t * <code>Range</code> object factory, the same as <code>this.create()</code>\n\t\t * but last argument represents end of range, not length\n\t\t * @returns {Range}\n\t\t */\n\t\tcreate2: function(start, end) {\n\t\t\tif (_.isNumber(start) && _.isNumber(end)) {\n\t\t\t\tend -= start;\n\t\t\t}\n\t\t\t\n\t\t\treturn this.create(start, end);\n\t\t}\n\t};\n});/**\n * Utility module that provides ordered storage of function handlers. \n * Many Emmet modules' functionality can be extended/overridden by custom\n * function. This modules provides unified storage of handler functions, their \n * management and execution\n * \n * @constructor\n * @memberOf __handlerListDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.define('handlerList', function(require, _) {\n\t/**\n\t * @type HandlerList\n\t * @constructor\n\t */\n\tfunction HandlerList() {\n\t\tthis._list = [];\n\t}\n\t\n\tHandlerList.prototype = {\n\t\t/**\n\t\t * Adds function handler\n\t\t * @param {Function} fn Handler\n\t\t * @param {Object} options Handler options. Possible values are:<br><br>\n\t\t * <b>order</b> : (<code>Number</code>) – order in handler list. Handlers\n\t\t * with higher order value will be executed earlier.\n\t\t */\n\t\tadd: function(fn, options) {\n\t\t\tthis._list.push(_.extend({order: 0}, options || {}, {fn: fn}));\n\t\t},\n\t\t\n\t\t/**\n\t\t * Removes handler from list\n\t\t * @param {Function} fn\n\t\t */\n\t\tremove: function(fn) {\n\t\t\tthis._list = _.without(this._list, _.find(this._list, function(item) {\n\t\t\t\treturn item.fn === fn;\n\t\t\t}));\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns ordered list of handlers. By default, handlers \n\t\t * with the same <code>order</code> option returned in reverse order, \n\t\t * i.e. the latter function was added into the handlers list, the higher \n\t\t * it will be in the returned array \n\t\t * @returns {Array}\n\t\t */\n\t\tlist: function() {\n\t\t\treturn _.sortBy(this._list, 'order').reverse();\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns ordered list of handler functions\n\t\t * @returns {Array}\n\t\t */\n\t\tlistFn: function() {\n\t\t\treturn _.pluck(this.list(), 'fn');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Executes handler functions in their designated order. If function\n\t\t * returns <code>skipVal</code>, meaning that function was unable to \n\t\t * handle passed <code>args</code>, the next function will be executed\n\t\t * and so on.\n\t\t * @param {Object} skipValue If function returns this value, execute \n\t\t * next handler.\n\t\t * @param {Array} args Arguments to pass to handler function\n\t\t * @returns {Boolean} Whether any of registered handlers performed\n\t\t * successfully  \n\t\t */\n\t\texec: function(skipValue, args) {\n\t\t\targs = args || [];\n\t\t\tvar result = null;\n\t\t\t_.find(this.list(), function(h) {\n\t\t\t\tresult = h.fn.apply(h, args);\n\t\t\t\tif (result !== skipValue)\n\t\t\t\t\treturn true;\n\t\t\t});\n\t\t\t\n\t\t\treturn result;\n\t\t}\n\t};\n\t\n\treturn {\n\t\t/**\n\t\t * Factory method that produces <code>HandlerList</code> instance\n\t\t * @returns {HandlerList}\n\t\t * @memberOf handlerList\n\t\t */\n\t\tcreate: function() {\n\t\t\treturn new HandlerList();\n\t\t}\n\t};\n});/**\n * Helper class for convenient token iteration\n */\nemmet.define('tokenIterator', function(require, _) {\n\t/**\n\t * @type TokenIterator\n\t * @param {Array} tokens\n\t * @type TokenIterator\n\t * @constructor\n\t */\n\tfunction TokenIterator(tokens) {\n\t\t/** @type Array */\n\t\tthis.tokens = tokens;\n\t\tthis._position = 0;\n\t\tthis.reset();\n\t}\n\t\n\tTokenIterator.prototype = {\n\t\tnext: function() {\n\t\t\tif (this.hasNext()) {\n\t\t\t\tvar token = this.tokens[++this._i];\n\t\t\t\tthis._position = token.start;\n\t\t\t\treturn token;\n\t\t\t}\n\t\t\t\n\t\t\treturn null;\n\t\t},\n\t\t\n\t\tcurrent: function() {\n\t\t\treturn this.tokens[this._i];\n\t\t},\n\t\t\n\t\tposition: function() {\n\t\t\treturn this._position;\n\t\t},\n\t\t\n\t\thasNext: function() {\n\t\t\treturn this._i < this._il - 1;\n\t\t},\n\t\t\n\t\treset: function() {\n\t\t\tthis._i = -1;\n\t\t\tthis._il = this.tokens.length;\n\t\t},\n\t\t\n\t\titem: function() {\n\t\t\treturn this.tokens[this._i];\n\t\t},\n\t\t\n\t\titemNext: function() {\n\t\t\treturn this.tokens[this._i + 1];\n\t\t},\n\t\t\n\t\titemPrev: function() {\n\t\t\treturn this.tokens[this._i - 1];\n\t\t},\n\t\t\n\t\tnextUntil: function(type, callback) {\n\t\t\tvar token;\n\t\t\tvar test = _.isString(type) \n\t\t\t\t? function(t){return t.type == type;} \n\t\t\t\t: type;\n\t\t\t\n\t\t\twhile (token = this.next()) {\n\t\t\t\tif (callback)\n\t\t\t\t\tcallback.call(this, token);\n\t\t\t\tif (test.call(this, token))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t};\n\t\n\treturn {\n\t\tcreate: function(tokens) {\n\t\t\treturn new TokenIterator(tokens);\n\t\t}\n\t};\n});/**\n * A trimmed version of CodeMirror's StringStream module for string parsing\n */\nemmet.define('stringStream', function(require, _) {\n\t/**\n\t * @type StringStream\n\t * @constructor\n\t * @param {String} string\n\t */\n\tfunction StringStream(string) {\n\t\tthis.pos = this.start = 0;\n\t\tthis.string = string;\n\t}\n\t\n\tStringStream.prototype = {\n\t\t/**\n\t\t * Returns true only if the stream is at the end of the line.\n\t\t * @returns {Boolean}\n\t\t */\n\t\teol: function() {\n\t\t\treturn this.pos >= this.string.length;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns true only if the stream is at the start of the line\n\t\t * @returns {Boolean}\n\t\t */\n\t\tsol: function() {\n\t\t\treturn this.pos == 0;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns the next character in the stream without advancing it. \n\t\t * Will return <code>undefined</code> at the end of the line.\n\t\t * @returns {String}\n\t\t */\n\t\tpeek: function() {\n\t\t\treturn this.string.charAt(this.pos);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns the next character in the stream and advances it.\n\t\t * Also returns <code>undefined</code> when no more characters are available.\n\t\t * @returns {String}\n\t\t */\n\t\tnext: function() {\n\t\t\tif (this.pos < this.string.length)\n\t\t\t\treturn this.string.charAt(this.pos++);\n\t\t},\n\t\t\n\t\t/**\n\t\t * match can be a character, a regular expression, or a function that\n\t\t * takes a character and returns a boolean. If the next character in the\n\t\t * stream 'matches' the given argument, it is consumed and returned.\n\t\t * Otherwise, undefined is returned.\n\t\t * @param {Object} match\n\t\t * @returns {String}\n\t\t */\n\t\teat: function(match) {\n\t\t\tvar ch = this.string.charAt(this.pos), ok;\n\t\t\tif (typeof match == \"string\")\n\t\t\t\tok = ch == match;\n\t\t\telse\n\t\t\t\tok = ch && (match.test ? match.test(ch) : match(ch));\n\t\t\t\n\t\t\tif (ok) {\n\t\t\t\t++this.pos;\n\t\t\t\treturn ch;\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Repeatedly calls <code>eat</code> with the given argument, until it\n\t\t * fails. Returns <code>true</code> if any characters were eaten.\n\t\t * @param {Object} match\n\t\t * @returns {Boolean}\n\t\t */\n\t\teatWhile: function(match) {\n\t\t\tvar start = this.pos;\n\t\t\twhile (this.eat(match)) {}\n\t\t\treturn this.pos > start;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Shortcut for <code>eatWhile</code> when matching white-space.\n\t\t * @returns {Boolean}\n\t\t */\n\t\teatSpace: function() {\n\t\t\tvar start = this.pos;\n\t\t\twhile (/[\\s\\u00a0]/.test(this.string.charAt(this.pos)))\n\t\t\t\t++this.pos;\n\t\t\treturn this.pos > start;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Moves the position to the end of the line.\n\t\t */\n\t\tskipToEnd: function() {\n\t\t\tthis.pos = this.string.length;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Skips to the next occurrence of the given character, if found on the\n\t\t * current line (doesn't advance the stream if the character does not\n\t\t * occur on the line). Returns true if the character was found.\n\t\t * @param {String} ch\n\t\t * @returns {Boolean}\n\t\t */\n\t\tskipTo: function(ch) {\n\t\t\tvar found = this.string.indexOf(ch, this.pos);\n\t\t\tif (found > -1) {\n\t\t\t\tthis.pos = found;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Skips to <code>close</code> character which is pair to <code>open</code>\n\t\t * character, considering possible pair nesting. This function is used\n\t\t * to consume pair of characters, like opening and closing braces\n\t\t * @param {String} open\n\t\t * @param {String} close\n\t\t * @returns {Boolean} Returns <code>true</code> if pair was successfully\n\t\t * consumed\n\t\t */\n\t\tskipToPair: function(open, close) {\n\t\t\tvar braceCount = 0, ch;\n\t\t\tvar pos = this.pos, len = this.string.length;\n\t\t\twhile (pos < len) {\n\t\t\t\tch = this.string.charAt(pos++);\n\t\t\t\tif (ch == open) {\n\t\t\t\t\tbraceCount++;\n\t\t\t\t} else if (ch == close) {\n\t\t\t\t\tbraceCount--;\n\t\t\t\t\tif (braceCount < 1) {\n\t\t\t\t\t\tthis.pos = pos;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Backs up the stream n characters. Backing it up further than the\n\t\t * start of the current token will cause things to break, so be careful.\n\t\t * @param {Number} n\n\t\t */\n\t\tbackUp : function(n) {\n\t\t\tthis.pos -= n;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Act like a multi-character <code>eat</code>—if <code>consume</code> is true or\n\t\t * not given—or a look-ahead that doesn't update the stream position—if\n\t\t * it is false. <code>pattern</code> can be either a string or a\n\t\t * regular expression starting with ^. When it is a string,\n\t\t * <code>caseInsensitive</code> can be set to true to make the match\n\t\t * case-insensitive. When successfully matching a regular expression,\n\t\t * the returned value will be the array returned by <code>match</code>,\n\t\t * in case you need to extract matched groups.\n\t\t * \n\t\t * @param {RegExp} pattern\n\t\t * @param {Boolean} consume\n\t\t * @param {Boolean} caseInsensitive\n\t\t * @returns\n\t\t */\n\t\tmatch: function(pattern, consume, caseInsensitive) {\n\t\t\tif (typeof pattern == \"string\") {\n\t\t\t\tvar cased = caseInsensitive\n\t\t\t\t\t? function(str) {return str.toLowerCase();}\n\t\t\t\t\t: function(str) {return str;};\n\t\t\t\t\n\t\t\t\tif (cased(this.string).indexOf(cased(pattern), this.pos) == this.pos) {\n\t\t\t\t\tif (consume !== false)\n\t\t\t\t\t\tthis.pos += pattern.length;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar match = this.string.slice(this.pos).match(pattern);\n\t\t\t\tif (match && consume !== false)\n\t\t\t\t\tthis.pos += match[0].length;\n\t\t\t\treturn match;\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Get the string between the start of the current token and the \n\t\t * current stream position.\n\t\t * @returns {String}\n\t\t */\n\t\tcurrent: function() {\n\t\t\treturn this.string.slice(this.start, this.pos);\n\t\t}\n\t};\n\t\n\treturn {\n\t\tcreate: function(string) {\n\t\t\treturn new StringStream(string);\n\t\t}\n\t};\n});/**\n * Parsed resources (snippets, abbreviations, variables, etc.) for Emmet.\n * Contains convenient method to get access for snippets with respect of \n * inheritance. Also provides ability to store data in different vocabularies\n * ('system' and 'user') for fast and safe resource update\n * @author Sergey Chikuyonok (serge.che@gmail.com)\n * @link http://chikuyonok.ru\n * \n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.define('resources', function(require, _) {\n\tvar VOC_SYSTEM = 'system';\n\tvar VOC_USER = 'user';\n\t\n\tvar cache = {};\n\t\t\n\t/** Regular expression for XML tag matching */\n\tvar reTag = /^<(\\w+\\:?[\\w\\-]*)((?:\\s+[\\w\\:\\-]+\\s*=\\s*(['\"]).*?\\3)*)\\s*(\\/?)>/;\n\t\t\n\tvar systemSettings = {};\n\tvar userSettings = {};\n\t\n\t/** @type HandlerList List of registered abbreviation resolvers */\n\tvar resolvers = require('handlerList').create();\n\t\n\t/**\n\t * Normalizes caret plceholder in passed text: replaces | character with\n\t * default caret placeholder\n\t * @param {String} text\n\t * @returns {String}\n\t */\n\tfunction normalizeCaretPlaceholder(text) {\n\t\tvar utils = require('utils');\n\t\treturn utils.replaceUnescapedSymbol(text, '|', utils.getCaretPlaceholder());\n\t}\n\t\n\tfunction parseItem(name, value, type) {\n\t\tvalue = normalizeCaretPlaceholder(value);\n\t\t\n\t\tif (type == 'snippets') {\n\t\t\treturn require('elements').create('snippet', value);\n\t\t}\n\t\t\n\t\tif (type == 'abbreviations') {\n\t\t\treturn parseAbbreviation(name, value);\n\t\t}\n\t}\n\t\n\t/**\n\t * Parses single abbreviation\n\t * @param {String} key Abbreviation name\n\t * @param {String} value Abbreviation value\n\t * @return {Object}\n\t */\n\tfunction parseAbbreviation(key, value) {\n\t\tkey = require('utils').trim(key);\n\t\tvar elements = require('elements');\n\t\tvar m;\n\t\tif (m = reTag.exec(value)) {\n\t\t\treturn elements.create('element', m[1], m[2], m[4] == '/');\n\t\t} else {\n\t\t\t// assume it's reference to another abbreviation\n\t\t\treturn elements.create('reference', value);\n\t\t}\n\t}\n\t\n\t/**\n\t * Normalizes snippet key name for better fuzzy search\n\t * @param {String} str\n\t * @returns {String}\n\t */\n\tfunction normalizeName(str) {\n\t\treturn str.replace(/:$/, '').replace(/:/g, '-');\n\t}\n\t\n\treturn {\n\t\t/**\n\t\t * Sets new unparsed data for specified settings vocabulary\n\t\t * @param {Object} data\n\t\t * @param {String} type Vocabulary type ('system' or 'user')\n\t\t * @memberOf resources\n\t\t */\n\t\tsetVocabulary: function(data, type) {\n\t\t\tcache = {};\n\t\t\tif (type == VOC_SYSTEM)\n\t\t\t\tsystemSettings = data;\n\t\t\telse\n\t\t\t\tuserSettings = data;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns resource vocabulary by its name\n\t\t * @param {String} name Vocabulary name ('system' or 'user')\n\t\t * @return {Object}\n\t\t */\n\t\tgetVocabulary: function(name) {\n\t\t\treturn name == VOC_SYSTEM ? systemSettings : userSettings;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns resource (abbreviation, snippet, etc.) matched for passed \n\t\t * abbreviation\n\t\t * @param {AbbreviationNode} node\n\t\t * @param {String} syntax\n\t\t * @returns {Object}\n\t\t */\n\t\tgetMatchedResource: function(node, syntax) {\n\t\t\treturn resolvers.exec(null, _.toArray(arguments)) \n\t\t\t\t|| this.findSnippet(syntax, node.name());\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns variable value\n\t\t * @return {String}\n\t\t */\n\t\tgetVariable: function(name) {\n\t\t\treturn (this.getSection('variables') || {})[name];\n\t\t},\n\t\t\n\t\t/**\n\t\t * Store runtime variable in user storage\n\t\t * @param {String} name Variable name\n\t\t * @param {String} value Variable value\n\t\t */\n\t\tsetVariable: function(name, value){\n\t\t\tvar voc = this.getVocabulary('user') || {};\n\t\t\tif (!('variables' in voc))\n\t\t\t\tvoc.variables = {};\n\t\t\t\t\n\t\t\tvoc.variables[name] = value;\n\t\t\tthis.setVocabulary(voc, 'user');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if there are resources for specified syntax\n\t\t * @param {String} syntax\n\t\t * @return {Boolean}\n\t\t */\n\t\thasSyntax: function(syntax) {\n\t\t\treturn syntax in this.getVocabulary(VOC_USER) \n\t\t\t\t|| syntax in this.getVocabulary(VOC_SYSTEM);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Registers new abbreviation resolver.\n\t\t * @param {Function} fn Abbreviation resolver which will receive \n\t\t * abbreviation as first argument and should return parsed abbreviation\n\t\t * object if abbreviation has handled successfully, <code>null</code>\n\t\t * otherwise\n\t\t * @param {Object} options Options list as described in \n\t\t * {@link HandlerList#add()} method\n\t\t */\n\t\taddResolver: function(fn, options) {\n\t\t\tresolvers.add(fn, options);\n\t\t},\n\t\t\n\t\tremoveResolver: function(fn) {\n\t\t\tresolvers.remove(fn);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns actual section data, merged from both\n\t\t * system and user data\n\t\t * @param {String} name Section name (syntax)\n\t\t * @param {String} ...args Subsections\n\t\t * @returns\n\t\t */\n\t\tgetSection: function(name) {\n\t\t\tif (!name)\n\t\t\t\treturn null;\n\t\t\t\n\t\t\tif (!(name in cache)) {\n\t\t\t\tcache[name] = require('utils').deepMerge({}, systemSettings[name], userSettings[name]);\n\t\t\t}\n\t\t\t\n\t\t\tvar data = cache[name], subsections = _.rest(arguments), key;\n\t\t\twhile (data && (key = subsections.shift())) {\n\t\t\t\tif (key in data) {\n\t\t\t\t\tdata = data[key];\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn data;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Recursively searches for a item inside top level sections (syntaxes)\n\t\t * with respect of `extends` attribute\n\t\t * @param {String} topSection Top section name (syntax)\n\t\t * @param {String} subsection Inner section name\n\t\t * @returns {Object}\n\t\t */\n\t\tfindItem: function(topSection, subsection) {\n\t\t\tvar data = this.getSection(topSection);\n\t\t\twhile (data) {\n\t\t\t\tif (subsection in data)\n\t\t\t\t\treturn data[subsection];\n\t\t\t\t\n\t\t\t\tdata = this.getSection(data['extends']);\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Recursively searches for a snippet definition inside syntax section.\n\t\t * Definition is searched inside `snippets` and `abbreviations` \n\t\t * subsections  \n\t\t * @param {String} syntax Top-level section name (syntax)\n\t\t * @param {String} name Snippet name\n\t\t * @returns {Object}\n\t\t */\n\t\tfindSnippet: function(syntax, name, memo) {\n\t\t\tif (!syntax || !name)\n\t\t\t\treturn null;\n\t\t\t\n\t\t\tmemo = memo || [];\n\t\t\t\n\t\t\tvar names = [name];\n\t\t\t// create automatic aliases to properties with colons,\n\t\t\t// e.g. pos-a == pos:a\n\t\t\tif (~name.indexOf('-'))\n\t\t\t\tnames.push(name.replace(/\\-/g, ':'));\n\t\t\t\n\t\t\tvar data = this.getSection(syntax), matchedItem = null;\n\t\t\t_.find(['snippets', 'abbreviations'], function(sectionName) {\n\t\t\t\tvar data = this.getSection(syntax, sectionName);\n\t\t\t\tif (data) {\n\t\t\t\t\treturn _.find(names, function(n) {\n\t\t\t\t\t\tif (data[n])\n\t\t\t\t\t\t\treturn matchedItem = parseItem(n, data[n], sectionName);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}, this);\n\t\t\t\n\t\t\tmemo.push(syntax);\n\t\t\tif (!matchedItem && data['extends'] && !_.include(memo, data['extends'])) {\n\t\t\t\t// try to find item in parent syntax section\n\t\t\t\treturn this.findSnippet(data['extends'], name, memo);\n\t\t\t}\n\t\t\t\n\t\t\treturn matchedItem;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Performs fuzzy search of snippet definition\n\t\t * @param {String} syntax Top-level section name (syntax)\n\t\t * @param {String} name Snippet name\n\t\t * @returns\n\t\t */\n\t\tfuzzyFindSnippet: function(syntax, name, minScore) {\n\t\t\tminScore = minScore || 0.3;\n\t\t\t\n\t\t\tvar payload = this.getAllSnippets(syntax);\n\t\t\tvar sc = require('string-score');\n\t\t\t\n\t\t\tname = normalizeName(name);\n\t\t\tvar scores = _.map(payload, function(value, key) {\n\t\t\t\treturn {\n\t\t\t\t\tkey: key,\n\t\t\t\t\tscore: sc.score(value.nk, name, 0.1)\n\t\t\t\t};\n\t\t\t});\n\t\t\t\n\t\t\tvar result = _.last(_.sortBy(scores, 'score'));\n\t\t\tif (result && result.score >= minScore) {\n\t\t\t\tvar k = result.key;\n\t\t\t\treturn payload[k].parsedValue;\n//\t\t\t\treturn parseItem(k, payload[k].value, payload[k].type);\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns plain dictionary of all available abbreviations and snippets\n\t\t * for specified syntax with respect of inheritance\n\t\t * @param {String} syntax\n\t\t * @returns {Object}\n\t\t */\n\t\tgetAllSnippets: function(syntax) {\n\t\t\tvar cacheKey = 'all-' + syntax;\n\t\t\tif (!cache[cacheKey]) {\n\t\t\t\tvar stack = [], sectionKey = syntax;\n\t\t\t\tvar memo = [];\n\t\t\t\t\n\t\t\t\tdo {\n\t\t\t\t\tvar section = this.getSection(sectionKey);\n\t\t\t\t\tif (!section)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\t_.each(['snippets', 'abbreviations'], function(sectionName) {\n\t\t\t\t\t\tvar stackItem = {};\n\t\t\t\t\t\t_.each(section[sectionName] || null, function(v, k) {\n\t\t\t\t\t\t\tstackItem[k] = {\n\t\t\t\t\t\t\t\tnk: normalizeName(k),\n\t\t\t\t\t\t\t\tvalue: v,\n\t\t\t\t\t\t\t\tparsedValue: parseItem(k, v, sectionName),\n\t\t\t\t\t\t\t\ttype: sectionName\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t});\n\t\t\t\t\t\t\n\t\t\t\t\t\tstack.push(stackItem);\n\t\t\t\t\t});\n\t\t\t\t\t\n\t\t\t\t\tmemo.push(sectionKey);\n\t\t\t\t\tsectionKey = section['extends'];\n\t\t\t\t} while (sectionKey && !_.include(memo, sectionKey));\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tcache[cacheKey] = _.extend.apply(_, stack.reverse());\n\t\t\t}\n\t\t\t\n\t\t\treturn cache[cacheKey];\n\t\t}\n\t};\n});/**\n * Module describes and performs Emmet actions. The actions themselves are\n * defined in <i>actions</i> folder\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.define('actions', function(require, _, zc) {\n\tvar actions = {};\n\t\n\t/**\n\t * “Humanizes” action name, makes it more readable for people\n\t * @param {String} name Action name (like 'expand_abbreviation')\n\t * @return Humanized name (like 'Expand Abbreviation')\n\t */\n\tfunction humanizeActionName(name) {\n\t\treturn require('utils').trim(name.charAt(0).toUpperCase() \n\t\t\t+ name.substring(1).replace(/_[a-z]/g, function(str) {\n\t\t\t\treturn ' ' + str.charAt(1).toUpperCase();\n\t\t\t}));\n\t}\n\t\n\treturn {\n\t\t/**\n\t\t * Registers new action\n\t\t * @param {String} name Action name\n\t\t * @param {Function} fn Action function\n\t\t * @param {Object} options Custom action options:<br>\n\t\t * <b>label</b> : (<code>String</code>) – Human-readable action name. \n\t\t * May contain '/' symbols as submenu separators<br>\n\t\t * <b>hidden</b> : (<code>Boolean</code>) – Indicates whether action\n\t\t * should be displayed in menu (<code>getMenu()</code> method)\n\t\t * \n\t\t * @memberOf actions\n\t\t */\n\t\tadd: function(name, fn, options) {\n\t\t\tname = name.toLowerCase();\n\t\t\toptions = options || {};\n\t\t\tif (!options.label) {\n\t\t\t\toptions.label = humanizeActionName(name);\n\t\t\t}\n\t\t\t\n\t\t\tactions[name] = {\n\t\t\t\tname: name,\n\t\t\t\tfn: fn,\n\t\t\t\toptions: options\n\t\t\t};\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns action object\n\t\t * @param {String} name Action name\n\t\t * @returns {Object}\n\t\t */\n\t\tget: function(name) {\n\t\t\treturn actions[name.toLowerCase()];\n\t\t},\n\t\t\n\t\t/**\n\t\t * Runs Emmet action. For list of available actions and their\n\t\t * arguments see <i>actions</i> folder.\n\t\t * @param {String} name Action name \n\t\t * @param {Array} args Additional arguments. It may be array of arguments\n\t\t * or inline arguments. The first argument should be <code>IEmmetEditor</code> instance\n\t\t * @returns {Boolean} Status of performed operation, <code>true</code>\n\t\t * means action was performed successfully.\n\t\t * @example\n\t\t * emmet.require('actions').run('expand_abbreviation', editor);  \n\t\t * emmet.require('actions').run('wrap_with_abbreviation', [editor, 'div']);  \n\t\t */\n\t\trun: function(name, args) {\n\t\t\tif (!_.isArray(args)) {\n\t\t\t\targs = _.rest(arguments);\n\t\t\t}\n\t\t\t\n\t\t\tvar action = this.get(name);\n\t\t\tif (action) {\n\t\t\t\treturn action.fn.apply(emmet, args);\n\t\t\t} else {\n\t\t\t\temmet.log('Action \"%s\" is not defined', name);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns all registered actions as object\n\t\t * @returns {Object}\n\t\t */\n\t\tgetAll: function() {\n\t\t\treturn actions;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns all registered actions as array\n\t\t * @returns {Array}\n\t\t */\n\t\tgetList: function() {\n\t\t\treturn _.values(this.getAll());\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns actions list as structured menu. If action has <i>label</i>,\n\t\t * it will be splitted by '/' symbol into submenus (for example: \n\t\t * CSS/Reflect Value) and grouped with other items\n\t\t * @param {Array} skipActions List of action identifiers that should be \n\t\t * skipped from menu\n\t\t * @returns {Array}\n\t\t */\n\t\tgetMenu: function(skipActions) {\n\t\t\tvar result = [];\n\t\t\tskipActions = skipActions || [];\n\t\t\t_.each(this.getList(), function(action) {\n\t\t\t\tif (action.options.hidden || _.include(skipActions, action.name))\n\t\t\t\t\treturn;\n\t\t\t\t\n\t\t\t\tvar actionName = humanizeActionName(action.name);\n\t\t\t\tvar ctx = result;\n\t\t\t\tif (action.options.label) {\n\t\t\t\t\tvar parts = action.options.label.split('/');\n\t\t\t\t\tactionName = parts.pop();\n\t\t\t\t\t\n\t\t\t\t\t// create submenus, if needed\n\t\t\t\t\tvar menuName, submenu;\n\t\t\t\t\twhile (menuName = parts.shift()) {\n\t\t\t\t\t\tsubmenu = _.find(ctx, function(item) {\n\t\t\t\t\t\t\treturn item.type == 'submenu' && item.name == menuName;\n\t\t\t\t\t\t});\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (!submenu) {\n\t\t\t\t\t\t\tsubmenu = {\n\t\t\t\t\t\t\t\tname: menuName,\n\t\t\t\t\t\t\t\ttype: 'submenu',\n\t\t\t\t\t\t\t\titems: []\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tctx.push(submenu);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tctx = submenu.items;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tctx.push({\n\t\t\t\t\ttype: 'action',\n\t\t\t\t\tname: action.name,\n\t\t\t\t\tlabel: actionName\n\t\t\t\t});\n\t\t\t});\n\t\t\t\n\t\t\treturn result;\n\t\t},\n\n\t\t/**\n\t\t * Returns action name associated with menu item title\n\t\t * @param {String} title\n\t\t * @returns {String}\n\t\t */\n\t\tgetActionNameForMenuTitle: function(title, menu) {\n\t\t\tvar item = null;\n\t\t\t_.find(menu || this.getMenu(), function(val) {\n\t\t\t\tif (val.type == 'action') {\n\t\t\t\t\tif (val.label == title || val.name == title) {\n\t\t\t\t\t\treturn item = val.name;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn item = this.getActionNameForMenuTitle(title, val.items);\n\t\t\t\t}\n\t\t\t}, this);\n\t\t\t\n\t\t\treturn item || null;\n\t\t}\n\t};\n});/**\n * Output profile module.\n * Profile defines how XHTML output data should look like\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.define('profile', function(require, _) {\n\tvar profiles = {};\n\t\n\tvar defaultProfile = {\n\t\ttag_case: 'asis',\n\t\tattr_case: 'asis',\n\t\tattr_quotes: 'double',\n\t\t\n\t\t// each tag on new line\n\t\ttag_nl: 'decide',\n\t\t\n\t\t// with tag_nl === true, defines if leaf node (e.g. node with no children)\n\t\t// should have formatted line breaks\n\t\ttag_nl_leaf: false,\n\t\t\n\t\tplace_cursor: true,\n\t\t\n\t\t// indent tags\n\t\tindent: true,\n\t\t\n\t\t// how many inline elements should be to force line break \n\t\t// (set to 0 to disable)\n\t\tinline_break: 3,\n\t\t\n\t\t// use self-closing style for writing empty elements, e.g. <br /> or <br>\n\t\tself_closing_tag: 'xhtml',\n\t\t\n\t\t// Profile-level output filters, re-defines syntax filters \n\t\tfilters: '',\n\t\t\n\t\t// Additional filters applied to abbreviation.\n\t\t// Unlike \"filters\", this preference doesn't override default filters\n\t\t// but add the instead every time given profile is chosen\n\t\textraFilters: ''\n\t};\n\t\n\t/**\n\t * @constructor\n\t * @type OutputProfile\n\t * @param {Object} options\n\t */\n\tfunction OutputProfile(options) {\n\t\t_.extend(this, defaultProfile, options);\n\t}\n\t\n\tOutputProfile.prototype = {\n\t\t/**\n\t\t * Transforms tag name case depending on current profile settings\n\t\t * @param {String} name String to transform\n\t\t * @returns {String}\n\t\t */\n\t\ttagName: function(name) {\n\t\t\treturn stringCase(name, this.tag_case);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Transforms attribute name case depending on current profile settings \n\t\t * @param {String} name String to transform\n\t\t * @returns {String}\n\t\t */\n\t\tattributeName: function(name) {\n\t\t\treturn stringCase(name, this.attr_case);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns quote character for current profile\n\t\t * @returns {String}\n\t\t */\n\t\tattributeQuote: function() {\n\t\t\treturn this.attr_quotes == 'single' ? \"'\" : '\"';\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns self-closing tag symbol for current profile\n\t\t * @param {String} param\n\t\t * @returns {String}\n\t\t */\n\t\tselfClosing: function(param) {\n\t\t\tif (this.self_closing_tag == 'xhtml')\n\t\t\t\treturn ' /';\n\t\t\t\n\t\t\tif (this.self_closing_tag === true)\n\t\t\t\treturn '/';\n\t\t\t\n\t\t\treturn '';\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns cursor token based on current profile settings\n\t\t * @returns {String}\n\t\t */\n\t\tcursor: function() {\n\t\t\treturn this.place_cursor ? require('utils').getCaretPlaceholder() : '';\n\t\t}\n\t};\n\t\n\t/**\n\t * Helper function that converts string case depending on \n\t * <code>caseValue</code> \n\t * @param {String} str String to transform\n\t * @param {String} caseValue Case value: can be <i>lower</i>, \n\t * <i>upper</i> and <i>leave</i>\n\t * @returns {String}\n\t */\n\tfunction stringCase(str, caseValue) {\n\t\tswitch (String(caseValue || '').toLowerCase()) {\n\t\t\tcase 'lower':\n\t\t\t\treturn str.toLowerCase();\n\t\t\tcase 'upper':\n\t\t\t\treturn str.toUpperCase();\n\t\t}\n\t\t\n\t\treturn str;\n\t}\n\t\n\t/**\n\t * Creates new output profile\n\t * @param {String} name Profile name\n\t * @param {Object} options Profile options\n\t */\n\tfunction createProfile(name, options) {\n\t\treturn profiles[name.toLowerCase()] = new OutputProfile(options);\n\t}\n\t\n\tfunction createDefaultProfiles() {\n\t\tcreateProfile('xhtml');\n\t\tcreateProfile('html', {self_closing_tag: false});\n\t\tcreateProfile('xml', {self_closing_tag: true, tag_nl: true});\n\t\tcreateProfile('plain', {tag_nl: false, indent: false, place_cursor: false});\n\t\tcreateProfile('line', {tag_nl: false, indent: false, extraFilters: 's'});\n\t}\n\t\n\tcreateDefaultProfiles();\n\t\n\treturn  {\n\t\t/**\n\t\t * Creates new output profile and adds it into internal dictionary\n\t\t * @param {String} name Profile name\n\t\t * @param {Object} options Profile options\n\t\t * @memberOf emmet.profile\n\t\t * @returns {Object} New profile\n\t\t */\n\t\tcreate: function(name, options) {\n\t\t\tif (arguments.length == 2)\n\t\t\t\treturn createProfile(name, options);\n\t\t\telse\n\t\t\t\t// create profile object only\n\t\t\t\treturn new OutputProfile(_.defaults(name || {}, defaultProfile));\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns profile by its name. If profile wasn't found, returns\n\t\t * 'plain' profile\n\t\t * @param {String} name Profile name. Might be profile itself\n\t\t * @param {String} syntax. Optional. Current editor syntax. If defined,\n\t\t * profile is searched in resources first, then in predefined profiles\n\t\t * @returns {Object}\n\t\t */\n\t\tget: function(name, syntax) {\n\t\t\tif (!name && syntax) {\n\t\t\t\t// search in user resources first\n\t\t\t\tvar profile = require('resources').findItem(syntax, 'profile');\n\t\t\t\tif (profile) {\n\t\t\t\t\tname = profile;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (!name) {\n\t\t\t\treturn profiles.plain;\n\t\t\t}\n\t\t\t\n\t\t\tif (name instanceof OutputProfile) {\n\t\t\t\treturn name;\n\t\t\t}\n\t\t\t\n\t\t\tif (_.isString(name) && name.toLowerCase() in profiles) {\n\t\t\t\treturn profiles[name.toLowerCase()];\n\t\t\t}\n\t\t\t\n\t\t\treturn this.create(name);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Deletes profile with specified name\n\t\t * @param {String} name Profile name\n\t\t */\n\t\tremove: function(name) {\n\t\t\tname = (name || '').toLowerCase();\n\t\t\tif (name in profiles)\n\t\t\t\tdelete profiles[name];\n\t\t},\n\t\t\n\t\t/**\n\t\t * Resets all user-defined profiles\n\t\t */\n\t\treset: function() {\n\t\t\tprofiles = {};\n\t\t\tcreateDefaultProfiles();\n\t\t},\n\t\t\n\t\t/**\n\t\t * Helper function that converts string case depending on \n\t\t * <code>caseValue</code> \n\t\t * @param {String} str String to transform\n\t\t * @param {String} caseValue Case value: can be <i>lower</i>, \n\t\t * <i>upper</i> and <i>leave</i>\n\t\t * @returns {String}\n\t\t */\n\t\tstringCase: stringCase\n\t};\n});/**\n * Utility module used to prepare text for pasting into back-end editor\n * @param {Function} require\n * @param {Underscore} _\n * @author Sergey Chikuyonok (serge.che@gmail.com) <http://chikuyonok.ru>\n */\nemmet.define('editorUtils', function(require, _) {\n\treturn  {\n\t\t/**\n\t\t * Check if cursor is placed inside XHTML tag\n\t\t * @param {String} html Contents of the document\n\t\t * @param {Number} caretPos Current caret position inside tag\n\t\t * @return {Boolean}\n\t\t */\n\t\tisInsideTag: function(html, caretPos) {\n\t\t\tvar reTag = /^<\\/?\\w[\\w\\:\\-]*.*?>/;\n\t\t\t\n\t\t\t// search left to find opening brace\n\t\t\tvar pos = caretPos;\n\t\t\twhile (pos > -1) {\n\t\t\t\tif (html.charAt(pos) == '<') \n\t\t\t\t\tbreak;\n\t\t\t\tpos--;\n\t\t\t}\n\t\t\t\n\t\t\tif (pos != -1) {\n\t\t\t\tvar m = reTag.exec(html.substring(pos));\n\t\t\t\tif (m && caretPos > pos && caretPos < pos + m[0].length)\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Sanitizes incoming editor data and provides default values for\n\t\t * output-specific info\n\t\t * @param {IEmmetEditor} editor\n\t\t * @param {String} syntax\n\t\t * @param {String} profile\n\t\t */\n\t\toutputInfo: function(editor, syntax, profile) {\n\t\t\t// most of this code makes sense for Java/Rhino environment\n\t\t\t// because string that comes from Java are not actually JS string\n\t\t\t// but Java String object so the have to be explicitly converted\n\t\t\t// to native string\n\t\t\tprofile = profile || editor.getProfileName();\n\t\t\treturn  {\n\t\t\t\t/** @memberOf outputInfo */\n\t\t\t\tsyntax: String(syntax || editor.getSyntax()),\n\t\t\t\tprofile: profile || null,\n\t\t\t\tcontent: String(editor.getContent())\n\t\t\t};\n\t\t},\n\t\t\n\t\t/**\n\t\t * Unindent content, thus preparing text for tag wrapping\n\t\t * @param {IEmmetEditor} editor Editor instance\n\t\t * @param {String} text\n\t\t * @return {String}\n\t\t */\n\t\tunindent: function(editor, text) {\n\t\t\treturn require('utils').unindentString(text, this.getCurrentLinePadding(editor));\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns padding of current editor's line\n\t\t * @param {IEmmetEditor} Editor instance\n\t\t * @return {String}\n\t\t */\n\t\tgetCurrentLinePadding: function(editor) {\n\t\t\treturn require('utils').getLinePadding(editor.getCurrentLine());\n\t\t}\n\t};\n});\n/**\n * Utility methods for Emmet actions\n * @param {Function} require\n * @param {Underscore} _\n * @author Sergey Chikuyonok (serge.che@gmail.com) <http://chikuyonok.ru>\n */\nemmet.define('actionUtils', function(require, _) {\n\treturn {\n\t\tmimeTypes: {\n\t\t\t'gif' : 'image/gif',\n\t\t\t'png' : 'image/png',\n\t\t\t'jpg' : 'image/jpeg',\n\t\t\t'jpeg': 'image/jpeg',\n\t\t\t'svg' : 'image/svg+xml',\n\t\t\t'html': 'text/html',\n\t\t\t'htm' : 'text/html'\n\t\t},\n\t\t\n\t\t/**\n\t\t * Extracts abbreviations from text stream, starting from the end\n\t\t * @param {String} str\n\t\t * @return {String} Abbreviation or empty string\n\t\t * @memberOf emmet.actionUtils\n\t\t */\n\t\textractAbbreviation: function(str) {\n\t\t\tvar curOffset = str.length;\n\t\t\tvar startIndex = -1;\n\t\t\tvar groupCount = 0;\n\t\t\tvar braceCount = 0;\n\t\t\tvar textCount = 0;\n\t\t\t\n\t\t\tvar utils = require('utils');\n\t\t\tvar parser = require('abbreviationParser');\n\t\t\t\n\t\t\twhile (true) {\n\t\t\t\tcurOffset--;\n\t\t\t\tif (curOffset < 0) {\n\t\t\t\t\t// moved to the beginning of the line\n\t\t\t\t\tstartIndex = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar ch = str.charAt(curOffset);\n\t\t\t\t\n\t\t\t\tif (ch == ']') {\n\t\t\t\t\tbraceCount++;\n\t\t\t\t} else if (ch == '[') {\n\t\t\t\t\tif (!braceCount) { // unexpected brace\n\t\t\t\t\t\tstartIndex = curOffset + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbraceCount--;\n\t\t\t\t} else if (ch == '}') {\n\t\t\t\t\ttextCount++;\n\t\t\t\t} else if (ch == '{') {\n\t\t\t\t\tif (!textCount) { // unexpected brace\n\t\t\t\t\t\tstartIndex = curOffset + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ttextCount--;\n\t\t\t\t} else if (ch == ')') {\n\t\t\t\t\tgroupCount++;\n\t\t\t\t} else if (ch == '(') {\n\t\t\t\t\tif (!groupCount) { // unexpected brace\n\t\t\t\t\t\tstartIndex = curOffset + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tgroupCount--;\n\t\t\t\t} else {\n\t\t\t\t\tif (braceCount || textCount) \n\t\t\t\t\t\t// respect all characters inside attribute sets or text nodes\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse if (!parser.isAllowedChar(ch) || (ch == '>' && utils.endsWithTag(str.substring(0, curOffset + 1)))) {\n\t\t\t\t\t\t// found stop symbol\n\t\t\t\t\t\tstartIndex = curOffset + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (startIndex != -1 && !textCount && !braceCount && !groupCount) \n\t\t\t\t// found something, remove some invalid symbols from the \n\t\t\t\t// beginning and return abbreviation\n\t\t\t\treturn str.substring(startIndex).replace(/^[\\*\\+\\>\\^]+/, '');\n\t\t\telse\n\t\t\t\treturn '';\n\t\t},\n\t\t\n\t\t/**\n\t\t * Gets image size from image byte stream.\n\t\t * @author http://romeda.org/rePublish/\n\t\t * @param {String} stream Image byte stream (use <code>IEmmetFile.read()</code>)\n\t\t * @return {Object} Object with <code>width</code> and <code>height</code> properties\n\t\t */\n\t\tgetImageSize: function(stream) {\n\t\t\tvar pngMagicNum = \"\\211PNG\\r\\n\\032\\n\",\n\t\t\t\tjpgMagicNum = \"\\377\\330\",\n\t\t\t\tgifMagicNum = \"GIF8\",\n\t\t\t\tnextByte = function() {\n\t\t\t\t\treturn stream.charCodeAt(pos++);\n\t\t\t\t};\n\t\t\n\t\t\tif (stream.substr(0, 8) === pngMagicNum) {\n\t\t\t\t// PNG. Easy peasy.\n\t\t\t\tvar pos = stream.indexOf('IHDR') + 4;\n\t\t\t\n\t\t\t\treturn { width:  (nextByte() << 24) | (nextByte() << 16) |\n\t\t\t\t\t\t\t\t (nextByte() <<  8) | nextByte(),\n\t\t\t\t\t\t height: (nextByte() << 24) | (nextByte() << 16) |\n\t\t\t\t\t\t\t\t (nextByte() <<  8) | nextByte() };\n\t\t\t\n\t\t\t} else if (stream.substr(0, 4) === gifMagicNum) {\n\t\t\t\tpos = 6;\n\t\t\t\n\t\t\t\treturn {\n\t\t\t\t\twidth:  nextByte() | (nextByte() << 8),\n\t\t\t\t\theight: nextByte() | (nextByte() << 8)\n\t\t\t\t};\n\t\t\t\n\t\t\t} else if (stream.substr(0, 2) === jpgMagicNum) {\n\t\t\t\tpos = 2;\n\t\t\t\n\t\t\t\tvar l = stream.length;\n\t\t\t\twhile (pos < l) {\n\t\t\t\t\tif (nextByte() != 0xFF) return;\n\t\t\t\t\n\t\t\t\t\tvar marker = nextByte();\n\t\t\t\t\tif (marker == 0xDA) break;\n\t\t\t\t\n\t\t\t\t\tvar size = (nextByte() << 8) | nextByte();\n\t\t\t\t\n\t\t\t\t\tif (marker >= 0xC0 && marker <= 0xCF && !(marker & 0x4) && !(marker & 0x8)) {\n\t\t\t\t\t\tpos += 1;\n\t\t\t\t\t\treturn { height:  (nextByte() << 8) | nextByte(),\n\t\t\t\t\t\t\t\t width: (nextByte() << 8) | nextByte() };\n\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpos += size - 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Captures context XHTML element from editor under current caret position.\n\t\t * This node can be used as a helper for abbreviation extraction\n\t\t * @param {IEmmetEditor} editor\n\t\t * @returns {Object}\n\t\t */\n\t\tcaptureContext: function(editor) {\n\t\t\tvar allowedSyntaxes = {'html': 1, 'xml': 1, 'xsl': 1};\n\t\t\tvar syntax = String(editor.getSyntax());\n\t\t\tif (syntax in allowedSyntaxes) {\n\t\t\t\tvar content = String(editor.getContent());\n\t\t\t\tvar tag = require('htmlMatcher').find(content, editor.getCaretPos());\n\t\t\t\t\n\t\t\t\tif (tag && tag.type == 'tag') {\n\t\t\t\t\tvar startTag = tag.open;\n\t\t\t\t\tvar contextNode = {\n\t\t\t\t\t\tname: startTag.name,\n\t\t\t\t\t\tattributes: []\n\t\t\t\t\t};\n\t\t\t\t\t\n\t\t\t\t\t// parse attributes\n\t\t\t\t\tvar tagTree = require('xmlEditTree').parse(startTag.range.substring(content));\n\t\t\t\t\tif (tagTree) {\n\t\t\t\t\t\tcontextNode.attributes = _.map(tagTree.getAll(), function(item) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tname: item.name(),\n\t\t\t\t\t\t\t\tvalue: item.value()\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\treturn contextNode;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn null;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Find expression bounds in current editor at caret position. \n\t\t * On each character a <code>fn</code> function will be called and must \n\t\t * return <code>true</code> if current character meets requirements, \n\t\t * <code>false</code> otherwise\n\t\t * @param {IEmmetEditor} editor\n\t\t * @param {Function} fn Function to test each character of expression\n\t\t * @return {Range}\n\t\t */\n\t\tfindExpressionBounds: function(editor, fn) {\n\t\t\tvar content = String(editor.getContent());\n\t\t\tvar il = content.length;\n\t\t\tvar exprStart = editor.getCaretPos() - 1;\n\t\t\tvar exprEnd = exprStart + 1;\n\t\t\t\t\n\t\t\t// start by searching left\n\t\t\twhile (exprStart >= 0 && fn(content.charAt(exprStart), exprStart, content)) exprStart--;\n\t\t\t\n\t\t\t// then search right\n\t\t\twhile (exprEnd < il && fn(content.charAt(exprEnd), exprEnd, content)) exprEnd++;\n\t\t\t\n\t\t\tif (exprEnd > exprStart) {\n\t\t\t\treturn require('range').create([++exprStart, exprEnd]);\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * @param {IEmmetEditor} editor\n\t\t * @param {Object} data\n\t\t * @returns {Boolean}\n\t\t */\n\t\tcompoundUpdate: function(editor, data) {\n\t\t\tif (data) {\n\t\t\t\tvar sel = editor.getSelectionRange();\n\t\t\t\teditor.replaceContent(data.data, data.start, data.end, true);\n\t\t\t\teditor.createSelection(data.caret, data.caret + sel.end - sel.start);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Common syntax detection method for editors that doesn’t provide any\n\t\t * info about current syntax scope. \n\t\t * @param {IEmmetEditor} editor Current editor\n\t\t * @param {String} hint Any syntax hint that editor can provide \n\t\t * for syntax detection. Default is 'html'\n\t\t * @returns {String} \n\t\t */\n\t\tdetectSyntax: function(editor, hint) {\n\t\t\tvar syntax = hint || 'html';\n\t\t\t\n\t\t\tif (!require('resources').hasSyntax(syntax)) {\n\t\t\t\tsyntax = 'html';\n\t\t\t}\n\t\t\t\n\t\t\tif (syntax == 'html' && (this.isStyle(editor) || this.isInlineCSS(editor))) {\n\t\t\t\tsyntax = 'css';\n\t\t\t}\n\t\t\t\n\t\t\treturn syntax;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Common method for detecting output profile\n\t\t * @param {IEmmetEditor} editor\n\t\t * @returns {String}\n\t\t */\n\t\tdetectProfile: function(editor) {\n\t\t\tvar syntax = editor.getSyntax();\n\t\t\t\n\t\t\t// get profile from syntax definition\n\t\t\tvar profile = require('resources').findItem(syntax, 'profile');\n\t\t\tif (profile) {\n\t\t\t\treturn profile;\n\t\t\t}\n\t\t\t\n\t\t\tswitch(syntax) {\n\t\t\t\tcase 'xml':\n\t\t\t\tcase 'xsl':\n\t\t\t\t\treturn 'xml';\n\t\t\t\tcase 'css':\n\t\t\t\t\tif (this.isInlineCSS(editor)) {\n\t\t\t\t\t\treturn 'line';\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'html':\n\t\t\t\t\tvar profile = require('resources').getVariable('profile');\n\t\t\t\t\tif (!profile) { // no forced profile, guess from content\n\t\t\t\t\t\t// html or xhtml?\n\t\t\t\t\t\tprofile = this.isXHTML(editor) ? 'xhtml': 'html';\n\t\t\t\t\t}\n\n\t\t\t\t\treturn profile;\n\t\t\t}\n\n\t\t\treturn 'xhtml';\n\t\t},\n\t\t\n\t\t/**\n\t\t * Tries to detect if current document is XHTML one.\n\t\t * @param {IEmmetEditor} editor\n\t\t * @returns {Boolean}\n\t\t */\n\t\tisXHTML: function(editor) {\n\t\t\treturn editor.getContent().search(/<!DOCTYPE[^>]+XHTML/i) != -1;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if current caret position is inside &lt;style&gt; tag\n\t\t * @param {IEmmetEditor} editor\n\t\t * @returns\n\t\t */\n\t\tisStyle: function(editor) {\n\t\t\tvar content = String(editor.getContent());\n\t\t\tvar caretPos = editor.getCaretPos();\n\t\t\tvar tag = require('htmlMatcher').tag(content, caretPos);\n\t\t\treturn tag && tag.open.name.toLowerCase() == 'style' \n\t\t\t\t&& tag.innerRange.cmp(caretPos, 'lte', 'gte');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if current caret position is inside \"style\" attribute of HTML\n\t\t * element\n\t\t * @param {IEmmetEditor} editor\n\t\t * @returns {Boolean}\n\t\t */\n\t\tisInlineCSS: function(editor) {\n\t\t\tvar content = String(editor.getContent());\n\t\t\tvar caretPos = editor.getCaretPos();\n\t\t\tvar tree = require('xmlEditTree').parseFromPosition(content, caretPos, true);\n            if (tree) {\n                var attr = tree.itemFromPosition(caretPos, true);\n                return attr && attr.name().toLowerCase() == 'style' \n                \t&& attr.valueRange(true).cmp(caretPos, 'lte', 'gte');\n            }\n            \n            return false;\n\t\t}\n\t};\n});/**\n * Utility functions to work with <code>AbbreviationNode</code> as HTML element\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.define('abbreviationUtils', function(require, _) {\n\treturn {\n\t\t/**\n\t\t * Check if passed abbreviation node has matched snippet resource\n\t\t * @param {AbbreviationNode} node\n\t\t * @returns {Boolean}\n\t\t * @memberOf abbreviationUtils\n\t\t */\n\t\tisSnippet: function(node) {\n\t\t\treturn require('elements').is(node.matchedResource(), 'snippet');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Test if passed node is unary (no closing tag)\n\t\t * @param {AbbreviationNode} node\n\t\t * @return {Boolean}\n\t\t */\n\t\tisUnary: function(node) {\n\t\t\tif (node.children.length || node._text || this.isSnippet(node)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tvar r = node.matchedResource();\n\t\t\treturn r && r.is_empty;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Test if passed node is inline-level (like &lt;strong&gt;, &lt;img&gt;)\n\t\t * @param {AbbreviationNode} node\n\t\t * @return {Boolean}\n\t\t */\n\t\tisInline: function(node) {\n\t\t\treturn node.isTextNode() \n\t\t\t\t|| !node.name() \n\t\t\t\t|| require('tagName').isInlineLevel(node.name());\n\t\t},\n\t\t\n\t\t/**\n\t\t * Test if passed node is block-level\n\t\t * @param {AbbreviationNode} node\n\t\t * @return {Boolean}\n\t\t */\n\t\tisBlock: function(node) {\n\t\t\treturn this.isSnippet(node) || !this.isInline(node);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Test if given node is a snippet\n\t\t * @param {AbbreviationNode} node\n\t\t * @return {Boolean}\n\t\t */\n\t\tisSnippet: function(node) {\n\t\t\treturn require('elements').is(node.matchedResource(), 'snippet');\n\t\t},\n\t\t\n\t\t/**\n\t\t * This function tests if passed node content contains HTML tags. \n\t\t * This function is mostly used for output formatting\n\t\t * @param {AbbreviationNode} node\n\t\t * @returns {Boolean}\n\t\t */\n\t\thasTagsInContent: function(node) {\n\t\t\treturn require('utils').matchesTag(node.content);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Test if current element contains block-level children\n\t\t * @param {AbbreviationNode} node\n\t\t * @return {Boolean}\n\t\t */\n\t\thasBlockChildren: function(node) {\n\t\t\treturn (this.hasTagsInContent(node) && this.isBlock(node)) \n\t\t\t\t|| _.any(node.children, function(child) {\n\t\t\t\t\treturn this.isBlock(child);\n\t\t\t\t}, this);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Utility function that inserts content instead of <code>${child}</code>\n\t\t * variables on <code>text</code>\n\t\t * @param {String} text Text where child content should be inserted\n\t\t * @param {String} childContent Content to insert\n\t\t * @param {Object} options\n\t\t * @returns {String\n\t\t */\n\t\tinsertChildContent: function(text, childContent, options) {\n\t\t\toptions = _.extend({\n\t\t\t\tkeepVariable: true,\n\t\t\t\tappendIfNoChild: true\n\t\t\t}, options || {});\n\t\t\t\n\t\t\tvar childVariableReplaced = false;\n\t\t\tvar utils = require('utils');\n\t\t\ttext = utils.replaceVariables(text, function(variable, name, data) {\n\t\t\t\tvar output = variable;\n\t\t\t\tif (name == 'child') {\n\t\t\t\t\t// add correct indentation\n\t\t\t\t\toutput = utils.padString(childContent, utils.getLinePaddingFromPosition(text, data.start));\n\t\t\t\t\tchildVariableReplaced = true;\n\t\t\t\t\tif (options.keepVariable)\n\t\t\t\t\t\toutput += variable;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn output;\n\t\t\t});\n\t\t\t\n\t\t\tif (!childVariableReplaced && options.appendIfNoChild) {\n\t\t\t\ttext += childContent;\n\t\t\t}\n\t\t\t\n\t\t\treturn text;\n\t\t}\n\t};\n});/**\n * @author Sergey Chikuyonok (serge.che@gmail.com)\n * @link http://chikuyonok.ru\n */\nemmet.define('base64', function(require, _) {\n\tvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\t\n\treturn {\n\t\t/**\n\t\t * Encodes data using base64 algorithm\n\t\t * @author Tyler Akins (http://rumkin.com)\n\t\t * @param {String} input\n\t\t * @returns {String}\n\t\t * @memberOf emmet.base64\n\t\t */\n\t\tencode : function(input) {\n\t\t\tvar output = [];\n\t\t\tvar chr1, chr2, chr3, enc1, enc2, enc3, enc4, cdp1, cdp2, cdp3;\n\t\t\tvar i = 0, il = input.length, b64 = chars;\n\n\t\t\twhile (i < il) {\n\n\t\t\t\tcdp1 = input.charCodeAt(i++);\n\t\t\t\tcdp2 = input.charCodeAt(i++);\n\t\t\t\tcdp3 = input.charCodeAt(i++);\n\n\t\t\t\tchr1 = cdp1 & 0xff;\n\t\t\t\tchr2 = cdp2 & 0xff;\n\t\t\t\tchr3 = cdp3 & 0xff;\n\n\t\t\t\tenc1 = chr1 >> 2;\n\t\t\t\tenc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\n\t\t\t\tenc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\n\t\t\t\tenc4 = chr3 & 63;\n\n\t\t\t\tif (isNaN(cdp2)) {\n\t\t\t\t\tenc3 = enc4 = 64;\n\t\t\t\t} else if (isNaN(cdp3)) {\n\t\t\t\t\tenc4 = 64;\n\t\t\t\t}\n\n\t\t\t\toutput.push(b64.charAt(enc1) + b64.charAt(enc2) + b64.charAt(enc3) + b64.charAt(enc4));\n\t\t\t}\n\n\t\t\treturn output.join('');\n\t\t},\n\n\t\t/**\n\t\t * Decodes string using MIME base64 algorithm\n\t\t * \n\t\t * @author Tyler Akins (http://rumkin.com)\n\t\t * @param {String} data\n\t\t * @return {String}\n\t\t */\n\t\tdecode : function(data) {\n\t\t\tvar o1, o2, o3, h1, h2, h3, h4, bits, i = 0, ac = 0, tmpArr = [];\n\t\t\tvar b64 = chars, il = data.length;\n\n\t\t\tif (!data) {\n\t\t\t\treturn data;\n\t\t\t}\n\n\t\t\tdata += '';\n\n\t\t\tdo { // unpack four hexets into three octets using index points in b64\n\t\t\t\th1 = b64.indexOf(data.charAt(i++));\n\t\t\t\th2 = b64.indexOf(data.charAt(i++));\n\t\t\t\th3 = b64.indexOf(data.charAt(i++));\n\t\t\t\th4 = b64.indexOf(data.charAt(i++));\n\n\t\t\t\tbits = h1 << 18 | h2 << 12 | h3 << 6 | h4;\n\n\t\t\t\to1 = bits >> 16 & 0xff;\n\t\t\t\to2 = bits >> 8 & 0xff;\n\t\t\t\to3 = bits & 0xff;\n\n\t\t\t\tif (h3 == 64) {\n\t\t\t\t\ttmpArr[ac++] = String.fromCharCode(o1);\n\t\t\t\t} else if (h4 == 64) {\n\t\t\t\t\ttmpArr[ac++] = String.fromCharCode(o1, o2);\n\t\t\t\t} else {\n\t\t\t\t\ttmpArr[ac++] = String.fromCharCode(o1, o2, o3);\n\t\t\t\t}\n\t\t\t} while (i < il);\n\n\t\t\treturn tmpArr.join('');\n\t\t}\n\t};\n});/**\n * HTML matcher: takes string and searches for HTML tag pairs for given position \n * \n * Unlike “classic” matchers, it parses content from the specified \n * position, not from the start, so it may work even outside HTML documents\n * (for example, inside strings of programming languages like JavaScript, Python \n * etc.)\n * @constructor\n * @memberOf __htmlMatcherDefine\n */\nemmet.define('htmlMatcher', function(require, _) {\n\t// Regular Expressions for parsing tags and attributes\n\tvar reOpenTag = /^<([\\w\\:\\-]+)((?:\\s+[\\w\\-:]+(?:\\s*=\\s*(?:(?:\"[^\"]*\")|(?:'[^']*')|[^>\\s]+))?)*)\\s*(\\/?)>/;\n\tvar reCloseTag = /^<\\/([\\w\\:\\-]+)[^>]*>/;\n\t\n\tfunction openTag(i, match) {\n\t\treturn {\n\t\t\tname: match[1],\n\t\t\tselfClose: !!match[3],\n\t\t\t/** @type Range */\n\t\t\trange: require('range').create(i, match[0]),\n\t\t\ttype: 'open'\n\t\t};\n\t}\n\t\n\tfunction closeTag(i, match) {\n\t\treturn {\n\t\t\tname: match[1],\n\t\t\t/** @type Range */\n\t\t\trange: require('range').create(i, match[0]),\n\t\t\ttype: 'close'\n\t\t};\n\t}\n\t\n\tfunction comment(i, match) {\n\t\treturn {\n\t\t\t/** @type Range */\n\t\t\trange: require('range').create(i, _.isNumber(match) ? match - i : match[0]),\n\t\t\ttype: 'comment'\n\t\t};\n\t}\n\t\n\t/**\n\t * Creates new tag matcher session\n\t * @param {String} text\n\t */\n\tfunction createMatcher(text) {\n\t\tvar memo = {}, m;\n\t\treturn {\n\t\t\t/**\n\t\t\t * Test if given position matches opening tag\n\t\t\t * @param {Number} i\n\t\t\t * @returns {Object} Matched tag object\n\t\t\t */\n\t\t\topen: function(i) {\n\t\t\t\tvar m = this.matches(i);\n\t\t\t\treturn m && m.type == 'open' ? m : null;\n\t\t\t},\n\t\t\t\n\t\t\t/**\n\t\t\t * Test if given position matches closing tag\n\t\t\t * @param {Number} i\n\t\t\t * @returns {Object} Matched tag object\n\t\t\t */\n\t\t\tclose: function(i) {\n\t\t\t\tvar m = this.matches(i);\n\t\t\t\treturn m && m.type == 'close' ? m : null;\n\t\t\t},\n\t\t\t\n\t\t\t/**\n\t\t\t * Matches either opening or closing tag for given position\n\t\t\t * @param i\n\t\t\t * @returns\n\t\t\t */\n\t\t\tmatches: function(i) {\n\t\t\t\tvar key = 'p' + i;\n\t\t\t\t\n\t\t\t\tif (!(key in memo)) {\n\t\t\t\t\tif (text.charAt(i) == '<') {\n\t\t\t\t\t\tvar substr = text.slice(i);\n\t\t\t\t\t\tif (m = substr.match(reOpenTag)) {\n\t\t\t\t\t\t\tmemo[key] = openTag(i, m);\n\t\t\t\t\t\t} else if (m = substr.match(reCloseTag)) {\n\t\t\t\t\t\t\tmemo[key] = closeTag(i, m);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// remember that given position contains no valid tag\n\t\t\t\t\t\t\tmemo[key] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn memo[key];\n\t\t\t},\n\t\t\t\n\t\t\t/**\n\t\t\t * Returns original text\n\t\t\t * @returns {String}\n\t\t\t */\n\t\t\ttext: function() {\n\t\t\t\treturn text;\n\t\t\t}\n\t\t};\n\t}\n\t\n\tfunction matches(text, pos, pattern) {\n\t\treturn text.substring(pos, pos + pattern.length) == pattern;\n\t}\n\t\n\t/**\n\t * Search for closing pair of opening tag\n\t * @param {Object} open Open tag instance\n\t * @param {Object} matcher Matcher instance\n\t */\n\tfunction findClosingPair(open, matcher) {\n\t\tvar stack = [], tag = null;\n\t\tvar text = matcher.text();\n\t\t\n\t\tfor (var pos = open.range.end, len = text.length; pos < len; pos++) {\n\t\t\tif (matches(text, pos, '<!--')) {\n\t\t\t\t// skip to end of comment\n\t\t\t\tfor (var j = pos; j < len; j++) {\n\t\t\t\t\tif (matches(text, j, '-->')) {\n\t\t\t\t\t\tpos = j + 3;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (tag = matcher.matches(pos)) {\n\t\t\t\tif (tag.type == 'open' && !tag.selfClose) {\n\t\t\t\t\tstack.push(tag.name);\n\t\t\t\t} else if (tag.type == 'close') {\n\t\t\t\t\tif (!stack.length) { // found valid pair?\n\t\t\t\t\t\treturn tag.name == open.name ? tag : null;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// check if current closing tag matches previously opened one\n\t\t\t\t\tif (_.last(stack) == tag.name) {\n\t\t\t\t\t\tstack.pop();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar found = false;\n\t\t\t\t\t\twhile (stack.length && !found) {\n\t\t\t\t\t\t\tvar last = stack.pop();\n\t\t\t\t\t\t\tif (last == tag.name) {\n\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (!stack.length && !found) {\n\t\t\t\t\t\t\treturn tag.name == open.name ? tag : null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t\n\treturn {\n\t\t/**\n\t\t * Main function: search for tag pair in <code>text</code> for given \n\t\t * position\n\t\t * @memberOf htmlMatcher\n\t\t * @param {String} text \n\t\t * @param {Number} pos\n\t\t * @returns {Object}\n\t\t */\n\t\tfind: function(text, pos) {\n\t\t\tvar range = require('range');\n\t\t\tvar matcher = createMatcher(text); \n\t\t\tvar open = null, close = null;\n\t\t\t\n\t\t\tfor (var i = pos; i >= 0; i--) {\n\t\t\t\tif (open = matcher.open(i)) {\n\t\t\t\t\t// found opening tag\n\t\t\t\t\tif (open.selfClose) {\n\t\t\t\t\t\tif (open.range.cmp(pos, 'lt', 'gt')) {\n\t\t\t\t\t\t\t// inside self-closing tag, found match\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// outside self-closing tag, continue\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tclose = findClosingPair(open, matcher);\n\t\t\t\t\tif (close) {\n\t\t\t\t\t\t// found closing tag.\n\t\t\t\t\t\tvar r = range.create2(open.range.start, close.range.end);\n\t\t\t\t\t\tif (r.contains(pos)) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (open.range.contains(pos)) {\n\t\t\t\t\t\t// we inside empty HTML tag like <br>\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\topen = null;\n\t\t\t\t} else if (matches(text, i, '-->')) {\n\t\t\t\t\t// skip back to comment start\n\t\t\t\t\tfor (var j = i - 1; j >= 0; j--) {\n\t\t\t\t\t\tif (matches(text, j, '-->')) {\n\t\t\t\t\t\t\t// found another comment end, do nothing\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if (matches(text, j, '<!--')) {\n\t\t\t\t\t\t\ti = j;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (matches(text, i, '<!--')) {\n\t\t\t\t\t// we're inside comment, match it\n\t\t\t\t\tvar j = i + 4, jl = text.length;\n\t\t\t\t\tfor (; j < jl; j++) {\n\t\t\t\t\t\tif (matches(text, j, '-->')) {\n\t\t\t\t\t\t\tj += 3;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\topen = comment(i, j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (open) {\n\t\t\t\tvar outerRange = null;\n\t\t\t\tvar innerRange = null;\n\t\t\t\t\n\t\t\t\tif (close) {\n\t\t\t\t\touterRange = range.create2(open.range.start, close.range.end);\n\t\t\t\t\tinnerRange = range.create2(open.range.end, close.range.start);\n\t\t\t\t} else {\n\t\t\t\t\touterRange = innerRange = range.create2(open.range.start, open.range.end);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (open.type == 'comment') {\n\t\t\t\t\t// adjust positions of inner range for comment\n\t\t\t\t\tvar _c = outerRange.substring(text);\n\t\t\t\t\tinnerRange.start += _c.length - _c.replace(/^<\\!--\\s*/, '').length;\n\t\t\t\t\tinnerRange.end -= _c.length - _c.replace(/\\s*-->$/, '').length;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn {\n\t\t\t\t\topen: open,\n\t\t\t\t\tclose: close,\n\t\t\t\t\ttype: open.type == 'comment' ? 'comment' : 'tag',\n\t\t\t\t\tinnerRange: innerRange,\n\t\t\t\t\tinnerContent: function() {\n\t\t\t\t\t\treturn this.innerRange.substring(text);\n\t\t\t\t\t},\n\t\t\t\t\touterRange: outerRange,\n\t\t\t\t\touterContent: function() {\n\t\t\t\t\t\treturn this.outerRange.substring(text);\n\t\t\t\t\t},\n\t\t\t\t\trange: !innerRange.length() || !innerRange.cmp(pos, 'lte', 'gte') ? outerRange : innerRange,\n\t\t\t\t\tcontent: function() {\n\t\t\t\t\t\treturn this.range.substring(text);\n\t\t\t\t\t},\n\t\t\t\t\tsource: text\n\t\t\t\t};\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * The same as <code>find()</code> method, but restricts matched result \n\t\t * to <code>tag</code> type\n\t\t * @param {String} text \n\t\t * @param {Number} pos\n\t\t * @returns {Object}\n\t\t */\n\t\ttag: function(text, pos) {\n\t\t\tvar result = this.find(text, pos);\n\t\t\tif (result && result.type == 'tag') {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t};\n});/**\n * Utility module for handling tabstops tokens generated by Emmet's \n * \"Expand Abbreviation\" action. The main <code>extract</code> method will take\n * raw text (for example: <i>${0} some ${1:text}</i>), find all tabstops \n * occurrences, replace them with tokens suitable for your editor of choice and \n * return object with processed text and list of found tabstops and their ranges.\n * For sake of portability (Objective-C/Java) the tabstops list is a plain \n * sorted array with plain objects.\n * \n * Placeholders with the same are meant to be <i>linked</i> in your editor.\n * @param {Function} require\n * @param {Underscore} _  \n */\nemmet.define('tabStops', function(require, _) {\n\t/**\n\t * Global placeholder value, automatically incremented by \n\t * <code>variablesResolver()</code> function\n\t */\n\tvar startPlaceholderNum = 100;\n\t\n\tvar tabstopIndex = 0;\n\t\n\tvar defaultOptions = {\n\t\treplaceCarets: false,\n\t\tescape: function(ch) {\n\t\t\treturn '\\\\' + ch;\n\t\t},\n\t\ttabstop: function(data) {\n\t\t\treturn data.token;\n\t\t},\n\t\tvariable: function(data) {\n\t\t\treturn data.token;\n\t\t}\n\t};\n\t\n\t// XXX register output processor that will upgrade tabstops of parsed node\n\t// in order to prevent tabstop index conflicts\n\trequire('abbreviationParser').addOutputProcessor(function(text, node, type) {\n\t\tvar maxNum = 0;\n\t\tvar tabstops = require('tabStops');\n\t\tvar utils = require('utils');\n\t\t\n\t\tvar tsOptions = {\n\t\t\ttabstop: function(data) {\n\t\t\t\tvar group = parseInt(data.group);\n\t\t\t\tif (group == 0)\n\t\t\t\t\treturn '${0}';\n\t\t\t\t\n\t\t\t\tif (group > maxNum) maxNum = group;\n\t\t\t\tif (data.placeholder) {\n\t\t\t\t\t// respect nested placeholders\n\t\t\t\t\tvar ix = group + tabstopIndex;\n\t\t\t\t\tvar placeholder = tabstops.processText(data.placeholder, tsOptions);\n\t\t\t\t\treturn '${' + ix + ':' + placeholder + '}';\n\t\t\t\t} else {\n\t\t\t\t\treturn '${' + (group + tabstopIndex) + '}';\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\t\n\t\t// upgrade tabstops\n\t\ttext = tabstops.processText(text, tsOptions);\n\t\t\n\t\t// resolve variables\n\t\ttext = utils.replaceVariables(text, tabstops.variablesResolver(node));\n\t\t\n\t\ttabstopIndex += maxNum + 1;\n\t\treturn text;\n\t});\n\t\n\treturn {\n\t\t/**\n\t\t * Main function that looks for a tabstops in provided <code>text</code>\n\t\t * and returns a processed version of <code>text</code> with expanded \n\t\t * placeholders and list of tabstops found.\n\t\t * @param {String} text Text to process\n\t\t * @param {Object} options List of processor options:<br>\n\t\t * \n\t\t * <b>replaceCarets</b> : <code>Boolean</code> — replace all default\n\t\t * caret placeholders (like <i>{%::emmet-caret::%}</i>) with <i>${0:caret}</i><br>\n\t\t * \n\t\t * <b>escape</b> : <code>Function</code> — function that handle escaped\n\t\t * characters (mostly '$'). By default, it returns the character itself \n\t\t * to be displayed as is in output, but sometimes you will use \n\t\t * <code>extract</code> method as intermediate solution for further \n\t\t * processing and want to keep character escaped. Thus, you should override\n\t\t * <code>escape</code> method to return escaped symbol (e.g. '\\\\$')<br>\n\t\t * \n\t\t * <b>tabstop</b> : <code>Function</code> – a tabstop handler. Receives \n\t\t * a single argument – an object describing token: its position, number \n\t\t * group, placeholder and token itself. Should return a replacement \n\t\t * string that will appear in final output\n\t\t * \n\t\t * <b>variable</b> : <code>Function</code> – variable handler. Receives \n\t\t * a single argument – an object describing token: its position, name \n\t\t * and original token itself. Should return a replacement \n\t\t * string that will appear in final output\n\t\t * \n\t\t * @returns {Object} Object with processed <code>text</code> property\n\t\t * and array of <code>tabstops</code> found\n\t\t * @memberOf tabStops\n\t\t */\n\t\textract: function(text, options) {\n\t\t\t// prepare defaults\n\t\t\tvar utils = require('utils');\n\t\t\tvar placeholders = {carets: ''};\n\t\t\tvar marks = [];\n\t\t\t\n\t\t\toptions = _.extend({}, defaultOptions, options, {\n\t\t\t\ttabstop: function(data) {\n\t\t\t\t\tvar token = data.token;\n\t\t\t\t\tvar ret = '';\n\t\t\t\t\tif (data.placeholder == 'cursor') {\n\t\t\t\t\t\tmarks.push({\n\t\t\t\t\t\t\tstart: data.start,\n\t\t\t\t\t\t\tend: data.start + token.length,\n\t\t\t\t\t\t\tgroup: 'carets',\n\t\t\t\t\t\t\tvalue: ''\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// unify placeholder value for single group\n\t\t\t\t\t\tif ('placeholder' in data)\n\t\t\t\t\t\t\tplaceholders[data.group] = data.placeholder;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (data.group in placeholders)\n\t\t\t\t\t\t\tret = placeholders[data.group];\n\t\t\t\t\t\t\n\t\t\t\t\t\tmarks.push({\n\t\t\t\t\t\t\tstart: data.start,\n\t\t\t\t\t\t\tend: data.start + token.length,\n\t\t\t\t\t\t\tgroup: data.group,\n\t\t\t\t\t\t\tvalue: ret\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\treturn token;\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\tif (options.replaceCarets) {\n\t\t\t\ttext = text.replace(new RegExp( utils.escapeForRegexp( utils.getCaretPlaceholder() ), 'g'), '${0:cursor}');\n\t\t\t}\n\t\t\t\n\t\t\t// locate tabstops and unify group's placeholders\n\t\t\ttext = this.processText(text, options);\n\t\t\t\n\t\t\t// now, replace all tabstops with placeholders\n\t\t\tvar buf = utils.stringBuilder(), lastIx = 0;\n\t\t\tvar tabStops = _.map(marks, function(mark) {\n\t\t\t\tbuf.append(text.substring(lastIx, mark.start));\n\t\t\t\t\n\t\t\t\tvar pos = buf.length;\n\t\t\t\tvar ph = placeholders[mark.group] || '';\n\t\t\t\t\n\t\t\t\tbuf.append(ph);\n\t\t\t\tlastIx = mark.end;\n\t\t\t\t\n\t\t\t\treturn {\n\t\t\t\t\tgroup: mark.group,\n\t\t\t\t\tstart: pos,\n\t\t\t\t\tend:  pos + ph.length\n\t\t\t\t};\n\t\t\t});\n\t\t\t\n\t\t\tbuf.append(text.substring(lastIx));\n\t\t\t\n\t\t\treturn {\n\t\t\t\ttext: buf.toString(),\n\t\t\t\ttabstops: _.sortBy(tabStops, 'start')\n\t\t\t};\n\t\t},\n\t\t\n\t\t/**\n\t\t * Text processing routine. Locates escaped characters and tabstops and\n\t\t * replaces them with values returned by handlers defined in \n\t\t * <code>options</code>\n\t\t * @param {String} text\n\t\t * @param {Object} options See <code>extract</code> method options \n\t\t * description\n\t\t * @returns {String}\n\t\t */\n\t\tprocessText: function(text, options) {\n\t\t\toptions = _.extend({}, defaultOptions, options);\n\t\t\t\n\t\t\tvar buf = require('utils').stringBuilder();\n\t\t\t/** @type StringStream */\n\t\t\tvar stream = require('stringStream').create(text);\n\t\t\tvar ch, m, a;\n\t\t\t\n\t\t\twhile (ch = stream.next()) {\n\t\t\t\tif (ch == '\\\\' && !stream.eol()) {\n\t\t\t\t\t// handle escaped character\n\t\t\t\t\tbuf.append(options.escape(stream.next()));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ta = ch;\n\t\t\t\t\n\t\t\t\tif (ch == '$') {\n\t\t\t\t\t// looks like a tabstop\n\t\t\t\t\tstream.start = stream.pos - 1;\n\t\t\t\t\t\n\t\t\t\t\tif (m = stream.match(/^[0-9]+/)) {\n\t\t\t\t\t\t// it's $N\n\t\t\t\t\t\ta = options.tabstop({\n\t\t\t\t\t\t\tstart: buf.length, \n\t\t\t\t\t\t\tgroup: stream.current().substr(1),\n\t\t\t\t\t\t\ttoken: stream.current()\n\t\t\t\t\t\t});\n\t\t\t\t\t} else if (m = stream.match(/^\\{([a-z_\\-][\\w\\-]*)\\}/)) {\n\t\t\t\t\t\t// ${variable}\n\t\t\t\t\t\ta = options.variable({\n\t\t\t\t\t\t\tstart: buf.length, \n\t\t\t\t\t\t\tname: m[1],\n\t\t\t\t\t\t\ttoken: stream.current()\n\t\t\t\t\t\t});\n\t\t\t\t\t} else if (m = stream.match(/^\\{([0-9]+)(:.+?)?\\}/, false)) {\n\t\t\t\t\t\t// ${N:value} or ${N} placeholder\n\t\t\t\t\t\t// parse placeholder, including nested ones\n\t\t\t\t\t\tstream.skipToPair('{', '}');\n\t\t\t\t\t\t\n\t\t\t\t\t\tvar obj = {\n\t\t\t\t\t\t\tstart: buf.length, \n\t\t\t\t\t\t\tgroup: m[1],\n\t\t\t\t\t\t\ttoken: stream.current()\n\t\t\t\t\t\t};\n\t\t\t\t\t\t\n\t\t\t\t\t\tvar placeholder = obj.token.substring(obj.group.length + 2, obj.token.length - 1);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (placeholder) {\n\t\t\t\t\t\t\tobj.placeholder = placeholder.substr(1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\ta = options.tabstop(obj);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbuf.append(a);\n\t\t\t}\n\t\t\t\n\t\t\treturn buf.toString();\n\t\t},\n\t\t\n\t\t/**\n\t\t * Upgrades tabstops in output node in order to prevent naming conflicts\n\t\t * @param {AbbreviationNode} node\n\t\t * @param {Number} offset Tab index offset\n\t\t * @returns {Number} Maximum tabstop index in element\n\t\t */\n\t\tupgrade: function(node, offset) {\n\t\t\tvar maxNum = 0;\n\t\t\tvar options = {\n\t\t\t\ttabstop: function(data) {\n\t\t\t\t\tvar group = parseInt(data.group);\n\t\t\t\t\tif (group > maxNum) maxNum = group;\n\t\t\t\t\t\t\n\t\t\t\t\tif (data.placeholder)\n\t\t\t\t\t\treturn '${' + (group + offset) + ':' + data.placeholder + '}';\n\t\t\t\t\telse\n\t\t\t\t\t\treturn '${' + (group + offset) + '}';\n\t\t\t\t}\n\t\t\t};\n\t\t\t\n\t\t\t_.each(['start', 'end', 'content'], function(p) {\n\t\t\t\tnode[p] = this.processText(node[p], options);\n\t\t\t}, this);\n\t\t\t\n\t\t\treturn maxNum;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Helper function that produces a callback function for \n\t\t * <code>replaceVariables()</code> method from {@link utils}\n\t\t * module. This callback will replace variable definitions (like \n\t\t * ${var_name}) with their value defined in <i>resource</i> module,\n\t\t * or outputs tabstop with variable name otherwise.\n\t\t * @param {AbbreviationNode} node Context node\n\t\t * @returns {Function}\n\t\t */\n\t\tvariablesResolver: function(node) {\n\t\t\tvar placeholderMemo = {};\n\t\t\tvar res = require('resources');\n\t\t\treturn function(str, varName) {\n\t\t\t\t// do not mark `child` variable as placeholder – it‘s a reserved\n\t\t\t\t// variable name\n\t\t\t\tif (varName == 'child')\n\t\t\t\t\treturn str;\n\t\t\t\t\n\t\t\t\tif (varName == 'cursor')\n\t\t\t\t\treturn require('utils').getCaretPlaceholder();\n\t\t\t\t\n\t\t\t\tvar attr = node.attribute(varName);\n\t\t\t\tif (!_.isUndefined(attr) && attr !== str) {\n\t\t\t\t\treturn attr;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar varValue = res.getVariable(varName);\n\t\t\t\tif (varValue)\n\t\t\t\t\treturn varValue;\n\t\t\t\t\n\t\t\t\t// output as placeholder\n\t\t\t\tif (!placeholderMemo[varName])\n\t\t\t\t\tplaceholderMemo[varName] = startPlaceholderNum++;\n\t\t\t\t\t\n\t\t\t\treturn '${' + placeholderMemo[varName] + ':' + varName + '}';\n\t\t\t};\n\t\t},\n\t\t\n\t\t/**\n\t\t * Resets global tabstop index. When parsed tree is converted to output\n\t\t * string (<code>AbbreviationNode.toString()</code>), all tabstops \n\t\t * defined in snippets and elements are upgraded in order to prevent\n\t\t * naming conflicts of nested. For example, <code>${1}</code> of a node\n\t\t * should not be linked with the same placehilder of the child node.\n\t\t * By default, <code>AbbreviationNode.toString()</code> automatically\n\t\t * upgrades tabstops of the same index for each node and writes maximum\n\t\t * tabstop index into the <code>tabstopIndex</code> variable. To keep\n\t\t * this variable at reasonable value, it is recommended to call \n\t\t * <code>resetTabstopIndex()</code> method each time you expand variable \n\t\t * @returns\n\t\t */\n\t\tresetTabstopIndex: function() {\n\t\t\ttabstopIndex = 0;\n\t\t\tstartPlaceholderNum = 100;\n\t\t}\n\t};\n});/**\n * Common module's preferences storage. This module \n * provides general storage for all module preferences, their description and\n * default values.<br><br>\n * \n * This module can also be used to list all available properties to create \n * UI for updating properties\n * \n * @memberOf __preferencesDefine\n * @constructor\n * @param {Function} require\n * @param {Underscore} _ \n */\nemmet.define('preferences', function(require, _) {\n\tvar preferences = {};\n\tvar defaults = {};\n\tvar _dbgDefaults = null;\n\tvar _dbgPreferences = null;\n\n\tfunction toBoolean(val) {\n\t\tif (_.isString(val)) {\n\t\t\tval = val.toLowerCase();\n\t\t\treturn val == 'yes' || val == 'true' || val == '1';\n\t\t}\n\n\t\treturn !!val;\n\t}\n\t\n\tfunction isValueObj(obj) {\n\t\treturn _.isObject(obj) \n\t\t\t&& 'value' in obj \n\t\t\t&& _.keys(obj).length < 3;\n\t}\n\t\n\treturn {\n\t\t/**\n\t\t * Creates new preference item with default value\n\t\t * @param {String} name Preference name. You can also pass object\n\t\t * with many options\n\t\t * @param {Object} value Preference default value\n\t\t * @param {String} description Item textual description\n\t\t * @memberOf preferences\n\t\t */\n\t\tdefine: function(name, value, description) {\n\t\t\tvar prefs = name;\n\t\t\tif (_.isString(name)) {\n\t\t\t\tprefs = {};\n\t\t\t\tprefs[name] = {\n\t\t\t\t\tvalue: value,\n\t\t\t\t\tdescription: description\n\t\t\t\t};\n\t\t\t}\n\t\t\t\n\t\t\t_.each(prefs, function(v, k) {\n\t\t\t\tdefaults[k] = isValueObj(v) ? v : {value: v};\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Updates preference item value. Preference value should be defined\n\t\t * first with <code>define</code> method.\n\t\t * @param {String} name Preference name. You can also pass object\n\t\t * with many options\n\t\t * @param {Object} value Preference default value\n\t\t * @memberOf preferences\n\t\t */\n\t\tset: function(name, value) {\n\t\t\tvar prefs = name;\n\t\t\tif (_.isString(name)) {\n\t\t\t\tprefs = {};\n\t\t\t\tprefs[name] = value;\n\t\t\t}\n\t\t\t\n\t\t\t_.each(prefs, function(v, k) {\n\t\t\t\tif (!(k in defaults)) {\n\t\t\t\t\tthrow 'Property \"' + k + '\" is not defined. You should define it first with `define` method of current module';\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// do not set value if it equals to default value\n\t\t\t\tif (v !== defaults[k].value) {\n\t\t\t\t\t// make sure we have value of correct type\n\t\t\t\t\tswitch (typeof defaults[k].value) {\n\t\t\t\t\t\tcase 'boolean':\n\t\t\t\t\t\t\tv = toBoolean(v);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'number':\n\t\t\t\t\t\t\tv = parseInt(v + '', 10) || 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault: // convert to string\n\t\t\t\t\t\t\tif (v !== null) {\n\t\t\t\t\t\t\t\tv += '';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tpreferences[k] = v;\n\t\t\t\t} else if  (k in preferences) {\n\t\t\t\t\tdelete preferences[k];\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns preference value\n\t\t * @param {String} name\n\t\t * @returns {String} Returns <code>undefined</code> if preference is \n\t\t * not defined\n\t\t */\n\t\tget: function(name) {\n\t\t\tif (name in preferences)\n\t\t\t\treturn preferences[name];\n\t\t\t\n\t\t\tif (name in defaults)\n\t\t\t\treturn defaults[name].value;\n\t\t\t\n\t\t\treturn void 0;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns comma-separated preference value as array of values\n\t\t * @param {String} name\n\t\t * @returns {Array} Returns <code>undefined</code> if preference is \n\t\t * not defined, <code>null</code> if string cannot be converted to array\n\t\t */\n\t\tgetArray: function(name) {\n\t\t\tvar val = this.get(name);\n\t\t\tif (_.isUndefined(val) || val === null || val === '')  {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tval = _.map(val.split(','), require('utils').trim);\n\t\t\tif (!val.length) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t\n\t\t\treturn val;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns comma and colon-separated preference value as dictionary\n\t\t * @param {String} name\n\t\t * @returns {Object}\n\t\t */\n\t\tgetDict: function(name) {\n\t\t\tvar result = {};\n\t\t\t_.each(this.getArray(name), function(val) {\n\t\t\t\tvar parts = val.split(':');\n\t\t\t\tresult[parts[0]] = parts[1];\n\t\t\t});\n\t\t\t\n\t\t\treturn result;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns description of preference item\n\t\t * @param {String} name Preference name\n\t\t * @returns {Object}\n\t\t */\n\t\tdescription: function(name) {\n\t\t\treturn name in defaults ? defaults[name].description : void 0;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Completely removes specified preference(s)\n\t\t * @param {String} name Preference name (or array of names)\n\t\t */\n\t\tremove: function(name) {\n\t\t\tif (!_.isArray(name))\n\t\t\t\tname = [name];\n\t\t\t\n\t\t\t_.each(name, function(key) {\n\t\t\t\tif (key in preferences)\n\t\t\t\t\tdelete preferences[key];\n\t\t\t\t\n\t\t\t\tif (key in defaults)\n\t\t\t\t\tdelete defaults[key];\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns sorted list of all available properties\n\t\t * @returns {Array}\n\t\t */\n\t\tlist: function() {\n\t\t\treturn _.map(_.keys(defaults).sort(), function(key) {\n\t\t\t\treturn {\n\t\t\t\t\tname: key,\n\t\t\t\t\tvalue: this.get(key),\n\t\t\t\t\ttype: typeof defaults[key].value,\n\t\t\t\t\tdescription: defaults[key].description\n\t\t\t\t};\n\t\t\t}, this);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Loads user-defined preferences from JSON\n\t\t * @param {Object} json\n\t\t * @returns\n\t\t */\n\t\tload: function(json) {\n\t\t\t_.each(json, function(value, key) {\n\t\t\t\tthis.set(key, value);\n\t\t\t}, this);\n\t\t},\n\n\t\t/**\n\t\t * Returns hash of user-modified preferences\n\t\t * @returns {Object}\n\t\t */\n\t\texportModified: function() {\n\t\t\treturn _.clone(preferences);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Reset to defaults\n\t\t * @returns\n\t\t */\n\t\treset: function() {\n\t\t\tpreferences = {};\n\t\t},\n\t\t\n\t\t/**\n\t\t * For unit testing: use empty storage\n\t\t */\n\t\t_startTest: function() {\n\t\t\t_dbgDefaults = defaults;\n\t\t\t_dbgPreferences = preferences;\n\t\t\tdefaults = {};\n\t\t\tpreferences = {};\n\t\t},\n\t\t\n\t\t/**\n\t\t * For unit testing: restore original storage\n\t\t */\n\t\t_stopTest: function() {\n\t\t\tdefaults = _dbgDefaults;\n\t\t\tpreferences = _dbgPreferences;\n\t\t}\n\t};\n});/**\n * Module for handling filters\n * @param {Function} require\n * @param {Underscore} _\n * @author Sergey Chikuyonok (serge.che@gmail.com) <http://chikuyonok.ru>\n */\nemmet.define('filters', function(require, _) {\n\t/** List of registered filters */\n\tvar registeredFilters = {};\n\t\n\t/** Filters that will be applied for unknown syntax */\n\tvar basicFilters = 'html';\n\t\n\tfunction list(filters) {\n\t\tif (!filters)\n\t\t\treturn [];\n\t\t\n\t\tif (_.isString(filters))\n\t\t\treturn filters.split(/[\\|,]/g);\n\t\t\n\t\treturn filters;\n\t}\n\t\n\treturn  {\n\t\t/**\n\t\t * Register new filter\n\t\t * @param {String} name Filter name\n\t\t * @param {Function} fn Filter function\n\t\t */\n\t\tadd: function(name, fn) {\n\t\t\tregisteredFilters[name] = fn;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Apply filters for final output tree\n\t\t * @param {AbbreviationNode} tree Output tree\n\t\t * @param {Array} filters List of filters to apply. Might be a \n\t\t * <code>String</code>\n\t\t * @param {Object} profile Output profile, defined in <i>profile</i> \n\t\t * module. Filters defined it profile are not used, <code>profile</code>\n\t\t * is passed to filter function\n\t\t * @memberOf emmet.filters\n\t\t * @returns {AbbreviationNode}\n\t\t */\n\t\tapply: function(tree, filters, profile) {\n\t\t\tvar utils = require('utils');\n\t\t\tprofile = require('profile').get(profile);\n\t\t\t\n\t\t\t_.each(list(filters), function(filter) {\n\t\t\t\tvar name = utils.trim(filter.toLowerCase());\n\t\t\t\tif (name && name in registeredFilters) {\n\t\t\t\t\ttree = registeredFilters[name](tree, profile);\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\treturn tree;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Composes list of filters that should be applied to a tree, based on \n\t\t * passed data\n\t\t * @param {String} syntax Syntax name ('html', 'css', etc.)\n\t\t * @param {Object} profile Output profile\n\t\t * @param {String} additionalFilters List or pipe-separated\n\t\t * string of additional filters to apply\n\t\t * @returns {Array}\n\t\t */\n\t\tcomposeList: function(syntax, profile, additionalFilters) {\n\t\t\tprofile = require('profile').get(profile);\n\t\t\tvar filters = list(profile.filters || require('resources').findItem(syntax, 'filters') || basicFilters);\n\t\t\t\n\t\t\tif (profile.extraFilters) {\n\t\t\t\tfilters = filters.concat(list(profile.extraFilters));\n\t\t\t}\n\t\t\t\t\n\t\t\tif (additionalFilters) {\n\t\t\t\tfilters = filters.concat(list(additionalFilters));\n\t\t\t}\n\t\t\t\t\n\t\t\tif (!filters || !filters.length) {\n\t\t\t\t// looks like unknown syntax, apply basic filters\n\t\t\t\tfilters = list(basicFilters);\n\t\t\t}\n\t\t\t\t\n\t\t\treturn filters;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Extracts filter list from abbreviation\n\t\t * @param {String} abbr\n\t\t * @returns {Array} Array with cleaned abbreviation and list of \n\t\t * extracted filters\n\t\t */\n\t\textractFromAbbreviation: function(abbr) {\n\t\t\tvar filters = '';\n\t\t\tabbr = abbr.replace(/\\|([\\w\\|\\-]+)$/, function(str, p1){\n\t\t\t\tfilters = p1;\n\t\t\t\treturn '';\n\t\t\t});\n\t\t\t\n\t\t\treturn [abbr, list(filters)];\n\t\t}\n\t};\n});/**\n * Module that contains factories for element types used by Emmet\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.define('elements', function(require, _) {\n\tvar factories = {};\n\tvar reAttrs = /([\\w\\-:]+)\\s*=\\s*(['\"])(.*?)\\2/g;\n\t\n\tvar result = {\n\t\t/**\n\t\t * Create new element factory\n\t\t * @param {String} name Element identifier\n\t\t * @param {Function} factory Function that produces element of specified \n\t\t * type. The object generated by this factory is automatically \n\t\t * augmented with <code>type</code> property pointing to element\n\t\t * <code>name</code>\n\t\t * @memberOf elements\n\t\t */\n\t\tadd: function(name, factory) {\n\t\t\tvar that = this;\n\t\t\tfactories[name] = function() {\n\t\t\t\tvar elem = factory.apply(that, arguments);\n\t\t\t\tif (elem)\n\t\t\t\t\telem.type = name;\n\t\t\t\t\n\t\t\t\treturn elem;\n\t\t\t};\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns factory for specified name\n\t\t * @param {String} name\n\t\t * @returns {Function}\n\t\t */\n\t\tget: function(name) {\n\t\t\treturn factories[name];\n\t\t},\n\t\t\n\t\t/**\n\t\t * Creates new element with specified type\n\t\t * @param {String} name\n\t\t * @returns {Object}\n\t\t */\n\t\tcreate: function(name) {\n\t\t\tvar args = [].slice.call(arguments, 1);\n\t\t\tvar factory = this.get(name);\n\t\t\treturn factory ? factory.apply(this, args) : null;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if passed element is of specified type\n\t\t * @param {Object} elem\n\t\t * @param {String} type\n\t\t * @returns {Boolean}\n\t\t */\n\t\tis: function(elem, type) {\n\t\t\treturn elem && elem.type === type;\n\t\t}\n\t};\n\t\n\t// register resource references\n\tfunction commonFactory(value) {\n\t\treturn {data: value};\n\t}\n\t\n\t/**\n\t * Element factory\n\t * @param {String} elementName Name of output element\n\t * @param {String} attrs Attributes definition. You may also pass\n\t * <code>Array</code> where each contains object with <code>name</code> \n\t * and <code>value</code> properties, or <code>Object</code>\n\t * @param {Boolean} isEmpty Is expanded element should be empty\n\t */\n\tresult.add('element', function(elementName, attrs, isEmpty) {\n\t\tvar ret = {\n\t\t\t/** @memberOf __emmetDataElement */\n\t\t\tname: elementName,\n\t\t\tis_empty: !!isEmpty\n\t\t};\n\t\t\n\t\tif (attrs) {\n\t\t\tret.attributes = [];\n\t\t\tif (_.isArray(attrs)) {\n\t\t\t\tret.attributes = attrs;\n\t\t\t} else if (_.isString(attrs)) {\n\t\t\t\tvar m;\n\t\t\t\twhile (m = reAttrs.exec(attrs)) {\n\t\t\t\t\tret.attributes.push({\n\t\t\t\t\t\tname: m[1],\n\t\t\t\t\t\tvalue: m[3]\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t_.each(attrs, function(value, name) {\n\t\t\t\t\tret.attributes.push({\n\t\t\t\t\t\tname: name, \n\t\t\t\t\t\tvalue: value\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn ret;\n\t});\n\t\n\tresult.add('snippet', commonFactory);\n\tresult.add('reference', commonFactory);\n\tresult.add('empty', function() {\n\t\treturn {};\n\t});\n\t\n\treturn result;\n});/**\n * Abstract implementation of edit tree interface.\n * Edit tree is a named container of editable “name-value” child elements, \n * parsed from <code>source</code>. This container provides convenient methods\n * for editing/adding/removing child elements. All these update actions are\n * instantly reflected in the <code>source</code> code with respect of formatting.\n * <br><br>\n * For example, developer can create an edit tree from CSS rule and add or \n * remove properties from it–all changes will be immediately reflected in the \n * original source.\n * <br><br>\n * All classes defined in this module should be extended the same way as in\n * Backbone framework: using <code>extend</code> method to create new class and \n * <code>initialize</code> method to define custom class constructor.\n * \n * @example\n * <pre><code>\n * var MyClass = require('editTree').EditElement.extend({\n * \tinitialize: function() {\n * \t\t// constructor code here\n * \t}\n * });\n * \n * var elem = new MyClass(); \n * </code></pre>\n * \n * \n * @param {Function} require\n * @param {Underscore} _\n * @constructor\n * @memberOf __editTreeDefine\n */\nemmet.define('editTree', function(require, _, core) {\n\tvar range = require('range').create;\n\t\n\t/**\n\t * Named container of edited source\n\t * @type EditContainer\n\t * @param {String} source\n\t * @param {Object} options\n\t */\n\tfunction EditContainer(source, options) {\n\t\tthis.options = _.extend({offset: 0}, options);\n\t\t/**\n\t\t * Source code of edited structure. All changes in the structure are \n\t\t * immediately reflected into this property\n\t\t */\n\t\tthis.source = source;\n\t\t\n\t\t/** \n\t\t * List of all editable children\n\t\t * @private \n\t\t */\n\t\tthis._children = [];\n\t\t\n\t\t/**\n\t\t * Hash of all positions of container\n\t\t * @private\n\t\t */\n\t\tthis._positions = {\n\t\t\tname: 0\n\t\t};\n\t\t\n\t\tthis.initialize.apply(this, arguments);\n\t}\n\t\n\t/**\n\t * The self-propagating extend function for classes.\n\t * @type Function\n\t */\n\tEditContainer.extend = core.extend;\n\t\n\tEditContainer.prototype = {\n\t\t/**\n\t\t * Child class constructor\n\t\t */\n\t\tinitialize: function() {},\n\t\t\n\t\t/**\n\t\t * Replace substring of tag's source\n\t\t * @param {String} value\n\t\t * @param {Number} start\n\t\t * @param {Number} end\n\t\t * @private\n\t\t */\n\t\t_updateSource: function(value, start, end) {\n\t\t\t// create modification range\n\t\t\tvar r = range(start, _.isUndefined(end) ? 0 : end - start);\n\t\t\tvar delta = value.length - r.length();\n\t\t\t\n\t\t\tvar update = function(obj) {\n\t\t\t\t_.each(obj, function(v, k) {\n\t\t\t\t\tif (v >= r.end)\n\t\t\t\t\t\tobj[k] += delta;\n\t\t\t\t});\n\t\t\t};\n\t\t\t\n\t\t\t// update affected positions of current container\n\t\t\tupdate(this._positions);\n\t\t\t\n\t\t\t// update affected positions of children\n\t\t\t_.each(this.list(), function(item) {\n\t\t\t\tupdate(item._positions);\n\t\t\t});\n\t\t\t\n\t\t\tthis.source = require('utils').replaceSubstring(this.source, value, r);\n\t\t},\n\t\t\t\n\t\t\t\n\t\t/**\n\t\t * Adds new attribute \n\t\t * @param {String} name Property name\n\t\t * @param {String} value Property value\n\t\t * @param {Number} pos Position at which to insert new property. By \n\t\t * default the property is inserted at the end of rule \n\t\t * @returns {EditElement} Newly created element\n\t\t */\n\t\tadd: function(name, value, pos) {\n\t\t\t// this is abstract implementation\n\t\t\tvar item = new EditElement(name, value);\n\t\t\tthis._children.push(item);\n\t\t\treturn item;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns attribute object\n\t\t * @param {String} name Attribute name or its index\n\t\t * @returns {EditElement}\n\t\t */\n\t\tget: function(name) {\n\t\t\tif (_.isNumber(name))\n\t\t\t\treturn this.list()[name];\n\t\t\t\n\t\t\tif (_.isString(name))\n\t\t\t\treturn _.find(this.list(), function(prop) {\n\t\t\t\t\treturn prop.name() === name;\n\t\t\t\t});\n\t\t\t\n\t\t\treturn name;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns all children by name or indexes\n\t\t * @param {Object} name Element name(s) or indexes (<code>String</code>,\n\t\t * <code>Array</code>, <code>Number</code>)\n\t\t * @returns {Array}\n\t\t */\n\t\tgetAll: function(name) {\n\t\t\tif (!_.isArray(name))\n\t\t\t\tname = [name];\n\t\t\t\n\t\t\t// split names and indexes\n\t\t\tvar names = [], indexes = [];\n\t\t\t_.each(name, function(item) {\n\t\t\t\tif (_.isString(item))\n\t\t\t\t\tnames.push(item);\n\t\t\t\telse if (_.isNumber(item))\n\t\t\t\t\tindexes.push(item);\n\t\t\t});\n\t\t\t\n\t\t\treturn _.filter(this.list(), function(attribute, i) {\n\t\t\t\treturn _.include(indexes, i) || _.include(names, attribute.name());\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns or updates element value. If such element doesn't exists,\n\t\t * it will be created automatically and added at the end of child list.\n\t\t * @param {String} name Element name or its index\n\t\t * @param {String} value New element value\n\t\t * @returns {String}\n\t\t */\n\t\tvalue: function(name, value, pos) {\n\t\t\tvar element = this.get(name);\n\t\t\tif (element)\n\t\t\t\treturn element.value(value);\n\t\t\t\n\t\t\tif (!_.isUndefined(value)) {\n\t\t\t\t// no such element — create it\n\t\t\t\treturn this.add(name, value, pos);\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns all values of child elements found by <code>getAll()</code>\n\t\t * method\n\t\t * @param {Object} name Element name(s) or indexes (<code>String</code>,\n\t\t * <code>Array</code>, <code>Number</code>)\n\t\t * @returns {Array}\n\t\t */\n\t\tvalues: function(name) {\n\t\t\treturn _.map(this.getAll(name), function(element) {\n\t\t\t\treturn element.value();\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Remove child element\n\t\t * @param {String} name Property name or its index\n\t\t */\n\t\tremove: function(name) {\n\t\t\tvar element = this.get(name);\n\t\t\tif (element) {\n\t\t\t\tthis._updateSource('', element.fullRange());\n\t\t\t\tthis._children = _.without(this._children, element);\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns list of all editable child elements\n\t\t * @returns {Array}\n\t\t */\n\t\tlist: function() {\n\t\t\treturn this._children;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns index of editble child in list\n\t\t * @param {Object} item\n\t\t * @returns {Number}\n\t\t */\n\t\tindexOf: function(item) {\n\t\t\treturn _.indexOf(this.list(), this.get(item));\n\t\t},\n\t\t\n\t\t/**\n\t\t * Sets or gets container name\n\t\t * @param {String} val New name. If not passed, current \n\t\t * name is returned\n\t\t * @return {String}\n\t\t */\n\t\tname: function(val) {\n\t\t\tif (!_.isUndefined(val) && this._name !== (val = String(val))) {\n\t\t\t\tthis._updateSource(val, this._positions.name, this._positions.name + this._name.length);\n\t\t\t\tthis._name = val;\n\t\t\t}\n\t\t\t\n\t\t\treturn this._name;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns name range object\n\t\t * @param {Boolean} isAbsolute Return absolute range (with respect of \n\t\t * rule offset)\n\t\t * @returns {Range}\n\t\t */\n\t\tnameRange: function(isAbsolute) {\n\t\t\treturn range(this._positions.name + (isAbsolute ? this.options.offset : 0), this.name());\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns range of current source\n\t\t * @param {Boolean} isAbsolute\n\t\t */\n\t\trange: function(isAbsolute) {\n\t\t\treturn range(isAbsolute ? this.options.offset : 0, this.toString());\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns element that belongs to specified position\n\t\t * @param {Number} pos\n\t\t * @param {Boolean} isAbsolute\n\t\t * @returns {EditElement}\n\t\t */\n\t\titemFromPosition: function(pos, isAbsolute) {\n\t\t\treturn _.find(this.list(), function(elem) {\n\t\t\t\treturn elem.range(isAbsolute).inside(pos);\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns source code of current container \n\t\t * @returns {String}\n\t\t */\n\t\ttoString: function() {\n\t\t\treturn this.source;\n\t\t}\n\t};\n\t\n\t/**\n\t * @param {EditContainer} parent\n\t * @param {Object} nameToken\n\t * @param {Object} valueToken\n\t */\n\tfunction EditElement(parent, nameToken, valueToken) {\n\t\t/** @type EditContainer */\n\t\tthis.parent = parent;\n\t\t\n\t\tthis._name = nameToken.value;\n\t\tthis._value = valueToken ? valueToken.value : '';\n\t\t\n\t\tthis._positions = {\n\t\t\tname: nameToken.start,\n\t\t\tvalue: valueToken ? valueToken.start : -1\n\t\t};\n\t\t\n\t\tthis.initialize.apply(this, arguments);\n\t}\n\t\n\t/**\n\t * The self-propagating extend function for classes.\n\t * @type Function\n\t */\n\tEditElement.extend = core.extend;\n\t\n\tEditElement.prototype = {\n\t\t/**\n\t\t * Child class constructor\n\t\t */\n\t\tinitialize: function() {},\n\t\t\n\t\t/**\n\t\t * Make position absolute\n\t\t * @private\n\t\t * @param {Number} num\n\t\t * @param {Boolean} isAbsolute\n\t\t * @returns {Boolean}\n\t\t */\n\t\t_pos: function(num, isAbsolute) {\n\t\t\treturn num + (isAbsolute ? this.parent.options.offset : 0);\n\t\t},\n\t\t\t\n\t\t/**\n\t\t * Sets of gets element value\n\t\t * @param {String} val New element value. If not passed, current \n\t\t * value is returned\n\t\t * @returns {String}\n\t\t */\n\t\tvalue: function(val) {\n\t\t\tif (!_.isUndefined(val) && this._value !== (val = String(val))) {\n\t\t\t\tthis.parent._updateSource(val, this.valueRange());\n\t\t\t\tthis._value = val;\n\t\t\t}\n\t\t\t\n\t\t\treturn this._value;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Sets of gets element name\n\t\t * @param {String} val New element name. If not passed, current \n\t\t * name is returned\n\t\t * @returns {String}\n\t\t */\n\t\tname: function(val) {\n\t\t\tif (!_.isUndefined(val) && this._name !== (val = String(val))) {\n\t\t\t\tthis.parent._updateSource(val, this.nameRange());\n\t\t\t\tthis._name = val;\n\t\t\t}\n\t\t\t\n\t\t\treturn this._name;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns position of element name token\n\t\t * @param {Boolean} isAbsolute Return absolute position\n\t\t * @returns {Number}\n\t\t */\n\t\tnamePosition: function(isAbsolute) {\n\t\t\treturn this._pos(this._positions.name, isAbsolute);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns position of element value token\n\t\t * @param {Boolean} isAbsolute Return absolute position\n\t\t * @returns {Number}\n\t\t */\n\t\tvaluePosition: function(isAbsolute) {\n\t\t\treturn this._pos(this._positions.value, isAbsolute);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns element name\n\t\t * @param {Boolean} isAbsolute Return absolute range \n\t\t * @returns {Range}\n\t\t */\n\t\trange: function(isAbsolute) {\n\t\t\treturn range(this.namePosition(isAbsolute), this.toString());\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns full element range, including possible indentation\n\t\t * @param {Boolean} isAbsolute Return absolute range\n\t\t * @returns {Range}\n\t\t */\n\t\tfullRange: function(isAbsolute) {\n\t\t\treturn this.range(isAbsolute);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns element name range\n\t\t * @param {Boolean} isAbsolute Return absolute range\n\t\t * @returns {Range}\n\t\t */\n\t\tnameRange: function(isAbsolute) {\n\t\t\treturn range(this.namePosition(isAbsolute), this.name());\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns element value range\n\t\t * @param {Boolean} isAbsolute Return absolute range\n\t\t * @returns {Range}\n\t\t */\n\t\tvalueRange: function(isAbsolute) {\n\t\t\treturn range(this.valuePosition(isAbsolute), this.value());\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns current element string representation\n\t\t * @returns {String}\n\t\t */\n\t\ttoString: function() {\n\t\t\treturn this.name() + this.value();\n\t\t},\n\t\t\n\t\tvalueOf: function() {\n\t\t\treturn this.toString();\n\t\t}\n\t};\n\t\n\treturn {\n\t\tEditContainer: EditContainer,\n\t\tEditElement: EditElement,\n\t\t\n\t\t/**\n\t\t * Creates token that can be fed to <code>EditElement</code>\n\t\t * @param {Number} start\n\t\t * @param {String} value\n\t\t * @param {String} type\n\t\t * @returns\n\t\t */\n\t\tcreateToken: function(start, value, type) {\n\t\t\tvar obj = {\n\t\t\t\tstart: start || 0,\n\t\t\t\tvalue: value || '',\n\t\t\t\ttype: type\n\t\t\t};\n\t\t\t\n\t\t\tobj.end = obj.start + obj.value.length;\n\t\t\treturn obj;\n\t\t}\n\t};\n});/**\n * CSS EditTree is a module that can parse a CSS rule into a tree with \n * convenient methods for adding, modifying and removing CSS properties. These \n * changes can be written back to string with respect of code formatting.\n * \n * @memberOf __cssEditTreeDefine\n * @constructor\n * @param {Function} require\n * @param {Underscore} _ \n */\nemmet.define('cssEditTree', function(require, _) {\n\tvar defaultOptions = {\n\t\tstyleBefore: '\\n\\t',\n\t\tstyleSeparator: ': ',\n\t\toffset: 0\n\t};\n\t\n\tvar WHITESPACE_REMOVE_FROM_START = 1;\n\tvar WHITESPACE_REMOVE_FROM_END   = 2;\n\t\n\t/**\n\t * Returns range object\n\t * @param {Number} start\n\t * @param {Number} len \n\t * @returns {Range}\n\t */\n\tfunction range(start, len) {\n\t\treturn require('range').create(start, len);\n\t}\n\t\n\t/**\n\t * Removes whitespace tokens from the array ends\n\t * @param {Array} tokens\n\t * @param {Number} mask Mask indicating from which end whitespace should be \n\t * removed \n\t * @returns {Array}\n\t */\n\tfunction trimWhitespaceTokens(tokens, mask) {\n\t\tmask = mask || (WHITESPACE_REMOVE_FROM_START | WHITESPACE_REMOVE_FROM_END);\n\t\tvar whitespace = ['white', 'line'];\n\t\t\n\t\tif ((mask & WHITESPACE_REMOVE_FROM_END) == WHITESPACE_REMOVE_FROM_END)\n\t\t\twhile (tokens.length && _.include(whitespace, _.last(tokens).type)) {\n\t\t\t\ttokens.pop();\n\t \t\t}\n\t\t\n\t\tif ((mask & WHITESPACE_REMOVE_FROM_START) == WHITESPACE_REMOVE_FROM_START)\n\t\t\twhile (tokens.length && _.include(whitespace, tokens[0].type)) {\n\t\t\t\ttokens.shift();\n\t\t\t}\n\t\t\n\t\treturn tokens;\n\t}\n\t\n\t/**\n\t * Helper function that searches for selector range for <code>CSSEditRule</code>\n\t * @param {TokenIterator} it\n\t * @returns {Range}\n\t */\n\tfunction findSelectorRange(it) {\n\t\tvar tokens = [], token;\n \t\tvar start = it.position(), end;\n \t\t\n \t\twhile (token = it.next()) {\n\t\t\tif (token.type == '{')\n\t\t\t\tbreak;\n\t\t\ttokens.push(token);\n\t\t}\n \t\t\n \t\ttrimWhitespaceTokens(tokens);\n \t\t\n \t\tif (tokens.length) {\n \t\t\tstart = tokens[0].start;\n \t\t\tend = _.last(tokens).end;\n \t\t} else {\n \t\t\tend = start;\n \t\t}\n \t\t\n \t\treturn range(start, end - start);\n\t}\n\t\n\t/**\n\t * Helper function that searches for CSS property value range next to\n\t * iterator's current position  \n\t * @param {TokenIterator} it\n\t * @returns {Range}\n\t */\n\tfunction findValueRange(it) {\n\t\t// find value start position\n\t\tvar skipTokens = ['white', 'line', ':'];\n\t\tvar tokens = [], token, start, end;\n\t\t\n\t\tit.nextUntil(function(tok) {\n\t\t\treturn !_.include(skipTokens, this.itemNext().type);\n\t\t});\n\t\t\n\t\tstart = it.current().end;\n\t\t// consume value\n\t\twhile (token = it.next()) {\n\t\t\tif (token.type == '}' || token.type == ';') {\n\t\t\t\t// found value end\n\t\t\t\ttrimWhitespaceTokens(tokens, WHITESPACE_REMOVE_FROM_START \n\t\t\t\t\t\t| (token.type == '}' ? WHITESPACE_REMOVE_FROM_END : 0));\n\t\t\t\t\n\t\t\t\tif (tokens.length) {\n\t\t\t\t\tstart = tokens[0].start;\n\t\t\t\t\tend = _.last(tokens).end;\n\t\t\t\t} else {\n\t\t\t\t\tend = start;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn range(start, end - start);\n\t\t\t}\n\t\t\t\n\t\t\ttokens.push(token);\n\t\t}\n\t\t\n\t\t// reached the end of tokens list\n\t\tif (tokens.length) {\n\t\t\treturn range(tokens[0].start, _.last(tokens).end - tokens[0].start);\n\t\t}\n\t}\n\t\n\t/**\n\t * Finds parts of complex CSS value\n\t * @param {String} str\n\t * @returns {Array} Returns list of <code>Range</code>'s\n\t */\n\tfunction findParts(str) {\n\t\t/** @type StringStream */\n\t\tvar stream = require('stringStream').create(str);\n\t\tvar ch;\n\t\tvar result = [];\n\t\tvar sep = /[\\s\\u00a0,]/;\n\t\t\n\t\tvar add = function() {\n\t\t\tstream.next();\n\t\t\tresult.push(range(stream.start, stream.current()));\n\t\t\tstream.start = stream.pos;\n\t\t};\n\t\t\n\t\t// skip whitespace\n\t\tstream.eatSpace();\n\t\tstream.start = stream.pos;\n\t\t\n\t\twhile (ch = stream.next()) {\n\t\t\tif (ch == '\"' || ch == \"'\") {\n\t\t\t\tstream.next();\n\t\t\t\tif (!stream.skipTo(ch)) break;\n\t\t\t\tadd();\n\t\t\t} else if (ch == '(') {\n\t\t\t\t// function found, may have nested function\n\t\t\t\tstream.backUp(1);\n\t\t\t\tif (!stream.skipToPair('(', ')')) break;\n\t\t\t\tstream.backUp(1);\n\t\t\t\tadd();\n\t\t\t} else {\n\t\t\t\tif (sep.test(ch)) {\n\t\t\t\t\tresult.push(range(stream.start, stream.current().length - 1));\n\t\t\t\t\tstream.eatWhile(sep);\n\t\t\t\t\tstream.start = stream.pos;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tadd();\n\t\t\n\t\treturn _.chain(result)\n\t\t\t.filter(function(item) {\n\t\t\t\treturn !!item.length();\n\t\t\t})\n\t\t\t.uniq(false, function(item) {\n\t\t\t\treturn item.toString();\n\t\t\t})\n\t\t\t.value();\n\t}\n\t\n\t/**\n\t * A bit hacky way to identify invalid CSS property definition: when user\n\t * starts writing new abbreviation in CSS rule, he actually creates invalid\n\t * CSS property definition and this method tries to identify such abbreviation\n\t * and prevent it from being added to CSS edit tree \n\t * @param {TokenIterator} it\n\t */\n\tfunction isValidIdentifier(it) {\n//\t\treturn true;\n\t\tvar tokens = it.tokens;\n\t\tfor (var i = it._i + 1, il = tokens.length; i < il; i++) {\n\t\t\tif (tokens[i].type == ':')\n\t\t\t\treturn true;\n\t\t\t\n\t\t\tif (tokens[i].type == 'identifier' || tokens[i].type == 'line')\n\t\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * @class\n\t * @extends EditContainer\n\t */\n\tvar CSSEditContainer = require('editTree').EditContainer.extend({\n\t\tinitialize: function(source, options) {\n\t\t\t_.defaults(this.options, defaultOptions);\n\t\t\tvar editTree = require('editTree');\n\t\t\t\n\t\t\t/** @type TokenIterator */\n\t \t\tvar it = require('tokenIterator').create(\n\t \t\t\t\trequire('cssParser').parse(source));\n\t \t\t\n\t \t\tvar selectorRange = findSelectorRange(it);\n\t \t\tthis._positions.name = selectorRange.start;\n\t \t\tthis._name = selectorRange.substring(source);\n\t \t\t\n\t \t\tif (!it.current() || it.current().type != '{')\n\t \t\t\tthrow 'Invalid CSS rule';\n\t \t\t\n\t \t\tthis._positions.contentStart = it.position() + 1;\n\t \t\t\n\t \t\t// consume properties\n\t \t\tvar propertyRange, valueRange, token;\n\t\t\twhile (token = it.next()) {\n\t\t\t\tif (token.type == 'identifier' && isValidIdentifier(it)) {\n\t\t\t\t\tpropertyRange = range(token);\n\t\t\t\t\tvalueRange = findValueRange(it);\n\t\t\t\t\tvar end = (it.current() && it.current().type == ';') \n\t\t\t\t\t\t? range(it.current())\n\t\t\t\t\t\t: range(valueRange.end, 0);\n\t\t\t\t\tthis._children.push(new CSSEditElement(this,\n\t\t\t\t\t\t\teditTree.createToken(propertyRange.start, propertyRange.substring(source)),\n\t\t\t\t\t\t\teditTree.createToken(valueRange.start, valueRange.substring(source)),\n\t\t\t\t\t\t\teditTree.createToken(end.start, end.substring(source))\n\t\t\t\t\t\t\t));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tthis._saveStyle();\n\t\t},\n\t\t\n\t\t/**\n\t\t * Remembers all styles of properties\n\t\t * @private\n\t\t */\n\t\t_saveStyle: function() {\n\t\t\tvar start = this._positions.contentStart;\n\t\t\tvar source = this.source;\n\t\t\tvar utils = require('utils');\n\t\t\t\n\t\t\t_.each(this.list(), /** @param {CSSEditProperty} p */ function(p) {\n\t\t\t\tp.styleBefore = source.substring(start, p.namePosition());\n\t\t\t\t// a small hack here:\n\t\t\t\t// Sometimes users add empty lines before properties to logically\n\t\t\t\t// separate groups of properties. In this case, a blind copy of\n\t\t\t\t// characters between rules may lead to undesired behavior,\n\t\t\t\t// especially when current rule is duplicated or used as a donor\n\t\t\t\t// to create new rule.\n\t\t\t\t// To solve this issue, we‘ll take only last newline indentation\n\t\t\t\tvar lines = utils.splitByLines(p.styleBefore);\n\t\t\t\tif (lines.length > 1) {\n\t\t\t\t\tp.styleBefore = '\\n' + _.last(lines);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tp.styleSeparator = source.substring(p.nameRange().end, p.valuePosition());\n\t\t\t\t\n\t\t\t\t// graceful and naive comments removal \n\t\t\t\tp.styleBefore = _.last(p.styleBefore.split('*/'));\n\t\t\t\tp.styleSeparator = p.styleSeparator.replace(/\\/\\*.*?\\*\\//g, '');\n\t\t\t\t\n\t\t\t\tstart = p.range().end;\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Adds new CSS property \n\t\t * @param {String} name Property name\n\t\t * @param {String} value Property value\n\t\t * @param {Number} pos Position at which to insert new property. By \n\t\t * default the property is inserted at the end of rule \n\t\t * @returns {CSSEditProperty}\n\t\t */\n\t\tadd: function(name, value, pos) {\n\t\t\tvar list = this.list();\n\t\t\tvar start = this._positions.contentStart;\n\t\t\tvar styles = _.pick(this.options, 'styleBefore', 'styleSeparator');\n\t\t\tvar editTree = require('editTree');\n\t\t\t\n\t\t\tif (_.isUndefined(pos))\n\t\t\t\tpos = list.length;\n\t\t\t\n\t\t\t/** @type CSSEditProperty */\n\t\t\tvar donor = list[pos];\n\t\t\tif (donor) {\n\t\t\t\tstart = donor.fullRange().start;\n\t\t\t} else if (donor = list[pos - 1]) {\n\t\t\t\t// make sure that donor has terminating semicolon\n\t\t\t\tdonor.end(';');\n\t\t\t\tstart = donor.range().end;\n\t\t\t}\n\t\t\t\n\t\t\tif (donor) {\n\t\t\t\tstyles = _.pick(donor, 'styleBefore', 'styleSeparator');\n\t\t\t}\n\t\t\t\n\t\t\tvar nameToken = editTree.createToken(start + styles.styleBefore.length, name);\n\t\t\tvar valueToken = editTree.createToken(nameToken.end + styles.styleSeparator.length, value);\n\t\t\t\n\t\t\tvar property = new CSSEditElement(this, nameToken, valueToken,\n\t\t\t\t\teditTree.createToken(valueToken.end, ';'));\n\t\t\t\n\t\t\t_.extend(property, styles);\n\t\t\t\n\t\t\t// write new property into the source\n\t\t\tthis._updateSource(property.styleBefore + property.toString(), start);\n\t\t\t\n\t\t\t// insert new property\n\t\t\tthis._children.splice(pos, 0, property);\n\t\t\treturn property;\n\t\t}\n\t});\n\t\n\t/**\n\t * @class\n\t * @type CSSEditElement\n\t * @constructor\n\t */\n\tvar CSSEditElement = require('editTree').EditElement.extend({\n\t\tinitialize: function(rule, name, value, end) {\n\t\t\tthis.styleBefore = rule.options.styleBefore;\n\t\t\tthis.styleSeparator = rule.options.styleSeparator;\n\t\t\t\n\t\t\tthis._end = end.value;\n\t\t\tthis._positions.end = end.start;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns ranges of complex value parts\n\t\t * @returns {Array} Returns <code>null</code> if value is not complex\n\t\t */\n\t\tvalueParts: function(isAbsolute) {\n\t\t\tvar parts = findParts(this.value());\n\t\t\tif (isAbsolute) {\n\t\t\t\tvar offset = this.valuePosition(true);\n\t\t\t\t_.each(parts, function(p) {\n\t\t\t\t\tp.shift(offset);\n\t\t\t\t});\n\t\t\t}\n\t\t\t\n\t\t\treturn parts;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Sets of gets property end value (basically, it's a semicolon)\n\t\t * @param {String} val New end value. If not passed, current \n\t\t * value is returned\n\t\t */\n\t\tend: function(val) {\n\t\t\tif (!_.isUndefined(val) && this._end !== val) {\n\t\t\t\tthis.parent._updateSource(val, this._positions.end, this._positions.end + this._end.length);\n\t\t\t\tthis._end = val;\n\t\t\t}\n\t\t\t\n\t\t\treturn this._end;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns full rule range, with indentation\n\t\t * @param {Boolean} isAbsolute Return absolute range (with respect of\n\t\t * rule offset)\n\t\t * @returns {Range}\n\t\t */\n\t\tfullRange: function(isAbsolute) {\n\t\t\tvar r = this.range(isAbsolute);\n\t\t\tr.start -= this.styleBefore.length;\n\t\t\treturn r;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns item string representation\n\t\t * @returns {String}\n\t\t */\n\t\ttoString: function() {\n\t\t\treturn this.name() + this.styleSeparator + this.value() + this.end();\n\t\t}\n\t});\n\t\n\treturn {\n\t\t/**\n\t\t * Parses CSS rule into editable tree\n\t\t * @param {String} source\n\t\t * @param {Object} options\n\t\t * @memberOf emmet.cssEditTree\n\t\t * @returns {EditContainer}\n\t\t */\n\t\tparse: function(source, options) {\n\t\t\treturn new CSSEditContainer(source, options);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Extract and parse CSS rule from specified position in <code>content</code> \n\t\t * @param {String} content CSS source code\n\t\t * @param {Number} pos Character position where to start source code extraction\n\t\t * @returns {EditContainer}\n\t\t */\n\t\tparseFromPosition: function(content, pos, isBackward) {\n\t\t\tvar bounds = this.extractRule(content, pos, isBackward);\n\t\t\tif (!bounds || !bounds.inside(pos))\n\t\t\t\t// no matching CSS rule or caret outside rule bounds\n\t\t\t\treturn null;\n\t\t\t\n\t\t\treturn this.parse(bounds.substring(content), {\n\t\t\t\toffset: bounds.start\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Extracts single CSS selector definition from source code\n\t\t * @param {String} content CSS source code\n\t\t * @param {Number} pos Character position where to start source code extraction\n\t\t * @returns {Range}\n\t\t */\n\t\textractRule: function(content, pos, isBackward) {\n\t\t\tvar result = '';\n\t\t\tvar len = content.length;\n\t\t\tvar offset = pos;\n\t\t\tvar stopChars = '{}/\\\\<>\\n\\r';\n\t\t\tvar bracePos = -1, ch;\n\t\t\t\n\t\t\t// search left until we find rule edge\n\t\t\twhile (offset >= 0) {\n\t\t\t\tch = content.charAt(offset);\n\t\t\t\tif (ch == '{') {\n\t\t\t\t\tbracePos = offset;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (ch == '}' && !isBackward) {\n\t\t\t\t\toffset++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\toffset--;\n\t\t\t}\n\t\t\t\n\t\t\t// search right for full rule set\n\t\t\twhile (offset < len) {\n\t\t\t\tch = content.charAt(offset);\n\t\t\t\tif (ch == '{') {\n\t\t\t\t\tbracePos = offset;\n\t\t\t\t} else if (ch == '}') {\n\t\t\t\t\tif (bracePos != -1)\n\t\t\t\t\t\tresult = content.substring(bracePos, offset + 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\toffset++;\n\t\t\t}\n\t\t\t\n\t\t\tif (result) {\n\t\t\t\t// find CSS selector\n\t\t\t\toffset = bracePos - 1;\n\t\t\t\tvar selector = '';\n\t\t\t\twhile (offset >= 0) {\n\t\t\t\t\tch = content.charAt(offset);\n\t\t\t\t\tif (stopChars.indexOf(ch) != -1) break;\n\t\t\t\t\toffset--;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// also trim whitespace\n\t\t\t\tselector = content.substring(offset + 1, bracePos).replace(/^[\\s\\n\\r]+/m, '');\n\t\t\t\treturn require('range').create(bracePos - selector.length, result.length + selector.length);\n\t\t\t}\n\t\t\t\n\t\t\treturn null;\n\t\t},\n\t\t\n\t\t/**\n\t \t * Removes vendor prefix from CSS property\n\t \t * @param {String} name CSS property\n\t \t * @return {String}\n\t \t */\n\t \tbaseName: function(name) {\n\t \t\treturn name.replace(/^\\s*\\-\\w+\\-/, '');\n\t \t},\n\t \t\n\t \t/**\n\t \t * Finds parts of complex CSS value\n\t \t * @param {String} str\n\t \t * @returns {Array}\n\t \t */\n\t \tfindParts: findParts\n\t};\n});/**\n * XML EditTree is a module that can parse an XML/HTML element into a tree with \n * convenient methods for adding, modifying and removing attributes. These \n * changes can be written back to string with respect of code formatting.\n * \n * @memberOf __xmlEditTreeDefine\n * @constructor\n * @param {Function} require\n * @param {Underscore} _ \n */\nemmet.define('xmlEditTree', function(require, _) {\n\tvar defaultOptions = {\n\t\tstyleBefore: ' ',\n\t\tstyleSeparator: '=',\n\t\tstyleQuote: '\"',\n\t\toffset: 0\n\t};\n\t\n\tvar startTag = /^<([\\w\\:\\-]+)((?:\\s+[\\w\\-:]+(?:\\s*=\\s*(?:(?:\"[^\"]*\")|(?:'[^']*')|[^>\\s]+))?)*)\\s*(\\/?)>/m;\n\t\n\tvar XMLEditContainer = require('editTree').EditContainer.extend({\n\t\tinitialize: function(source, options) {\n\t\t\t_.defaults(this.options, defaultOptions);\n\t\t\tthis._positions.name = 1;\n\t\t\t\n\t\t\tvar attrToken = null;\n\t\t\tvar tokens = require('xmlParser').parse(source);\n\t\t\tvar range = require('range');\n\t\t\t\n\t\t\t_.each(tokens, function(token) {\n\t\t\t\ttoken.value = range.create(token).substring(source);\n\t\t\t\tswitch (token.type) {\n\t\t\t\t\tcase 'tag':\n\t\t\t\t\t\tif (/^<[^\\/]+/.test(token.value)) {\n\t\t\t\t\t\t\tthis._name = token.value.substring(1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\n\t\t\t\t\tcase 'attribute':\n\t\t\t\t\t\t// add empty attribute\n\t\t\t\t\t\tif (attrToken) {\n\t\t\t\t\t\t\tthis._children.push(new XMLEditElement(this, attrToken));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tattrToken = token;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\n\t\t\t\t\tcase 'string':\n\t\t\t\t\t\tthis._children.push(new XMLEditElement(this, attrToken, token));\n\t\t\t\t\t\tattrToken = null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}, this);\n\t\t\t\n\t\t\tif (attrToken) {\n\t\t\t\tthis._children.push(new XMLEditElement(this, attrToken));\n\t\t\t}\n\t\t\t\n\t\t\tthis._saveStyle();\n\t\t},\n\t\t\n\t\t/**\n\t\t * Remembers all styles of properties\n\t\t * @private\n\t\t */\n\t\t_saveStyle: function() {\n\t\t\tvar start = this.nameRange().end;\n\t\t\tvar source = this.source;\n\t\t\t\n\t\t\t_.each(this.list(), /** @param {EditElement} p */ function(p) {\n\t\t\t\tp.styleBefore = source.substring(start, p.namePosition());\n\t\t\t\t\n\t\t\t\tif (p.valuePosition() !== -1) {\n\t\t\t\t\tp.styleSeparator = source.substring(p.namePosition() + p.name().length, p.valuePosition() - p.styleQuote.length);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tstart = p.range().end;\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Adds new attribute \n\t\t * @param {String} name Property name\n\t\t * @param {String} value Property value\n\t\t * @param {Number} pos Position at which to insert new property. By \n\t\t * default the property is inserted at the end of rule \n\t\t */\n\t\tadd: function(name, value, pos) {\n\t\t\tvar list = this.list();\n\t\t\tvar start = this.nameRange().end;\n\t\t\tvar editTree = require('editTree');\n\t\t\tvar styles = _.pick(this.options, 'styleBefore', 'styleSeparator', 'styleQuote');\n\t\t\t\n\t\t\tif (_.isUndefined(pos))\n\t\t\t\tpos = list.length;\n\t\t\t\n\t\t\t\n\t\t\t/** @type XMLEditAttribute */\n\t\t\tvar donor = list[pos];\n\t\t\tif (donor) {\n\t\t\t\tstart = donor.fullRange().start;\n\t\t\t} else if (donor = list[pos - 1]) {\n\t\t\t\tstart = donor.range().end;\n\t\t\t}\n\t\t\t\n\t\t\tif (donor) {\n\t\t\t\tstyles = _.pick(donor, 'styleBefore', 'styleSeparator', 'styleQuote');\n\t\t\t}\n\t\t\t\n\t\t\tvalue = styles.styleQuote + value + styles.styleQuote;\n\t\t\t\n\t\t\tvar attribute = new XMLEditElement(this, \n\t\t\t\t\teditTree.createToken(start + styles.styleBefore.length, name),\n\t\t\t\t\teditTree.createToken(start + styles.styleBefore.length + name.length \n\t\t\t\t\t\t\t+ styles.styleSeparator.length, value)\n\t\t\t\t\t);\n\t\t\t\n\t\t\t_.extend(attribute, styles);\n\t\t\t\n\t\t\t// write new attribute into the source\n\t\t\tthis._updateSource(attribute.styleBefore + attribute.toString(), start);\n\t\t\t\n\t\t\t// insert new attribute\n\t\t\tthis._children.splice(pos, 0, attribute);\n\t\t\treturn attribute;\n\t\t}\n\t});\n\t\n\tvar XMLEditElement = require('editTree').EditElement.extend({\n\t\tinitialize: function(parent, nameToken, valueToken) {\n\t\t\tthis.styleBefore = parent.options.styleBefore;\n\t\t\tthis.styleSeparator = parent.options.styleSeparator;\n\t\t\t\n\t\t\tvar value = '', quote = parent.options.styleQuote;\n\t\t\tif (valueToken) {\n\t\t\t\tvalue = valueToken.value;\n\t\t\t\tquote = value.charAt(0);\n\t\t\t\tif (quote == '\"' || quote == \"'\") {\n\t\t\t\t\tvalue = value.substring(1);\n\t\t\t\t} else {\n\t\t\t\t\tquote = '';\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (quote && value.charAt(value.length - 1) == quote) {\n\t\t\t\t\tvalue = value.substring(0, value.length - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tthis.styleQuote = quote;\n\t\t\t\n\t\t\tthis._value = value;\n\t\t\tthis._positions.value = valueToken ? valueToken.start + quote.length : -1;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns full rule range, with indentation\n\t\t * @param {Boolean} isAbsolute Return absolute range (with respect of\n\t\t * rule offset)\n\t\t * @returns {Range}\n\t\t */\n\t\tfullRange: function(isAbsolute) {\n\t\t\tvar r = this.range(isAbsolute);\n\t\t\tr.start -= this.styleBefore.length;\n\t\t\treturn r;\n\t\t},\n\t\t\n\t\ttoString: function() {\n\t\t\treturn this.name() + this.styleSeparator\n\t\t\t\t+ this.styleQuote + this.value() + this.styleQuote;\n\t\t}\n\t});\n\t\n\treturn {\n\t\t/**\n\t\t * Parses HTML element into editable tree\n\t\t * @param {String} source\n\t\t * @param {Object} options\n\t\t * @memberOf emmet.htmlEditTree\n\t\t * @returns {EditContainer}\n\t\t */\n\t\tparse: function(source, options) {\n\t\t\treturn new XMLEditContainer(source, options);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Extract and parse HTML from specified position in <code>content</code> \n\t\t * @param {String} content CSS source code\n\t\t * @param {Number} pos Character position where to start source code extraction\n\t\t * @returns {XMLEditElement}\n\t\t */\n\t\tparseFromPosition: function(content, pos, isBackward) {\n\t\t\tvar bounds = this.extractTag(content, pos, isBackward);\n\t\t\tif (!bounds || !bounds.inside(pos))\n\t\t\t\t// no matching HTML tag or caret outside tag bounds\n\t\t\t\treturn null;\n\t\t\t\n\t\t\treturn this.parse(bounds.substring(content), {\n\t\t\t\toffset: bounds.start\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Extracts nearest HTML tag range from <code>content</code>, starting at \n\t\t * <code>pos</code> position\n\t\t * @param {String} content\n\t\t * @param {Number} pos\n\t\t * @param {Boolean} isBackward\n\t\t * @returns {Range}\n\t\t */\n\t\textractTag: function(content, pos, isBackward) {\n\t\t\tvar len = content.length, i;\n\t\t\tvar range = require('range');\n\t\t\t\n\t\t\t// max extraction length. I don't think there may be tags larger \n\t\t\t// than 2000 characters length\n\t\t\tvar maxLen = Math.min(2000, len);\n\t\t\t\n\t\t\t/** @type Range */\n\t\t\tvar r = null;\n\t\t\t\n\t\t\tvar match = function(pos) {\n\t\t\t\tvar m;\n\t\t\t\tif (content.charAt(pos) == '<' && (m = content.substr(pos, maxLen).match(startTag)))\n\t\t\t\t\treturn range.create(pos, m[0]);\n\t\t\t};\n\t\t\t\n\t\t\t// lookup backward, in case we are inside tag already\n\t\t\tfor (i = pos; i >= 0; i--) {\n\t\t\t\tif (r = match(i)) break;\n\t\t\t}\n\t\t\t\n\t\t\tif (r && (r.inside(pos) || isBackward))\n\t\t\t\treturn r;\n\t\t\t\n\t\t\tif (!r && isBackward)\n\t\t\t\treturn null;\n\t\t\t\n\t\t\t// search forward\n\t\t\tfor (i = pos; i < len; i++) {\n\t\t\t\tif (r = match(i))\n\t\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\t};\n});/**\n * 'Expand abbreviation' editor action: extracts abbreviation from current caret \n * position and replaces it with formatted output. \n * <br><br>\n * This behavior can be overridden with custom handlers which can perform \n * different actions when 'Expand Abbreviation' action is called.\n * For example, a CSS gradient handler that produces vendor-prefixed gradient\n * definitions registers its own expand abbreviation handler.  \n *  \n * @constructor\n * @memberOf __expandAbbreviationActionDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.define('expandAbbreviation', function(require, _) {\n\t/**\n\t * @type HandlerList List of registered handlers\n\t */\n\tvar handlers = require('handlerList').create();\n\t\n\t/** Back-reference to module */\n\tvar module = null;\n\t\n\tvar actions = require('actions');\n\t/**\n\t * 'Expand abbreviation' editor action \n\t * @param {IEmmetEditor} editor Editor instance\n\t * @param {String} syntax Syntax type (html, css, etc.)\n\t * @param {String} profile Output profile name (html, xml, xhtml)\n\t * @return {Boolean} Returns <code>true</code> if abbreviation was expanded \n\t * successfully\n\t */\n\tactions.add('expand_abbreviation', function(editor, syntax, profile) {\n\t\tvar args = _.toArray(arguments);\n\t\t\n\t\t// normalize incoming arguments\n\t\tvar info = require('editorUtils').outputInfo(editor, syntax, profile);\n\t\targs[1] = info.syntax;\n\t\targs[2] = info.profile;\n\t\t\n\t\treturn handlers.exec(false, args);\n\t});\n\t\n\t/**\n\t * A special version of <code>expandAbbreviation</code> function: if it can't\n\t * find abbreviation, it will place Tab character at caret position\n\t * @param {IEmmetEditor} editor Editor instance\n\t * @param {String} syntax Syntax type (html, css, etc.)\n\t * @param {String} profile Output profile name (html, xml, xhtml)\n\t */\n\tactions.add('expand_abbreviation_with_tab', function(editor, syntax, profile) {\n\t\tvar sel = editor.getSelection();\n\t\tvar indent = require('resources').getVariable('indentation');\n\t\tif (sel) {\n\t\t\t// indent selection\n\t\t\tvar utils = require('utils');\n\t\t\tvar selRange = require('range').create(editor.getSelectionRange());\n\t\t\tvar content = utils.padString(sel, indent);\n\t\t\t\n\t\t\teditor.replaceContent(indent + '${0}', editor.getCaretPos());\n\t\t\tvar replaceRange = require('range').create(editor.getCaretPos(), selRange.length());\n\t\t\teditor.replaceContent(content, replaceRange.start, replaceRange.end, true);\n\t\t\teditor.createSelection(replaceRange.start, replaceRange.start + content.length);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tif (!actions.run('expand_abbreviation', editor, syntax, profile)) {\n\t\t\teditor.replaceContent(indent, editor.getCaretPos());\n\t\t}\n\t\t\n\t\treturn true;\n\t}, {hidden: true});\n\t\n\t// XXX setup default handler\n\t/**\n\t * Extracts abbreviation from current caret \n\t * position and replaces it with formatted output \n\t * @param {IEmmetEditor} editor Editor instance\n\t * @param {String} syntax Syntax type (html, css, etc.)\n\t * @param {String} profile Output profile name (html, xml, xhtml)\n\t * @return {Boolean} Returns <code>true</code> if abbreviation was expanded \n\t * successfully\n\t */\n\thandlers.add(function(editor, syntax, profile) {\n\t\tvar caretPos = editor.getSelectionRange().end;\n\t\tvar abbr = module.findAbbreviation(editor);\n\t\t\t\n\t\tif (abbr) {\n\t\t\tvar content = emmet.expandAbbreviation(abbr, syntax, profile, \n\t\t\t\t\trequire('actionUtils').captureContext(editor));\n\t\t\tif (content) {\n\t\t\t\teditor.replaceContent(content, caretPos - abbr.length, caretPos);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}, {order: -1});\n\t\n\treturn module = {\n\t\t/**\n\t\t * Adds custom expand abbreviation handler. The passed function should \n\t\t * return <code>true</code> if it was performed successfully, \n\t\t * <code>false</code> otherwise.\n\t\t * \n\t\t * Added handlers will be called when 'Expand Abbreviation' is called\n\t\t * in order they were added\n\t\t * @memberOf expandAbbreviation\n\t\t * @param {Function} fn\n\t\t * @param {Object} options\n\t\t */\n\t\taddHandler: function(fn, options) {\n\t\t\thandlers.add(fn, options);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Removes registered handler\n\t\t * @returns\n\t\t */\n\t\tremoveHandler: function(fn) {\n\t\t\thandlers.remove(fn, options);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Search for abbreviation in editor from current caret position\n\t\t * @param {IEmmetEditor} editor Editor instance\n\t\t * @return {String}\n\t\t */\n\t\tfindAbbreviation: function(editor) {\n\t\t\t/** @type Range */\n\t\t\tvar range = require('range').create(editor.getSelectionRange());\n\t\t\tvar content = String(editor.getContent());\n\t\t\tif (range.length()) {\n\t\t\t\t// abbreviation is selected by user\n\t\t\t\treturn range.substring(content);\n\t\t\t}\n\t\t\t\n\t\t\t// search for new abbreviation from current caret position\n\t\t\tvar curLine = editor.getCurrentLineRange();\n\t\t\treturn require('actionUtils').extractAbbreviation(content.substring(curLine.start, range.start));\n\t\t}\n\t};\n});/**\n * Action that wraps content with abbreviation. For convenience, action is \n * defined as reusable module\n * @constructor\n * @memberOf __wrapWithAbbreviationDefine\n */\nemmet.define('wrapWithAbbreviation', function(require, _) {\n\t/** Back-references to current module */\n\tvar module = null;\n\t\n\t/**\n\t * Wraps content with abbreviation\n\t * @param {IEmmetEditor} Editor instance\n\t * @param {String} abbr Abbreviation to wrap with\n\t * @param {String} syntax Syntax type (html, css, etc.)\n\t * @param {String} profile Output profile name (html, xml, xhtml)\n\t */\n\trequire('actions').add('wrap_with_abbreviation', function (editor, abbr, syntax, profile) {\n\t\tvar info = require('editorUtils').outputInfo(editor, syntax, profile);\n\t\tvar utils = require('utils');\n\t\t/** @type emmet.editorUtils */\n\t\tvar editorUtils = require('editorUtils');\n\t\tabbr = abbr || editor.prompt(\"Enter abbreviation\");\n\t\t\n\t\tif (!abbr) \n\t\t\treturn null;\n\t\t\n\t\tabbr = String(abbr);\n\t\t\n\t\tvar range = require('range').create(editor.getSelectionRange());\n\t\t\n\t\tif (!range.length()) {\n\t\t\t// no selection, find tag pair\n\t\t\tvar match = require('htmlMatcher').tag(info.content, range.start);\n\t\t\tif (!match) {  // nothing to wrap\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\trange = utils.narrowToNonSpace(info.content, match.range);\n\t\t}\n\t\t\n\t\tvar newContent = utils.escapeText(range.substring(info.content));\n\t\tvar result = module\n\t\t\t.wrap(abbr, editorUtils.unindent(editor, newContent), info.syntax, \n\t\t\t\t\tinfo.profile, require('actionUtils').captureContext(editor));\n\t\t\n\t\tif (result) {\n\t\t\teditor.replaceContent(result, range.start, range.end);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t});\n\t\n\treturn module = {\n\t\t/**\n\t\t * Wraps passed text with abbreviation. Text will be placed inside last\n\t\t * expanded element\n\t\t * @memberOf wrapWithAbbreviation\n\t\t * @param {String} abbr Abbreviation\n\t\t * @param {String} text Text to wrap\n\t\t * @param {String} syntax Document type (html, xml, etc.). Default is 'html'\n\t\t * @param {String} profile Output profile's name. Default is 'plain'\n\t\t * @param {Object} contextNode Context node inside which abbreviation\n\t\t * is wrapped. It will be used as a reference for node name resolvers\n\t\t * @return {String}\n\t\t */\n\t\twrap: function(abbr, text, syntax, profile, contextNode) {\n\t\t\t/** @type emmet.filters */\n\t\t\tvar filters = require('filters');\n\t\t\t/** @type emmet.utils */\n\t\t\tvar utils = require('utils');\n\t\t\t\n\t\t\tsyntax = syntax || emmet.defaultSyntax();\n\t\t\tprofile = require('profile').get(profile, syntax);\n\t\t\t\n\t\t\trequire('tabStops').resetTabstopIndex();\n\t\t\t\n\t\t\tvar data = filters.extractFromAbbreviation(abbr);\n\t\t\tvar parsedTree = require('abbreviationParser').parse(data[0], {\n\t\t\t\tsyntax: syntax,\n\t\t\t\tpastedContent: text,\n\t\t\t\tcontextNode: contextNode\n\t\t\t});\n\t\t\tif (parsedTree) {\n\t\t\t\tvar filtersList = filters.composeList(syntax, profile, data[1]);\n\t\t\t\tfilters.apply(parsedTree, filtersList, profile);\n\t\t\t\treturn utils.replaceVariables(parsedTree.toString());\n\t\t\t}\n\t\t\t\n\t\t\treturn null;\n\t\t}\n\t};\n});/**\n * Toggles HTML and CSS comments depending on current caret context. Unlike\n * the same action in most editors, this action toggles comment on currently\n * matched item—HTML tag or CSS selector—when nothing is selected.\n * \n * @param {Function} require\n * @param {Underscore} _\n * @memberOf __toggleCommentAction\n * @constructor\n */\nemmet.exec(function(require, _) {\n\t/**\n\t * Toggle HTML comment on current selection or tag\n\t * @param {IEmmetEditor} editor\n\t * @return {Boolean} Returns <code>true</code> if comment was toggled\n\t */\n\tfunction toggleHTMLComment(editor) {\n\t\t/** @type Range */\n\t\tvar range = require('range').create(editor.getSelectionRange());\n\t\tvar info = require('editorUtils').outputInfo(editor);\n\t\t\t\n\t\tif (!range.length()) {\n\t\t\t// no selection, find matching tag\n\t\t\tvar tag = require('htmlMatcher').tag(info.content, editor.getCaretPos());\n\t\t\tif (tag) { // found pair\n\t\t\t\trange = tag.outerRange;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn genericCommentToggle(editor, '<!--', '-->', range);\n\t}\n\n\t/**\n\t * Simple CSS commenting\n\t * @param {IEmmetEditor} editor\n\t * @return {Boolean} Returns <code>true</code> if comment was toggled\n\t */\n\tfunction toggleCSSComment(editor) {\n\t\t/** @type Range */\n\t\tvar range = require('range').create(editor.getSelectionRange());\n\t\tvar info = require('editorUtils').outputInfo(editor);\n\t\t\t\n\t\tif (!range.length()) {\n\t\t\t// no selection, try to get current rule\n\t\t\t/** @type CSSRule */\n\t\t\tvar rule = require('cssEditTree').parseFromPosition(info.content, editor.getCaretPos());\n\t\t\tif (rule) {\n\t\t\t\tvar property = cssItemFromPosition(rule, editor.getCaretPos());\n\t\t\t\trange = property \n\t\t\t\t\t? property.range(true) \n\t\t\t\t\t: require('range').create(rule.nameRange(true).start, rule.source);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (!range.length()) {\n\t\t\t// still no selection, get current line\n\t\t\trange = require('range').create(editor.getCurrentLineRange());\n\t\t\trequire('utils').narrowToNonSpace(info.content, range);\n\t\t}\n\t\t\n\t\treturn genericCommentToggle(editor, '/*', '*/', range);\n\t}\n\t\n\t/**\n\t * Returns CSS property from <code>rule</code> that matches passed position\n\t * @param {EditContainer} rule\n\t * @param {Number} absPos\n\t * @returns {EditElement}\n\t */\n\tfunction cssItemFromPosition(rule, absPos) {\n\t\t// do not use default EditContainer.itemFromPosition() here, because\n\t\t// we need to make a few assumptions to make CSS commenting more reliable\n\t\tvar relPos = absPos - (rule.options.offset || 0);\n\t\tvar reSafeChar = /^[\\s\\n\\r]/;\n\t\treturn _.find(rule.list(), function(item) {\n\t\t\tif (item.range().end === relPos) {\n\t\t\t\t// at the end of property, but outside of it\n\t\t\t\t// if there’s a space character at current position,\n\t\t\t\t// use current property\n\t\t\t\treturn reSafeChar.test(rule.source.charAt(relPos));\n\t\t\t}\n\t\t\t\n\t\t\treturn item.range().inside(relPos);\n\t\t});\n\t}\n\n\t/**\n\t * Search for nearest comment in <code>str</code>, starting from index <code>from</code>\n\t * @param {String} text Where to search\n\t * @param {Number} from Search start index\n\t * @param {String} start_token Comment start string\n\t * @param {String} end_token Comment end string\n\t * @return {Range} Returns null if comment wasn't found\n\t */\n\tfunction searchComment(text, from, startToken, endToken) {\n\t\tvar commentStart = -1;\n\t\tvar commentEnd = -1;\n\t\t\n\t\tvar hasMatch = function(str, start) {\n\t\t\treturn text.substr(start, str.length) == str;\n\t\t};\n\t\t\t\n\t\t// search for comment start\n\t\twhile (from--) {\n\t\t\tif (hasMatch(startToken, from)) {\n\t\t\t\tcommentStart = from;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (commentStart != -1) {\n\t\t\t// search for comment end\n\t\t\tfrom = commentStart;\n\t\t\tvar contentLen = text.length;\n\t\t\twhile (contentLen >= from++) {\n\t\t\t\tif (hasMatch(endToken, from)) {\n\t\t\t\t\tcommentEnd = from + endToken.length;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn (commentStart != -1 && commentEnd != -1) \n\t\t\t? require('range').create(commentStart, commentEnd - commentStart) \n\t\t\t: null;\n\t}\n\n\t/**\n\t * Generic comment toggling routine\n\t * @param {IEmmetEditor} editor\n\t * @param {String} commentStart Comment start token\n\t * @param {String} commentEnd Comment end token\n\t * @param {Range} range Selection range\n\t * @return {Boolean}\n\t */\n\tfunction genericCommentToggle(editor, commentStart, commentEnd, range) {\n\t\tvar editorUtils = require('editorUtils');\n\t\tvar content = editorUtils.outputInfo(editor).content;\n\t\tvar caretPos = editor.getCaretPos();\n\t\tvar newContent = null;\n\t\t\n\t\tvar utils = require('utils');\n\t\t\t\n\t\t/**\n\t\t * Remove comment markers from string\n\t\t * @param {Sting} str\n\t\t * @return {String}\n\t\t */\n\t\tfunction removeComment(str) {\n\t\t\treturn str\n\t\t\t\t.replace(new RegExp('^' + utils.escapeForRegexp(commentStart) + '\\\\s*'), function(str){\n\t\t\t\t\tcaretPos -= str.length;\n\t\t\t\t\treturn '';\n\t\t\t\t}).replace(new RegExp('\\\\s*' + utils.escapeForRegexp(commentEnd) + '$'), '');\n\t\t}\n\t\t\n\t\t// first, we need to make sure that this substring is not inside \n\t\t// comment\n\t\tvar commentRange = searchComment(content, caretPos, commentStart, commentEnd);\n\t\tif (commentRange && commentRange.overlap(range)) {\n\t\t\t// we're inside comment, remove it\n\t\t\trange = commentRange;\n\t\t\tnewContent = removeComment(range.substring(content));\n\t\t} else {\n\t\t\t// should add comment\n\t\t\t// make sure that there's no comment inside selection\n\t\t\tnewContent = commentStart + ' ' +\n\t\t\t\trange.substring(content)\n\t\t\t\t\t.replace(new RegExp(utils.escapeForRegexp(commentStart) + '\\\\s*|\\\\s*' + utils.escapeForRegexp(commentEnd), 'g'), '') +\n\t\t\t\t' ' + commentEnd;\n\t\t\t\t\n\t\t\t// adjust caret position\n\t\t\tcaretPos += commentStart.length + 1;\n\t\t}\n\n\t\t// replace editor content\n\t\tif (newContent !== null) {\n\t\t\tnewContent = utils.escapeText(newContent);\n\t\t\teditor.setCaretPos(range.start);\n\t\t\teditor.replaceContent(editorUtils.unindent(editor, newContent), range.start, range.end);\n\t\t\teditor.setCaretPos(caretPos);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * Toggle comment on current editor's selection or HTML tag/CSS rule\n\t * @param {IEmmetEditor} editor\n\t */\n\trequire('actions').add('toggle_comment', function(editor) {\n\t\tvar info = require('editorUtils').outputInfo(editor);\n\t\tif (info.syntax == 'css') {\n\t\t\t// in case our editor is good enough and can recognize syntax from \n\t\t\t// current token, we have to make sure that cursor is not inside\n\t\t\t// 'style' attribute of html element\n\t\t\tvar caretPos = editor.getCaretPos();\n\t\t\tvar tag = require('htmlMatcher').tag(info.content, caretPos);\n\t\t\tif (tag && tag.open.range.inside(caretPos)) {\n\t\t\t\tinfo.syntax = 'html';\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (info.syntax == 'css')\n\t\t\treturn toggleCSSComment(editor);\n\t\t\n\t\treturn toggleHTMLComment(editor);\n\t});\n});/**\n * Move between next/prev edit points. 'Edit points' are places between tags \n * and quotes of empty attributes in html\n * @constructor\n * \n * @memberOf __editPointActionDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\t/**\n\t * Search for new caret insertion point\n\t * @param {IEmmetEditor} editor Editor instance\n\t * @param {Number} inc Search increment: -1 — search left, 1 — search right\n\t * @param {Number} offset Initial offset relative to current caret position\n\t * @return {Number} Returns -1 if insertion point wasn't found\n\t */\n\tfunction findNewEditPoint(editor, inc, offset) {\n\t\tinc = inc || 1;\n\t\toffset = offset || 0;\n\t\t\n\t\tvar curPoint = editor.getCaretPos() + offset;\n\t\tvar content = String(editor.getContent());\n\t\tvar maxLen = content.length;\n\t\tvar nextPoint = -1;\n\t\tvar reEmptyLine = /^\\s+$/;\n\t\t\n\t\tfunction getLine(ix) {\n\t\t\tvar start = ix;\n\t\t\twhile (start >= 0) {\n\t\t\t\tvar c = content.charAt(start);\n\t\t\t\tif (c == '\\n' || c == '\\r')\n\t\t\t\t\tbreak;\n\t\t\t\tstart--;\n\t\t\t}\n\t\t\t\n\t\t\treturn content.substring(start, ix);\n\t\t}\n\t\t\t\n\t\twhile (curPoint <= maxLen && curPoint >= 0) {\n\t\t\tcurPoint += inc;\n\t\t\tvar curChar = content.charAt(curPoint);\n\t\t\tvar nextChar = content.charAt(curPoint + 1);\n\t\t\tvar prevChar = content.charAt(curPoint - 1);\n\t\t\t\t\n\t\t\tswitch (curChar) {\n\t\t\t\tcase '\"':\n\t\t\t\tcase '\\'':\n\t\t\t\t\tif (nextChar == curChar && prevChar == '=') {\n\t\t\t\t\t\t// empty attribute\n\t\t\t\t\t\tnextPoint = curPoint + 1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '>':\n\t\t\t\t\tif (nextChar == '<') {\n\t\t\t\t\t\t// between tags\n\t\t\t\t\t\tnextPoint = curPoint + 1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\n':\n\t\t\t\tcase '\\r':\n\t\t\t\t\t// empty line\n\t\t\t\t\tif (reEmptyLine.test(getLine(curPoint - 1))) {\n\t\t\t\t\t\tnextPoint = curPoint;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tif (nextPoint != -1)\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\treturn nextPoint;\n\t}\n\t\n\t/** @type emmet.actions */\n\tvar actions = require('actions');\n\t\n\t/**\n\t * Move caret to previous edit point\n\t * @param {IEmmetEditor} editor Editor instance\n\t */\n\tactions.add('prev_edit_point', function(editor) {\n\t\tvar curPos = editor.getCaretPos();\n\t\tvar newPoint = findNewEditPoint(editor, -1);\n\t\t\t\n\t\tif (newPoint == curPos)\n\t\t\t// we're still in the same point, try searching from the other place\n\t\t\tnewPoint = findNewEditPoint(editor, -1, -2);\n\t\t\n\t\tif (newPoint != -1) {\n\t\t\teditor.setCaretPos(newPoint);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}, {label: 'Previous Edit Point'});\n\t\n\t/**\n\t * Move caret to next edit point\n\t * @param {IEmmetEditor} editor Editor instance\n\t */\n\tactions.add('next_edit_point', function(editor) {\n\t\tvar newPoint = findNewEditPoint(editor, 1);\n\t\tif (newPoint != -1) {\n\t\t\teditor.setCaretPos(newPoint);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t});\n});/**\n * Actions that use stream parsers and tokenizers for traversing:\n * -- Search for next/previous items in HTML\n * -- Search for next/previous items in CSS\n * @constructor\n * @memberOf __selectItemActionDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\tvar startTag = /^<([\\w\\:\\-]+)((?:\\s+[\\w\\-:]+(?:\\s*=\\s*(?:(?:\"[^\"]*\")|(?:'[^']*')|[^>\\s]+))?)*)\\s*(\\/?)>/;\n\t\n\t/**\n\t * Generic function for searching for items to select\n\t * @param {IEmmetEditor} editor\n\t * @param {Boolean} isBackward Search backward (search forward otherwise)\n\t * @param {Function} extractFn Function that extracts item content\n\t * @param {Function} rangeFn Function that search for next token range\n\t */\n\tfunction findItem(editor, isBackward, extractFn, rangeFn) {\n\t\tvar range = require('range');\n\t\tvar content = require('editorUtils').outputInfo(editor).content;\n\t\t\n\t\tvar contentLength = content.length;\n\t\tvar itemRange, rng;\n\t\t/** @type Range */\n\t\tvar prevRange = range.create(-1, 0);\n\t\t/** @type Range */\n\t\tvar sel = range.create(editor.getSelectionRange());\n\t\t\n\t\tvar searchPos = sel.start, loop = 100000; // endless loop protection\n\t\twhile (searchPos >= 0 && searchPos < contentLength && --loop > 0) {\n\t\t\tif ( (itemRange = extractFn(content, searchPos, isBackward)) ) {\n\t\t\t\tif (prevRange.equal(itemRange)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tprevRange = itemRange.clone();\n\t\t\t\trng = rangeFn(itemRange.substring(content), itemRange.start, sel.clone());\n\t\t\t\t\n\t\t\t\tif (rng) {\n\t\t\t\t\teditor.createSelection(rng.start, rng.end);\n\t\t\t\t\treturn true;\n\t\t\t\t} else {\n\t\t\t\t\tsearchPos = isBackward ? itemRange.start : itemRange.end - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tsearchPos += isBackward ? -1 : 1;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\t// XXX HTML section\n\t\n\t/**\n\t * Find next HTML item\n\t * @param {IEmmetEditor} editor\n\t */\n\tfunction findNextHTMLItem(editor) {\n\t\tvar isFirst = true;\n\t\treturn findItem(editor, false, function(content, searchPos){\n\t\t\tif (isFirst) {\n\t\t\t\tisFirst = false;\n\t\t\t\treturn findOpeningTagFromPosition(content, searchPos);\n\t\t\t} else {\n\t\t\t\treturn getOpeningTagFromPosition(content, searchPos);\n\t\t\t}\n\t\t}, function(tag, offset, selRange) {\n\t\t\treturn getRangeForHTMLItem(tag, offset, selRange, false);\n\t\t});\n\t}\n\t\n\t/**\n\t * Find previous HTML item\n\t * @param {IEmmetEditor} editor\n\t */\n\tfunction findPrevHTMLItem(editor) {\n\t\treturn findItem(editor, true, getOpeningTagFromPosition, function (tag, offset, selRange) {\n\t\t\treturn getRangeForHTMLItem(tag, offset, selRange, true);\n\t\t});\n\t}\n\t\n\t/**\n\t * Creates possible selection ranges for HTML tag\n\t * @param {String} source Original HTML source for tokens\n\t * @param {Array} tokens List of HTML tokens\n\t * @returns {Array}\n\t */\n\tfunction makePossibleRangesHTML(source, tokens, offset) {\n\t\toffset = offset || 0;\n\t\tvar range = require('range');\n\t\tvar result = [];\n\t\tvar attrStart = -1, attrName = '', attrValue = '', attrValueRange, tagName;\n\t\t_.each(tokens, function(tok) {\n\t\t\tswitch (tok.type) {\n\t\t\t\tcase 'tag':\n\t\t\t\t\ttagName = source.substring(tok.start, tok.end);\n\t\t\t\t\tif (/^<[\\w\\:\\-]/.test(tagName)) {\n\t\t\t\t\t\t// add tag name\n\t\t\t\t\t\tresult.push(range.create({\n\t\t\t\t\t\t\tstart: tok.start + 1, \n\t\t\t\t\t\t\tend: tok.end\n\t\t\t\t\t\t}));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'attribute':\n\t\t\t\t\tattrStart = tok.start;\n\t\t\t\t\tattrName = source.substring(tok.start, tok.end);\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase 'string':\n\t\t\t\t\t// attribute value\n\t\t\t\t\t// push full attribute first\n\t\t\t\t\t result.push(range.create(attrStart, tok.end - attrStart));\n\t\t\t\t\t \n\t\t\t\t\t attrValueRange = range.create(tok);\n\t\t\t\t\t attrValue = attrValueRange.substring(source);\n\t\t\t\t\t \n\t\t\t\t\t // is this a quoted attribute?\n\t\t\t\t\t if (isQuote(attrValue.charAt(0)))\n\t\t\t\t\t\t attrValueRange.start++;\n\t\t\t\t\t \n\t\t\t\t\t if (isQuote(attrValue.charAt(attrValue.length - 1)))\n\t\t\t\t\t\t attrValueRange.end--;\n\t\t\t\t\t \n\t\t\t\t\t result.push(attrValueRange);\n\t\t\t\t\t \n\t\t\t\t\t if (attrName == 'class') {\n\t\t\t\t\t\t result = result.concat(classNameRanges(attrValueRange.substring(source), attrValueRange.start));\n\t\t\t\t\t }\n\t\t\t\t\t \n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t});\n\t\t\n\t\t// offset ranges\n\t\t_.each(result, function(r) {\n\t\t\tr.shift(offset);\n\t\t});\n\t\t\n\t\treturn _.chain(result)\n\t\t\t.filter(function(item) {        // remove empty\n\t\t\t\treturn !!item.length();\n\t\t\t})\n\t\t\t.uniq(false, function(item) {   // remove duplicates\n\t\t\t\treturn item.toString();\n\t\t\t})\n\t\t\t.value();\n\t}\n\t\n\t/**\n\t * Returns ranges of class names in \"class\" attribute value\n\t * @param {String} className\n\t * @returns {Array}\n\t */\n\tfunction classNameRanges(className, offset) {\n\t\toffset = offset || 0;\n\t\tvar result = [];\n\t\t/** @type StringStream */\n\t\tvar stream = require('stringStream').create(className);\n\t\tvar range = require('range');\n\t\t\n\t\t// skip whitespace\n\t\tstream.eatSpace();\n\t\tstream.start = stream.pos;\n\t\t\n\t\tvar ch;\n\t\twhile (ch = stream.next()) {\n\t\t\tif (/[\\s\\u00a0]/.test(ch)) {\n\t\t\t\tresult.push(range.create(stream.start + offset, stream.pos - stream.start - 1));\n\t\t\t\tstream.eatSpace();\n\t\t\t\tstream.start = stream.pos;\n\t\t\t}\n\t\t}\n\t\t\n\t\tresult.push(range.create(stream.start + offset, stream.pos - stream.start));\n\t\treturn result;\n\t}\n\t\n\t/**\n\t * Returns best HTML tag range match for current selection\n\t * @param {String} tag Tag declaration\n\t * @param {Number} offset Tag's position index inside content\n\t * @param {Range} selRange Selection range\n\t * @return {Range} Returns range if next item was found, <code>null</code> otherwise\n\t */\n\tfunction getRangeForHTMLItem(tag, offset, selRange, isBackward) {\n\t\tvar ranges = makePossibleRangesHTML(tag, require('xmlParser').parse(tag), offset);\n\t\t\n\t\tif (isBackward)\n\t\t\tranges.reverse();\n\t\t\n\t\t// try to find selected range\n\t\tvar curRange = _.find(ranges, function(r) {\n\t\t\treturn r.equal(selRange);\n\t\t});\n\t\t\n\t\tif (curRange) {\n\t\t\tvar ix = _.indexOf(ranges, curRange);\n\t\t\tif (ix < ranges.length - 1)\n\t\t\t\treturn ranges[ix + 1];\n\t\t\t\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\t// no selected range, find nearest one\n\t\tif (isBackward)\n\t\t\t// search backward\n\t\t\treturn _.find(ranges, function(r) {\n\t\t\t\treturn r.start < selRange.start;\n\t\t\t});\n\t\t\n\t\t// search forward\n\t\t// to deal with overlapping ranges (like full attribute definition\n\t\t// and attribute value) let's find range under caret first\n\t\tif (!curRange) {\n\t\t\tvar matchedRanges = _.filter(ranges, function(r) {\n\t\t\t\treturn r.inside(selRange.end);\n\t\t\t});\n\t\t\t\n\t\t\tif (matchedRanges.length > 1)\n\t\t\t\treturn matchedRanges[1];\n\t\t}\n\t\t\n\t\t\n\t\treturn _.find(ranges, function(r) {\n\t\t\treturn r.end > selRange.end;\n\t\t});\n\t}\n\t\n\t/**\n\t * Search for opening tag in content, starting at specified position\n\t * @param {String} html Where to search tag\n\t * @param {Number} pos Character index where to start searching\n\t * @return {Range} Returns range if valid opening tag was found,\n\t * <code>null</code> otherwise\n\t */\n\tfunction findOpeningTagFromPosition(html, pos) {\n\t\tvar tag;\n\t\twhile (pos >= 0) {\n\t\t\tif (tag = getOpeningTagFromPosition(html, pos))\n\t\t\t\treturn tag;\n\t\t\tpos--;\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\t\n\t/**\n\t * @param {String} html Where to search tag\n\t * @param {Number} pos Character index where to start searching\n\t * @return {Range} Returns range if valid opening tag was found,\n\t * <code>null</code> otherwise\n\t */\n\tfunction getOpeningTagFromPosition(html, pos) {\n\t\tvar m;\n\t\tif (html.charAt(pos) == '<' && (m = html.substring(pos, html.length).match(startTag))) {\n\t\t\treturn require('range').create(pos, m[0]);\n\t\t}\n\t}\n\t\n\tfunction isQuote(ch) {\n\t\treturn ch == '\"' || ch == \"'\";\n\t}\n\t\n\t/**\n\t * Makes all possible selection ranges for specified CSS property\n\t * @param {CSSProperty} property\n\t * @returns {Array}\n\t */\n\tfunction makePossibleRangesCSS(property) {\n\t\t// find all possible ranges, sorted by position and size\n\t\tvar valueRange = property.valueRange(true);\n\t\tvar result = [property.range(true), valueRange];\n\t\tvar stringStream = require('stringStream');\n\t\tvar cssEditTree = require('cssEditTree');\n\t\tvar range = require('range');\n\t\t\n\t\t// locate parts of complex values.\n\t\t// some examples:\n\t\t// – 1px solid red: 3 parts\n\t\t// – arial, sans-serif: enumeration, 2 parts\n\t\t// – url(image.png): function value part\n\t\tvar value = property.value();\n\t\t_.each(property.valueParts(), function(r) {\n\t\t\t// add absolute range\n\t\t\tvar clone = r.clone();\n\t\t\tresult.push(clone.shift(valueRange.start));\n\t\t\t\n\t\t\t/** @type StringStream */\n\t\t\tvar stream = stringStream.create(r.substring(value));\n\t\t\tif (stream.match(/^[\\w\\-]+\\(/, true)) {\n\t\t\t\t// we have a function, find values in it.\n\t\t\t\t// but first add function contents\n\t\t\t\tstream.start = stream.pos;\n\t\t\t\tstream.skipToPair('(', ')');\n\t\t\t\tvar fnBody = stream.current();\n\t\t\t\tresult.push(range.create(clone.start + stream.start, fnBody));\n\t\t\t\t\n\t\t\t\t// find parts\n\t\t\t\t_.each(cssEditTree.findParts(fnBody), function(part) {\n\t\t\t\t\tresult.push(range.create(clone.start + stream.start + part.start, part.substring(fnBody)));\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t\t\n\t\t// optimize result: remove empty ranges and duplicates\n\t\treturn _.chain(result)\n\t\t\t.filter(function(item) {\n\t\t\t\treturn !!item.length();\n\t\t\t})\n\t\t\t.uniq(false, function(item) {\n\t\t\t\treturn item.toString();\n\t\t\t})\n\t\t\t.value();\n\t}\n\t\n\t/**\n\t * Tries to find matched CSS property and nearest range for selection\n\t * @param {CSSRule} rule\n\t * @param {Range} selRange\n\t * @param {Boolean} isBackward\n\t * @returns {Range}\n\t */\n\tfunction matchedRangeForCSSProperty(rule, selRange, isBackward) {\n\t\t/** @type CSSProperty */\n\t\tvar property = null;\n\t\tvar possibleRanges, curRange = null, ix;\n\t\tvar list = rule.list();\n\t\tvar searchFn, nearestItemFn;\n\t\t\n\t\tif (isBackward) {\n\t\t\tlist.reverse();\n\t\t\tsearchFn = function(p) {\n\t\t\t\treturn p.range(true).start <= selRange.start;\n\t\t\t};\n\t\t\tnearestItemFn = function(r) {\n\t\t\t\treturn r.start < selRange.start;\n\t\t\t};\n\t\t} else {\n\t\t\tsearchFn = function(p) {\n\t\t\t\treturn p.range(true).end >= selRange.end;\n\t\t\t};\n\t\t\tnearestItemFn = function(r) {\n\t\t\t\treturn r.end > selRange.start;\n\t\t\t};\n\t\t}\n\t\t\n\t\t// search for nearest to selection CSS property\n\t\twhile (property = _.find(list, searchFn)) {\n\t\t\tpossibleRanges = makePossibleRangesCSS(property);\n\t\t\tif (isBackward)\n\t\t\t\tpossibleRanges.reverse();\n\t\t\t\n\t\t\t// check if any possible range is already selected\n\t\t\tcurRange = _.find(possibleRanges, function(r) {\n\t\t\t\treturn r.equal(selRange);\n\t\t\t});\n\t\t\t\n\t\t\tif (!curRange) {\n\t\t\t\t// no selection, select nearest item\n\t\t\t\tvar matchedRanges = _.filter(possibleRanges, function(r) {\n\t\t\t\t\treturn r.inside(selRange.end);\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tif (matchedRanges.length > 1) {\n\t\t\t\t\tcurRange = matchedRanges[1];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (curRange = _.find(possibleRanges, nearestItemFn))\n\t\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tix = _.indexOf(possibleRanges, curRange);\n\t\t\t\tif (ix != possibleRanges.length - 1) {\n\t\t\t\t\tcurRange = possibleRanges[ix + 1];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tcurRange = null;\n\t\t\tselRange.start = selRange.end = isBackward \n\t\t\t\t? property.range(true).start - 1\n\t\t\t\t: property.range(true).end + 1;\n\t\t}\n\t\t\n\t\treturn curRange;\n\t}\n\t\n\tfunction findNextCSSItem(editor) {\n\t\treturn findItem(editor, false, require('cssEditTree').extractRule, getRangeForNextItemInCSS);\n\t}\n\t\n\tfunction findPrevCSSItem(editor) {\n\t\treturn findItem(editor, true, require('cssEditTree').extractRule, getRangeForPrevItemInCSS);\n\t}\n\t\n\t/**\n\t * Returns range for item to be selected in CSS after current caret \n\t * (selection) position\n\t * @param {String} rule CSS rule declaration\n\t * @param {Number} offset Rule's position index inside content\n\t * @param {Range} selRange Selection range\n\t * @return {Range} Returns range if next item was found, <code>null</code> otherwise\n\t */\n\tfunction getRangeForNextItemInCSS(rule, offset, selRange) {\n\t\tvar tree = require('cssEditTree').parse(rule, {\n\t\t\toffset: offset\n\t\t});\n\t\t\n\t\t// check if selector is matched\n\t\tvar range = tree.nameRange(true);\n\t\tif (selRange.end < range.end) {\n\t\t\treturn range;\n\t\t}\n\t\t\n\t\treturn matchedRangeForCSSProperty(tree, selRange, false);\n\t}\n\t\n\t/**\n\t * Returns range for item to be selected in CSS before current caret \n\t * (selection) position\n\t * @param {String} rule CSS rule declaration\n\t * @param {Number} offset Rule's position index inside content\n\t * @param {Range} selRange Selection range\n\t * @return {Range} Returns range if previous item was found, <code>null</code> otherwise\n\t */\n\tfunction getRangeForPrevItemInCSS(rule, offset, selRange) {\n\t\tvar tree = require('cssEditTree').parse(rule, {\n\t\t\toffset: offset\n\t\t});\n\t\t\n\t\tvar curRange = matchedRangeForCSSProperty(tree, selRange, true);\n\t\t\n\t\tif (!curRange) {\n\t\t\t// no matched property, try to match selector\n\t\t\tvar range = tree.nameRange(true);\n\t\t\tif (selRange.start > range.start) {\n\t\t\t\treturn range;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn curRange;\n\t}\n\t\n\t// XXX register actions\n\tvar actions = require('actions');\n\tactions.add('select_next_item', function(editor){\n\t\tif (editor.getSyntax() == 'css')\n\t\t\treturn findNextCSSItem(editor);\n\t\telse\n\t\t\treturn findNextHTMLItem(editor);\n\t});\n\t\n\tactions.add('select_previous_item', function(editor){\n\t\tif (editor.getSyntax() == 'css')\n\t\t\treturn findPrevCSSItem(editor);\n\t\telse\n\t\t\treturn findPrevHTMLItem(editor);\n\t});\n});/**\n * HTML pair matching (balancing) actions\n * @constructor\n * @memberOf __matchPairActionDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\t/** @type emmet.actions */\n\tvar actions = require('actions');\n\tvar matcher = require('htmlMatcher');\n\tvar lastMatch = null;\n\t\n\t/**\n\t * Find and select HTML tag pair\n\t * @param {IEmmetEditor} editor Editor instance\n\t * @param {String} direction Direction of pair matching: 'in' or 'out'. \n\t * Default is 'out'\n\t */\n\tfunction matchPair(editor, direction) {\n\t\tdirection = String((direction || 'out').toLowerCase());\n\t\tvar info = require('editorUtils').outputInfo(editor);\n\t\t\n\t\tvar range = require('range');\n\t\t/** @type Range */\n\t\tvar sel = range.create(editor.getSelectionRange());\n\t\tvar content = info.content;\n\t\t\n\t\t// validate previous match\n\t\tif (lastMatch && !lastMatch.range.equal(sel)) {\n\t\t\tlastMatch = null;\n\t\t}\n\t\t\n\t\tif (lastMatch && sel.length()) {\n\t\t\tif (direction == 'in') {\n\t\t\t\t// user has previously selected tag and wants to move inward\n\t\t\t\tif (lastMatch.type == 'tag' && !lastMatch.close) {\n\t\t\t\t\t// unary tag was selected, can't move inward\n\t\t\t\t\treturn false;\n\t\t\t\t} else {\n\t\t\t\t\tif (lastMatch.range.equal(lastMatch.outerRange)) {\n\t\t\t\t\t\tlastMatch.range = lastMatch.innerRange;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar narrowed = require('utils').narrowToNonSpace(content, lastMatch.innerRange);\n\t\t\t\t\t\tlastMatch = matcher.find(content, narrowed.start + 1);\n\t\t\t\t\t\tif (lastMatch && lastMatch.range.equal(sel) && lastMatch.outerRange.equal(sel)) {\n\t\t\t\t\t\t\tlastMatch.range = lastMatch.innerRange;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (\n\t\t\t\t\t\t!lastMatch.innerRange.equal(lastMatch.outerRange) \n\t\t\t\t\t\t&& lastMatch.range.equal(lastMatch.innerRange) \n\t\t\t\t\t\t&& sel.equal(lastMatch.range)) {\n\t\t\t\t\tlastMatch.range = lastMatch.outerRange;\n\t\t\t\t} else {\n\t\t\t\t\tlastMatch = matcher.find(content, sel.start);\n\t\t\t\t\tif (lastMatch && lastMatch.range.equal(sel) && lastMatch.innerRange.equal(sel)) {\n\t\t\t\t\t\tlastMatch.range = lastMatch.outerRange;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tlastMatch = matcher.find(content, sel.start);\n\t\t}\n\t\t\n\t\tif (lastMatch && !lastMatch.range.equal(sel)) {\n\t\t\teditor.createSelection(lastMatch.range.start, lastMatch.range.end);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tlastMatch = null;\n\t\treturn false;\n\t}\n\t\n\tactions.add('match_pair', matchPair, {hidden: true});\n\tactions.add('match_pair_inward', function(editor){\n\t\treturn matchPair(editor, 'in');\n\t}, {label: 'HTML/Match Pair Tag (inward)'});\n\n\tactions.add('match_pair_outward', function(editor){\n\t\treturn matchPair(editor, 'out');\n\t}, {label: 'HTML/Match Pair Tag (outward)'});\n\t\n\t/**\n\t * Moves caret to matching opening or closing tag\n\t * @param {IEmmetEditor} editor\n\t */\n\tactions.add('matching_pair', function(editor) {\n\t\tvar content = String(editor.getContent());\n\t\tvar caretPos = editor.getCaretPos();\n\t\t\n\t\tif (content.charAt(caretPos) == '<') \n\t\t\t// looks like caret is outside of tag pair  \n\t\t\tcaretPos++;\n\t\t\t\n\t\tvar tag = matcher.tag(content, caretPos);\n\t\tif (tag && tag.close) { // exclude unary tags\n\t\t\tif (tag.open.range.inside(caretPos)) {\n\t\t\t\teditor.setCaretPos(tag.close.range.start);\n\t\t\t} else {\n\t\t\t\teditor.setCaretPos(tag.open.range.start);\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}, {label: 'HTML/Go To Matching Tag Pair'});\n});/**\n * Gracefully removes tag under cursor\n * \n * @param {Function} require\n * @param {Underscore} _ \n */\nemmet.exec(function(require, _) {\n\trequire('actions').add('remove_tag', function(editor) {\n\t\tvar utils = require('utils');\n\t\tvar info = require('editorUtils').outputInfo(editor);\n\t\t\n\t\t// search for tag\n\t\tvar tag = require('htmlMatcher').tag(info.content, editor.getCaretPos());\n\t\tif (tag) {\n\t\t\tif (!tag.close) {\n\t\t\t\t// simply remove unary tag\n\t\t\t\teditor.replaceContent(utils.getCaretPlaceholder(), tag.range.start, tag.range.end);\n\t\t\t} else {\n\t\t\t\t// remove tag and its newlines\n\t\t\t\t/** @type Range */\n\t\t\t\tvar tagContentRange = utils.narrowToNonSpace(info.content, tag.innerRange);\n\t\t\t\t/** @type Range */\n\t\t\t\tvar startLineBounds = utils.findNewlineBounds(info.content, tagContentRange.start);\n\t\t\t\tvar startLinePad = utils.getLinePadding(startLineBounds.substring(info.content));\n\t\t\t\tvar tagContent = tagContentRange.substring(info.content);\n\t\t\t\t\n\t\t\t\ttagContent = utils.unindentString(tagContent, startLinePad);\n\t\t\t\teditor.replaceContent(utils.getCaretPlaceholder() + utils.escapeText(tagContent), tag.outerRange.start, tag.outerRange.end);\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}, {label: 'HTML/Remove Tag'});\n});\n/**\n * Splits or joins tag, e.g. transforms it into a short notation and vice versa:<br>\n * &lt;div&gt;&lt;/div&gt; → &lt;div /&gt; : join<br>\n * &lt;div /&gt; → &lt;div&gt;&lt;/div&gt; : split\n * @param {Function} require\n * @param {Underscore} _\n * @memberOf __splitJoinTagAction\n * @constructor\n */\nemmet.exec(function(require, _) {\n\t/**\n\t * @param {IEmmetEditor} editor\n\t * @param {Object} profile\n\t * @param {Object} tag\n\t */\n\tfunction joinTag(editor, profile, tag) {\n\t\t/** @type emmet.utils */\n\t\tvar utils = require('utils');\n\t\t\n\t\t// empty closing slash is a nonsense for this action\n\t\tvar slash = profile.selfClosing() || ' /';\n\t\tvar content = tag.open.range.substring(tag.source).replace(/\\s*>$/, slash + '>');\n\t\t\n\t\tvar caretPos = editor.getCaretPos();\n\t\t\n\t\t// update caret position\n\t\tif (content.length + tag.outerRange.start < caretPos) {\n\t\t\tcaretPos = content.length + tag.outerRange.start;\n\t\t}\n\t\t\n\t\tcontent = utils.escapeText(content);\n\t\teditor.replaceContent(content, tag.outerRange.start, tag.outerRange.end);\n\t\teditor.setCaretPos(caretPos);\n\t\treturn true;\n\t}\n\t\n\tfunction splitTag(editor, profile, tag) {\n\t\t/** @type emmet.utils */\n\t\tvar utils = require('utils');\n\t\t\n\t\tvar nl = utils.getNewline();\n\t\tvar pad = require('resources').getVariable('indentation');\n\t\tvar caretPos = editor.getCaretPos();\n\t\t\n\t\t// define tag content depending on profile\n\t\tvar tagContent = (profile.tag_nl === true) ? nl + pad + nl : '';\n\t\tvar content = tag.outerContent().replace(/\\s*\\/>$/, '>');\n\t\tcaretPos = tag.outerRange.start + content.length;\n\t\tcontent += tagContent + '</' + tag.open.name + '>';\n\t\t\n\t\tcontent = utils.escapeText(content);\n\t\teditor.replaceContent(content, tag.outerRange.start, tag.outerRange.end);\n\t\teditor.setCaretPos(caretPos);\n\t\treturn true;\n\t}\n\t\n\trequire('actions').add('split_join_tag', function(editor, profileName) {\n\t\tvar matcher = require('htmlMatcher');\n\t\t\n\t\tvar info = require('editorUtils').outputInfo(editor, null, profileName);\n\t\tvar profile = require('profile').get(info.profile);\n\t\t\n\t\t// find tag at current position\n\t\tvar tag = matcher.tag(info.content, editor.getCaretPos());\n\t\tif (tag) {\n\t\t\treturn tag.close \n\t\t\t\t? joinTag(editor, profile, tag) \n\t\t\t\t: splitTag(editor, profile, tag);\n\t\t}\n\t\t\n\t\treturn false;\n\t}, {label: 'HTML/Split\\\\Join Tag Declaration'});\n});/**\n * Reflect CSS value: takes rule's value under caret and pastes it for the same \n * rules with vendor prefixes\n * @constructor\n * @memberOf __reflectCSSActionDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.define('reflectCSSValue', function(require, _) {\n\t/**\n\t * @type HandlerList List of registered handlers\n\t */\n\tvar handlers = require('handlerList').create();\n\t\n\trequire('actions').add('reflect_css_value', function(editor) {\n\t\tif (editor.getSyntax() != 'css') return false;\n\t\t\n\t\treturn require('actionUtils').compoundUpdate(editor, doCSSReflection(editor));\n\t}, {label: 'CSS/Reflect Value'});\n\t\n\tfunction doCSSReflection(editor) {\n\t\t/** @type emmet.cssEditTree */\n\t\tvar cssEditTree = require('cssEditTree');\n\t\tvar outputInfo = require('editorUtils').outputInfo(editor);\n\t\tvar caretPos = editor.getCaretPos();\n\t\t\n\t\tvar cssRule = cssEditTree.parseFromPosition(outputInfo.content, caretPos);\n\t\tif (!cssRule) return;\n\t\t\n\t\tvar property = cssRule.itemFromPosition(caretPos, true);\n\t\t// no property under cursor, nothing to reflect\n\t\tif (!property) return;\n\t\t\n\t\tvar oldRule = cssRule.source;\n\t\tvar offset = cssRule.options.offset;\n\t\tvar caretDelta = caretPos - offset - property.range().start;\n\t\t\n\t\thandlers.exec(false, [property]);\n\t\t\n\t\tif (oldRule !== cssRule.source) {\n\t\t\treturn {\n\t\t\t\tdata:  cssRule.source,\n\t\t\t\tstart: offset,\n\t\t\t\tend:   offset + oldRule.length,\n\t\t\t\tcaret: offset + property.range().start + caretDelta\n\t\t\t};\n\t\t}\n\t}\n\t\n\t/**\n\t * Returns regexp that should match reflected CSS property names\n\t * @param {String} name Current CSS property name\n\t * @return {RegExp}\n\t */\n\tfunction getReflectedCSSName(name) {\n\t\tname = require('cssEditTree').baseName(name);\n\t\tvar vendorPrefix = '^(?:\\\\-\\\\w+\\\\-)?', m;\n\t\t\n\t\tif (name == 'opacity' || name == 'filter') {\n\t\t\treturn new RegExp(vendorPrefix + '(?:opacity|filter)$');\n\t\t} else if (m = name.match(/^border-radius-(top|bottom)(left|right)/)) {\n\t\t\t// Mozilla-style border radius\n\t\t\treturn new RegExp(vendorPrefix + '(?:' + name + '|border-' + m[1] + '-' + m[2] + '-radius)$');\n\t\t} else if (m = name.match(/^border-(top|bottom)-(left|right)-radius/)) { \n\t\t\treturn new RegExp(vendorPrefix + '(?:' + name + '|border-radius-' + m[1] + m[2] + ')$');\n\t\t}\n\t\t\n\t\treturn new RegExp(vendorPrefix + name + '$');\n\t}\n\t\n\t/**\n\t * Reflects value from <code>donor</code> into <code>receiver</code>\n\t * @param {CSSProperty} donor Donor CSS property from which value should\n\t * be reflected\n\t * @param {CSSProperty} receiver Property that should receive reflected \n\t * value from donor\n\t */\n\tfunction reflectValue(donor, receiver) {\n\t\tvar value = getReflectedValue(donor.name(), donor.value(), \n\t\t\t\treceiver.name(), receiver.value());\n\t\t\n\t\treceiver.value(value);\n\t}\n\t\n\t/**\n\t * Returns value that should be reflected for <code>refName</code> CSS property\n\t * from <code>curName</code> property. This function is used for special cases,\n\t * when the same result must be achieved with different properties for different\n\t * browsers. For example: opаcity:0.5; → filter:alpha(opacity=50);<br><br>\n\t * \n\t * This function does value conversion between different CSS properties\n\t * \n\t * @param {String} curName Current CSS property name\n\t * @param {String} curValue Current CSS property value\n\t * @param {String} refName Receiver CSS property's name \n\t * @param {String} refValue Receiver CSS property's value\n\t * @return {String} New value for receiver property\n\t */\n\tfunction getReflectedValue(curName, curValue, refName, refValue) {\n\t\tvar cssEditTree = require('cssEditTree');\n\t\tvar utils = require('utils');\n\t\tcurName = cssEditTree.baseName(curName);\n\t\trefName = cssEditTree.baseName(refName);\n\t\t\n\t\tif (curName == 'opacity' && refName == 'filter') {\n\t\t\treturn refValue.replace(/opacity=[^)]*/i, 'opacity=' + Math.floor(parseFloat(curValue) * 100));\n\t\t} else if (curName == 'filter' && refName == 'opacity') {\n\t\t\tvar m = curValue.match(/opacity=([^)]*)/i);\n\t\t\treturn m ? utils.prettifyNumber(parseInt(m[1]) / 100) : refValue;\n\t\t}\n\t\t\n\t\treturn curValue;\n\t}\n\t\n\t// XXX add default handler\n\thandlers.add(function(property) {\n\t\tvar reName = getReflectedCSSName(property.name());\n\t\t_.each(property.parent.list(), function(p) {\n\t\t\tif (reName.test(p.name())) {\n\t\t\t\treflectValue(property, p);\n\t\t\t}\n\t\t});\n\t}, {order: -1});\n\t\n\treturn {\n\t\t/**\n\t\t * Adds custom reflect handler. The passed function will receive matched\n\t\t * CSS property (as <code>CSSEditElement</code> object) and should\n\t\t * return <code>true</code> if it was performed successfully (handled \n\t\t * reflection), <code>false</code> otherwise.\n\t\t * @param {Function} fn\n\t\t * @param {Object} options\n\t\t */\n\t\taddHandler: function(fn, options) {\n\t\t\thandlers.add(fn, options);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Removes registered handler\n\t\t * @returns\n\t\t */\n\t\tremoveHandler: function(fn) {\n\t\t\thandlers.remove(fn, options);\n\t\t}\n\t};\n});/**\n * Evaluates simple math expression under caret\n * @param {Function} require\n * @param {Underscore} _ \n */\nemmet.exec(function(require, _) {\n\trequire('actions').add('evaluate_math_expression', function(editor) {\n\t\tvar actionUtils = require('actionUtils');\n\t\tvar utils = require('utils');\n\t\t\n\t\tvar content = String(editor.getContent());\n\t\tvar chars = '.+-*/\\\\';\n\t\t\n\t\t/** @type Range */\n\t\tvar sel = require('range').create(editor.getSelectionRange());\n\t\tif (!sel.length()) {\n\t\t\tsel = actionUtils.findExpressionBounds(editor, function(ch) {\n\t\t\t\treturn utils.isNumeric(ch) || chars.indexOf(ch) != -1;\n\t\t\t});\n\t\t}\n\t\t\n\t\tif (sel && sel.length()) {\n\t\t\tvar expr = sel.substring(content);\n\t\t\t\n\t\t\t// replace integral division: 11\\2 => Math.round(11/2) \n\t\t\texpr = expr.replace(/([\\d\\.\\-]+)\\\\([\\d\\.\\-]+)/g, 'Math.round($1/$2)');\n\t\t\t\n\t\t\ttry {\n\t\t\t\tvar result = utils.prettifyNumber(new Function('return ' + expr)());\n\t\t\t\teditor.replaceContent(result, sel.start, sel.end);\n\t\t\t\teditor.setCaretPos(sel.start + result.length);\n\t\t\t\treturn true;\n\t\t\t} catch (e) {}\n\t\t}\n\t\t\n\t\treturn false;\n\t}, {label: 'Numbers/Evaluate Math Expression'});\n});\n/**\n * Increment/decrement number under cursor\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\t/**\n\t * Extract number from current caret position of the <code>editor</code> and\n\t * increment it by <code>step</code>\n\t * @param {IEmmetEditor} editor\n\t * @param {Number} step Increment step (may be negative)\n\t */\n\tfunction incrementNumber(editor, step) {\n\t\tvar utils = require('utils');\n\t\tvar actionUtils = require('actionUtils');\n\t\t\n\t\tvar hasSign = false;\n\t\tvar hasDecimal = false;\n\t\t\t\n\t\tvar r = actionUtils.findExpressionBounds(editor, function(ch, pos, content) {\n\t\t\tif (utils.isNumeric(ch))\n\t\t\t\treturn true;\n\t\t\tif (ch == '.') {\n\t\t\t\t// make sure that next character is numeric too\n\t\t\t\tif (!utils.isNumeric(content.charAt(pos + 1)))\n\t\t\t\t\treturn false;\n\t\t\t\t\n\t\t\t\treturn hasDecimal ? false : hasDecimal = true;\n\t\t\t}\n\t\t\tif (ch == '-')\n\t\t\t\treturn hasSign ? false : hasSign = true;\n\t\t\t\t\n\t\t\treturn false;\n\t\t});\n\t\t\t\n\t\tif (r && r.length()) {\n\t\t\tvar strNum = r.substring(String(editor.getContent()));\n\t\t\tvar num = parseFloat(strNum);\n\t\t\tif (!_.isNaN(num)) {\n\t\t\t\tnum = utils.prettifyNumber(num + step);\n\t\t\t\t\n\t\t\t\t// do we have zero-padded number?\n\t\t\t\tif (/^(\\-?)0+[1-9]/.test(strNum)) {\n\t\t\t\t\tvar minus = '';\n\t\t\t\t\tif (RegExp.$1) {\n\t\t\t\t\t\tminus = '-';\n\t\t\t\t\t\tnum = num.substring(1);\n\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\tvar parts = num.split('.');\n\t\t\t\t\tparts[0] = utils.zeroPadString(parts[0], intLength(strNum));\n\t\t\t\t\tnum = minus + parts.join('.');\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\teditor.replaceContent(num, r.start, r.end);\n\t\t\t\teditor.createSelection(r.start, r.start + num.length);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * Returns length of integer part of number\n\t * @param {String} num\n\t */\n\tfunction intLength(num) {\n\t\tnum = num.replace(/^\\-/, '');\n\t\tif (~num.indexOf('.')) {\n\t\t\treturn num.split('.')[0].length;\n\t\t}\n\t\t\n\t\treturn num.length;\n\t}\n\t\n\tvar actions = require('actions');\n\t_.each([1, -1, 10, -10, 0.1, -0.1], function(num) {\n\t\tvar prefix = num > 0 ? 'increment' : 'decrement';\n\t\t\n\t\tactions.add(prefix + '_number_by_' + String(Math.abs(num)).replace('.', '').substring(0, 2), function(editor) {\n\t\t\treturn incrementNumber(editor, num);\n\t\t}, {label: 'Numbers/' + prefix.charAt(0).toUpperCase() + prefix.substring(1) + ' number by ' + Math.abs(num)});\n\t});\n});/**\n * Actions to insert line breaks. Some simple editors (like browser's \n * &lt;textarea&gt;, for example) do not provide such simple things\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\tvar actions = require('actions');\n\t/** @type emmet.preferences */\n\tvar prefs = require('preferences');\n\t\n\t// setup default preferences\n\tprefs.define('css.closeBraceIndentation', '\\n',\n\t\t\t'Indentation before closing brace of CSS rule. Some users prefere ' \n\t\t\t+ 'indented closing brace of CSS rule for better readability. '\n\t\t\t+ 'This preference’s value will be automatically inserted before '\n\t\t\t+ 'closing brace when user adds newline in newly created CSS rule '\n\t\t\t+ '(e.g. when “Insert formatted linebreak” action will be performed ' \n\t\t\t+ 'in CSS file). If you’re such user, you may want to write put a value ' \n\t\t\t+ 'like <code>\\\\n\\\\t</code> in this preference.');\n\t\n\t/**\n\t * Inserts newline character with proper indentation in specific positions only.\n\t * @param {IEmmetEditor} editor\n\t * @return {Boolean} Returns <code>true</code> if line break was inserted \n\t */\n\tactions.add('insert_formatted_line_break_only', function(editor) {\n\t\tvar utils = require('utils');\n\t\t/** @type emmet.resources */\n\t\tvar res = require('resources');\n\t\t\n\t\tvar info = require('editorUtils').outputInfo(editor);\n\t\tvar caretPos = editor.getCaretPos();\n\t\tvar nl = utils.getNewline();\n\t\t\n\t\tif (_.include(['html', 'xml', 'xsl'], info.syntax)) {\n\t\t\tvar pad = res.getVariable('indentation');\n\t\t\t// let's see if we're breaking newly created tag\n\t\t\tvar tag = require('htmlMatcher').tag(info.content, caretPos);\n\t\t\tif (tag && !tag.innerRange.length()) {\n\t\t\t\teditor.replaceContent(nl + pad + utils.getCaretPlaceholder() + nl, caretPos);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else if (info.syntax == 'css') {\n\t\t\t/** @type String */\n\t\t\tvar content = info.content;\n\t\t\tif (caretPos && content.charAt(caretPos - 1) == '{') {\n\t\t\t\tvar append = prefs.get('css.closeBraceIndentation');\n\t\t\t\tvar pad = res.getVariable('indentation');\n\t\t\t\t\n\t\t\t\tvar hasCloseBrace = content.charAt(caretPos) == '}';\n\t\t\t\tif (!hasCloseBrace) {\n\t\t\t\t\t// do we really need special formatting here?\n\t\t\t\t\t// check if this is really a newly created rule,\n\t\t\t\t\t// look ahead for a closing brace\n\t\t\t\t\tfor (var i = caretPos, il = content.length, ch; i < il; i++) {\n\t\t\t\t\t\tch = content.charAt(i);\n\t\t\t\t\t\tif (ch == '{') {\n\t\t\t\t\t\t\t// ok, this is a new rule without closing brace\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (ch == '}') {\n\t\t\t\t\t\t\t// not a new rule, just add indentation\n\t\t\t\t\t\t\tappend = '';\n\t\t\t\t\t\t\thasCloseBrace = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (!hasCloseBrace) {\n\t\t\t\t\tappend += '}';\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// defining rule set\n\t\t\t\tvar insValue = nl + pad + utils.getCaretPlaceholder() + append;\n\t\t\t\teditor.replaceContent(insValue, caretPos);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\t\n\t\treturn false;\n\t}, {hidden: true});\n\t\n\t/**\n\t * Inserts newline character with proper indentation. This action is used in\n\t * editors that doesn't have indentation control (like textarea element) to \n\t * provide proper indentation\n\t * @param {IEmmetEditor} editor Editor instance\n\t */\n\tactions.add('insert_formatted_line_break', function(editor) {\n\t\tif (!actions.run('insert_formatted_line_break_only', editor)) {\n\t\t\tvar utils = require('utils');\n\t\t\t\n\t\t\tvar curPadding = require('editorUtils').getCurrentLinePadding(editor);\n\t\t\tvar content = String(editor.getContent());\n\t\t\tvar caretPos = editor.getCaretPos();\n\t\t\tvar len = content.length;\n\t\t\tvar nl = utils.getNewline();\n\t\t\t\t\n\t\t\t// check out next line padding\n\t\t\tvar lineRange = editor.getCurrentLineRange();\n\t\t\tvar nextPadding = '';\n\t\t\t\t\n\t\t\tfor (var i = lineRange.end + 1, ch; i < len; i++) {\n\t\t\t\tch = content.charAt(i);\n\t\t\t\tif (ch == ' ' || ch == '\\t')\n\t\t\t\t\tnextPadding += ch;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tif (nextPadding.length > curPadding.length)\n\t\t\t\teditor.replaceContent(nl + nextPadding, caretPos, caretPos, true);\n\t\t\telse\n\t\t\t\teditor.replaceContent(nl, caretPos);\n\t\t}\n\t\t\n\t\treturn true;\n\t}, {hidden: true});\n});/**\n * Merges selected lines or lines between XHTML tag pairs\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\trequire('actions').add('merge_lines', function(editor) {\n\t\tvar matcher = require('htmlMatcher');\n\t\tvar utils = require('utils');\n\t\tvar editorUtils = require('editorUtils');\n\t\tvar info = editorUtils.outputInfo(editor);\n\t\t\n\t\t/** @type Range */\n\t\tvar selection = require('range').create(editor.getSelectionRange());\n\t\tif (!selection.length()) {\n\t\t\t// find matching tag\n\t\t\tvar pair = matcher.find(info.content, editor.getCaretPos());\n\t\t\tif (pair) {\n\t\t\t\tselection = pair.outerRange;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (selection.length()) {\n\t\t\t// got range, merge lines\n\t\t\tvar text =  selection.substring(info.content);\n\t\t\tvar lines = utils.splitByLines(text);\n\t\t\t\n\t\t\tfor (var i = 1; i < lines.length; i++) {\n\t\t\t\tlines[i] = lines[i].replace(/^\\s+/, '');\n\t\t\t}\n\t\t\t\n\t\t\ttext = lines.join('').replace(/\\s{2,}/, ' ');\n\t\t\tvar textLen = text.length;\n\t\t\ttext = utils.escapeText(text);\n\t\t\teditor.replaceContent(text, selection.start, selection.end);\n\t\t\teditor.createSelection(selection.start, selection.start + textLen);\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t});\n});/**\n * Encodes/decodes image under cursor to/from base64\n * @param {IEmmetEditor} editor\n * @since 0.65\n * \n * @memberOf __base64ActionDefine\n * @constructor\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\trequire('actions').add('encode_decode_data_url', function(editor) {\n\t\tvar data = String(editor.getSelection());\n\t\tvar caretPos = editor.getCaretPos();\n\t\t\t\n\t\tif (!data) {\n\t\t\t// no selection, try to find image bounds from current caret position\n\t\t\tvar text = String(editor.getContent()),  m;\n\t\t\twhile (caretPos-- >= 0) {\n\t\t\t\tif (startsWith('src=', text, caretPos)) { // found <img src=\"\">\n\t\t\t\t\tif (m = text.substr(caretPos).match(/^(src=([\"'])?)([^'\"<>\\s]+)\\1?/)) {\n\t\t\t\t\t\tdata = m[3];\n\t\t\t\t\t\tcaretPos += m[1].length;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (startsWith('url(', text, caretPos)) { // found CSS url() pattern\n\t\t\t\t\tif (m = text.substr(caretPos).match(/^(url\\((['\"])?)([^'\"\\)\\s]+)\\1?/)) {\n\t\t\t\t\t\tdata = m[3];\n\t\t\t\t\t\tcaretPos += m[1].length;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (data) {\n\t\t\tif (startsWith('data:', data))\n\t\t\t\treturn decodeFromBase64(editor, data, caretPos);\n\t\t\telse\n\t\t\t\treturn encodeToBase64(editor, data, caretPos);\n\t\t}\n\t\t\n\t\treturn false;\n\t}, {label: 'Encode\\\\Decode data:URL image'});\n\t\n\t/**\n\t * Test if <code>text</code> starts with <code>token</code> at <code>pos</code>\n\t * position. If <code>pos</code> is omitted, search from beginning of text \n\t * @param {String} token Token to test\n\t * @param {String} text Where to search\n\t * @param {Number} pos Position where to start search\n\t * @return {Boolean}\n\t * @since 0.65\n\t */\n\tfunction startsWith(token, text, pos) {\n\t\tpos = pos || 0;\n\t\treturn text.charAt(pos) == token.charAt(0) && text.substr(pos, token.length) == token;\n\t}\n\t\n\t/**\n\t * Encodes image to base64\n\t * \n\t * @param {IEmmetEditor} editor\n\t * @param {String} imgPath Path to image\n\t * @param {Number} pos Caret position where image is located in the editor\n\t * @return {Boolean}\n\t */\n\tfunction encodeToBase64(editor, imgPath, pos) {\n\t\tvar file = require('file');\n\t\tvar actionUtils = require('actionUtils');\n\t\t\n\t\tvar editorFile = editor.getFilePath();\n\t\tvar defaultMimeType = 'application/octet-stream';\n\t\t\t\n\t\tif (editorFile === null) {\n\t\t\tthrow \"You should save your file before using this action\";\n\t\t}\n\t\t\n\t\t// locate real image path\n\t\tvar realImgPath = file.locateFile(editorFile, imgPath);\n\t\tif (realImgPath === null) {\n\t\t\tthrow \"Can't find \" + imgPath + ' file';\n\t\t}\n\t\t\n\t\tfile.read(realImgPath, function(err, content) {\n\t\t\tif (err) {\n\t\t\t\tthrow 'Unable to read ' + realImgPath + ': ' + err;\n\t\t\t}\n\t\t\t\n\t\t\tvar b64 = require('base64').encode(String(content));\n\t\t\tif (!b64) {\n\t\t\t\tthrow \"Can't encode file content to base64\";\n\t\t\t}\n\t\t\t\n\t\t\tb64 = 'data:' + (actionUtils.mimeTypes[String(file.getExt(realImgPath))] || defaultMimeType) +\n\t\t\t\t';base64,' + b64;\n\t\t\t\t\n\t\t\teditor.replaceContent('$0' + b64, pos, pos + imgPath.length);\n\t\t});\n\t\t\n\t\t\n\t\treturn true;\n\t}\n\n\t/**\n\t * Decodes base64 string back to file.\n\t * @param {IEmmetEditor} editor\n\t * @param {String} data Base64-encoded file content\n\t * @param {Number} pos Caret position where image is located in the editor\n\t */\n\tfunction decodeFromBase64(editor, data, pos) {\n\t\t// ask user to enter path to file\n\t\tvar filePath = String(editor.prompt('Enter path to file (absolute or relative)'));\n\t\tif (!filePath)\n\t\t\treturn false;\n\t\t\t\n\t\tvar file = require('file');\n\t\tvar absPath = file.createPath(editor.getFilePath(), filePath);\n\t\tif (!absPath) {\n\t\t\tthrow \"Can't save file\";\n\t\t}\n\t\t\n\t\tfile.save(absPath, require('base64').decode( data.replace(/^data\\:.+?;.+?,/, '') ));\n\t\teditor.replaceContent('$0' + filePath, pos, pos + data.length);\n\t\treturn true;\n\t}\n});\n/**\n * Automatically updates image size attributes in HTML's &lt;img&gt; element or\n * CSS rule\n * @param {Function} require\n * @param {Underscore} _\n * @constructor\n * @memberOf __updateImageSizeAction\n */\nemmet.exec(function(require, _) {\n\t/**\n\t * Updates image size of &lt;img src=\"\"&gt; tag\n\t * @param {IEmmetEditor} editor\n\t */\n\tfunction updateImageSizeHTML(editor) {\n\t\tvar offset = editor.getCaretPos();\n\t\t\n\t\t// find tag from current caret position\n\t\tvar info = require('editorUtils').outputInfo(editor);\n\t\tvar xmlElem = require('xmlEditTree').parseFromPosition(info.content, offset, true);\n\t\tif (xmlElem && (xmlElem.name() || '').toLowerCase() == 'img') {\n\t\t\tgetImageSizeForSource(editor, xmlElem.value('src'), function(size) {\n\t\t\t\tif (size) {\n\t\t\t\t\tvar compoundData = xmlElem.range(true);\n\t\t\t\t\txmlElem.value('width', size.width);\n\t\t\t\t\txmlElem.value('height', size.height, xmlElem.indexOf('width') + 1);\n\t\t\t\t\t\n\t\t\t\t\trequire('actionUtils').compoundUpdate(editor, _.extend(compoundData, {\n\t\t\t\t\t\tdata: xmlElem.toString(),\n\t\t\t\t\t\tcaret: offset\n\t\t\t\t\t}));\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\t\n\t/**\n\t * Updates image size of CSS property\n\t * @param {IEmmetEditor} editor\n\t */\n\tfunction updateImageSizeCSS(editor) {\n\t\tvar offset = editor.getCaretPos();\n\t\t\n\t\t// find tag from current caret position\n\t\tvar info = require('editorUtils').outputInfo(editor);\n\t\tvar cssRule = require('cssEditTree').parseFromPosition(info.content, offset, true);\n\t\tif (cssRule) {\n\t\t\t// check if there is property with image under caret\n\t\t\tvar prop = cssRule.itemFromPosition(offset, true), m;\n\t\t\tif (prop && (m = /url\\(([\"']?)(.+?)\\1\\)/i.exec(prop.value() || ''))) {\n\t\t\t\tgetImageSizeForSource(editor, m[2], function(size) {\n\t\t\t\t\tif (size) {\n\t\t\t\t\t\tvar compoundData = cssRule.range(true);\n\t\t\t\t\t\tcssRule.value('width', size.width + 'px');\n\t\t\t\t\t\tcssRule.value('height', size.height + 'px', cssRule.indexOf('width') + 1);\n\t\t\t\t\t\t\n\t\t\t\t\t\trequire('actionUtils').compoundUpdate(editor, _.extend(compoundData, {\n\t\t\t\t\t\t\tdata: cssRule.toString(),\n\t\t\t\t\t\t\tcaret: offset\n\t\t\t\t\t\t}));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * Returns image dimensions for source\n\t * @param {IEmmetEditor} editor\n\t * @param {String} src Image source (path or data:url)\n\t */\n\tfunction getImageSizeForSource(editor, src, callback) {\n\t\tvar fileContent;\n\t\tvar au = require('actionUtils');\n\t\tif (src) {\n\t\t\t// check if it is data:url\n\t\t\tif (/^data:/.test(src)) {\n\t\t\t\tfileContent = require('base64').decode( src.replace(/^data\\:.+?;.+?,/, '') );\n\t\t\t\treturn callback(au.getImageSize(fileContent));\n\t\t\t}\n\t\t\t\n\t\t\tvar file = require('file');\n\t\t\tvar absPath = file.locateFile(editor.getFilePath(), src);\n\t\t\tif (absPath === null) {\n\t\t\t\tthrow \"Can't find \" + src + ' file';\n\t\t\t}\n\t\t\t\n\t\t\tfile.read(absPath, function(err, content) {\n\t\t\t\tif (err) {\n\t\t\t\t\tthrow 'Unable to read ' + absPath + ': ' + err;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcontent = String(content);\n\t\t\t\tcallback(au.getImageSize(content));\n\t\t\t});\n\t\t}\n\t}\n\t\n\trequire('actions').add('update_image_size', function(editor) {\n\t\t// this action will definitely won’t work in SASS dialect,\n\t\t// but may work in SCSS or LESS\n\t\tif (_.include(['css', 'less', 'scss'], String(editor.getSyntax()))) {\n\t\t\tupdateImageSizeCSS(editor);\n\t\t} else {\n\t\t\tupdateImageSizeHTML(editor);\n\t\t}\n\t\t\n\t\treturn true;\n\t});\n});/**\n * Resolver for fast CSS typing. Handles abbreviations with the following \n * notation:<br>\n * \n * <code>(-vendor prefix)?property(value)*(!)?</code>\n * \n * <br><br>\n * <b>Abbreviation handling</b><br>\n * \n * By default, Emmet searches for matching snippet definition for provided abbreviation.\n * If snippet wasn't found, Emmet automatically generates element with \n * abbreviation's name. For example, <code>foo</code> abbreviation will generate\n * <code>&lt;foo&gt;&lt;/foo&gt;</code> output.\n * <br><br>\n * This module will capture all expanded properties and upgrade them with values, \n * vendor prefixes and !important declarations. All unmatched abbreviations will \n * be automatically transformed into <code>property-name: ${1}</code> snippets. \n * \n * <b>Vendor prefixes<b><br>\n * \n * If CSS-property is preceded with dash, resolver should output property with\n * all <i>known</i> vendor prefixes. For example, if <code>brad</code> \n * abbreviation generates <code>border-radius: ${value};</code> snippet,\n * the <code>-brad</code> abbreviation should generate:\n * <pre><code>\n * -webkit-border-radius: ${value};\n * -moz-border-radius: ${value};\n * border-radius: ${value};\n * </code></pre>\n * Note that <i>o</i> and <i>ms</i> prefixes are omitted since Opera and IE \n * supports unprefixed property.<br><br>\n * \n * Users can also provide an explicit list of one-character prefixes for any\n * CSS property. For example, <code>-wm-float</code> will produce\n * \n * <pre><code>\n * -webkit-float: ${1};\n * -moz-float: ${1};\n * float: ${1};\n * </code></pre>\n * \n * Although this example looks pointless, users can use this feature to write\n * cutting-edge properties implemented by browser vendors recently.  \n * \n * @constructor\n * @memberOf __cssResolverDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.define('cssResolver', function(require, _) {\n\t/** Back-reference to module */\n\tvar module = null;\n\t\n\tvar prefixObj = {\n\t\t/** Real vendor prefix name */\n\t\tprefix: 'emmet',\n\t\t\n\t\t/** \n\t\t * Indicates this prefix is obsolete and should't be used when user \n\t\t * wants to generate all-prefixed properties\n\t\t */\n\t\tobsolete: false,\n\t\t\n\t\t/**\n\t\t * Returns prefixed CSS property name\n\t\t * @param {String} name Unprefixed CSS property\n\t\t */\n\t\ttransformName: function(name) {\n\t\t\treturn '-' + this.prefix + '-' + name;\n\t\t},\n\t\t\n\t\t/**\n\t\t * List of unprefixed CSS properties that supported by \n\t\t * current prefix. This list is used to generate all-prefixed property\n\t\t * @returns {Array} \n\t\t */\n\t\tproperties: function() {\n\t\t\treturn getProperties('css.' + this.prefix + 'Properties') || [];\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if given property is supported by current prefix\n\t\t * @param name\n\t\t */\n\t\tsupports: function(name) {\n\t\t\treturn _.include(this.properties(), name);\n\t\t}\n\t};\n\t\n\t\n\t/** \n\t * List of registered one-character prefixes. Key is a one-character prefix, \n\t * value is an <code>prefixObj</code> object\n\t */\n\tvar vendorPrefixes = {};\n\t\n\tvar defaultValue = '${1};';\n\t\n\t// XXX module preferences\n\tvar prefs = require('preferences');\n\tprefs.define('css.valueSeparator', ': ',\n\t\t\t'Defines a symbol that should be placed between CSS property and ' \n\t\t\t+ 'value when expanding CSS abbreviations.');\n\tprefs.define('css.propertyEnd', ';',\n\t\t\t'Defines a symbol that should be placed at the end of CSS property  ' \n\t\t\t+ 'when expanding CSS abbreviations.');\n\t\n\tprefs.define('stylus.valueSeparator', ' ',\n\t\t\t'Defines a symbol that should be placed between CSS property and ' \n\t\t\t+ 'value when expanding CSS abbreviations in Stylus dialect.');\n\tprefs.define('stylus.propertyEnd', '',\n\t\t\t'Defines a symbol that should be placed at the end of CSS property  ' \n\t\t\t+ 'when expanding CSS abbreviations in Stylus dialect.');\n\t\n\tprefs.define('sass.propertyEnd', '',\n\t\t\t'Defines a symbol that should be placed at the end of CSS property  ' \n\t\t\t+ 'when expanding CSS abbreviations in SASS dialect.');\n\t\n\tprefs.define('css.autoInsertVendorPrefixes', true,\n\t\t\t'Automatically generate vendor-prefixed copies of expanded CSS ' \n\t\t\t+ 'property. By default, Emmet will generate vendor-prefixed '\n\t\t\t+ 'properties only when you put dash before abbreviation ' \n\t\t\t+ '(e.g. <code>-bxsh</code>). With this option enabled, you don’t ' \n\t\t\t+ 'need dashes before abbreviations: Emmet will produce ' \n\t\t\t+ 'vendor-prefixed properties for you.');\n\t\n\tvar descTemplate = _.template('A comma-separated list of CSS properties that may have ' \n\t\t+ '<code><%= vendor %></code> vendor prefix. This list is used to generate '\n\t\t+ 'a list of prefixed properties when expanding <code>-property</code> '\n\t\t+ 'abbreviations. Empty list means that all possible CSS values may ' \n\t\t+ 'have <code><%= vendor %></code> prefix.');\n\t\n\tvar descAddonTemplate = _.template('A comma-separated list of <em>additional</em> CSS properties ' \n\t\t\t+ 'for <code>css.<%= vendor %>Preperties</code> preference. ' \n\t\t\t+ 'You should use this list if you want to add or remove a few CSS ' \n\t\t\t+ 'properties to original set. To add a new property, simply write its name, '\n\t\t\t+ 'to remove it, precede property with hyphen.<br>'\n\t\t\t+ 'For example, to add <em>foo</em> property and remove <em>border-radius</em> one, '\n\t\t\t+ 'the preference value will look like this: <code>foo, -border-radius</code>.');\n\t\n\t// properties list is created from cssFeatures.html file\n\tvar props = {\n\t\t'webkit': 'animation, animation-delay, animation-direction, animation-duration, animation-fill-mode, animation-iteration-count, animation-name, animation-play-state, animation-timing-function, appearance, backface-visibility, background-clip, background-composite, background-origin, background-size, border-fit, border-horizontal-spacing, border-image, border-vertical-spacing, box-align, box-direction, box-flex, box-flex-group, box-lines, box-ordinal-group, box-orient, box-pack, box-reflect, box-shadow, color-correction, column-break-after, column-break-before, column-break-inside, column-count, column-gap, column-rule-color, column-rule-style, column-rule-width, column-span, column-width, dashboard-region, font-smoothing, highlight, hyphenate-character, hyphenate-limit-after, hyphenate-limit-before, hyphens, line-box-contain, line-break, line-clamp, locale, margin-before-collapse, margin-after-collapse, marquee-direction, marquee-increment, marquee-repetition, marquee-style, mask-attachment, mask-box-image, mask-box-image-outset, mask-box-image-repeat, mask-box-image-slice, mask-box-image-source, mask-box-image-width, mask-clip, mask-composite, mask-image, mask-origin, mask-position, mask-repeat, mask-size, nbsp-mode, perspective, perspective-origin, rtl-ordering, text-combine, text-decorations-in-effect, text-emphasis-color, text-emphasis-position, text-emphasis-style, text-fill-color, text-orientation, text-security, text-stroke-color, text-stroke-width, transform, transition, transform-origin, transform-style, transition-delay, transition-duration, transition-property, transition-timing-function, user-drag, user-modify, user-select, writing-mode, svg-shadow, box-sizing, border-radius',\n\t\t'moz': 'animation-delay, animation-direction, animation-duration, animation-fill-mode, animation-iteration-count, animation-name, animation-play-state, animation-timing-function, appearance, backface-visibility, background-inline-policy, binding, border-bottom-colors, border-image, border-left-colors, border-right-colors, border-top-colors, box-align, box-direction, box-flex, box-ordinal-group, box-orient, box-pack, box-shadow, box-sizing, column-count, column-gap, column-rule-color, column-rule-style, column-rule-width, column-width, float-edge, font-feature-settings, font-language-override, force-broken-image-icon, hyphens, image-region, orient, outline-radius-bottomleft, outline-radius-bottomright, outline-radius-topleft, outline-radius-topright, perspective, perspective-origin, stack-sizing, tab-size, text-blink, text-decoration-color, text-decoration-line, text-decoration-style, text-size-adjust, transform, transform-origin, transform-style, transition, transition-delay, transition-duration, transition-property, transition-timing-function, user-focus, user-input, user-modify, user-select, window-shadow, background-clip, border-radius',\n\t\t'ms': 'accelerator, backface-visibility, background-position-x, background-position-y, behavior, block-progression, box-align, box-direction, box-flex, box-line-progression, box-lines, box-ordinal-group, box-orient, box-pack, content-zoom-boundary, content-zoom-boundary-max, content-zoom-boundary-min, content-zoom-chaining, content-zoom-snap, content-zoom-snap-points, content-zoom-snap-type, content-zooming, filter, flow-from, flow-into, font-feature-settings, grid-column, grid-column-align, grid-column-span, grid-columns, grid-layer, grid-row, grid-row-align, grid-row-span, grid-rows, high-contrast-adjust, hyphenate-limit-chars, hyphenate-limit-lines, hyphenate-limit-zone, hyphens, ime-mode, interpolation-mode, layout-flow, layout-grid, layout-grid-char, layout-grid-line, layout-grid-mode, layout-grid-type, line-break, overflow-style, perspective, perspective-origin, perspective-origin-x, perspective-origin-y, scroll-boundary, scroll-boundary-bottom, scroll-boundary-left, scroll-boundary-right, scroll-boundary-top, scroll-chaining, scroll-rails, scroll-snap-points-x, scroll-snap-points-y, scroll-snap-type, scroll-snap-x, scroll-snap-y, scrollbar-arrow-color, scrollbar-base-color, scrollbar-darkshadow-color, scrollbar-face-color, scrollbar-highlight-color, scrollbar-shadow-color, scrollbar-track-color, text-align-last, text-autospace, text-justify, text-kashida-space, text-overflow, text-size-adjust, text-underline-position, touch-action, transform, transform-origin, transform-origin-x, transform-origin-y, transform-origin-z, transform-style, transition, transition-delay, transition-duration, transition-property, transition-timing-function, user-select, word-break, word-wrap, wrap-flow, wrap-margin, wrap-through, writing-mode',\n\t\t'o': 'dashboard-region, animation, animation-delay, animation-direction, animation-duration, animation-fill-mode, animation-iteration-count, animation-name, animation-play-state, animation-timing-function, border-image, link, link-source, object-fit, object-position, tab-size, table-baseline, transform, transform-origin, transition, transition-delay, transition-duration, transition-property, transition-timing-function, accesskey, input-format, input-required, marquee-dir, marquee-loop, marquee-speed, marquee-style'\n\t};\n\t\n\t_.each(props, function(v, k) {\n\t\tprefs.define('css.' + k + 'Properties', v, descTemplate({vendor: k}));\n\t\tprefs.define('css.' + k + 'PropertiesAddon', '', descAddonTemplate({vendor: k}));\n\t});\n\t\n\tprefs.define('css.unitlessProperties', 'z-index, line-height, opacity, font-weight, zoom', \n\t\t\t'The list of properties whose values ​​must not contain units.');\n\t\n\tprefs.define('css.intUnit', 'px', 'Default unit for integer values');\n\tprefs.define('css.floatUnit', 'em', 'Default unit for float values');\n\t\n\tprefs.define('css.keywords', 'auto, inherit', \n\t\t\t'A comma-separated list of valid keywords that can be used in CSS abbreviations.');\n\t\n\tprefs.define('css.keywordAliases', 'a:auto, i:inherit, s:solid, da:dashed, do:dotted, t:transparent', \n\t\t\t'A comma-separated list of keyword aliases, used in CSS abbreviation. '\n\t\t\t+ 'Each alias should be defined as <code>alias:keyword_name</code>.');\n\t\n\tprefs.define('css.unitAliases', 'e:em, p:%, x:ex, r:rem', \n\t\t\t'A comma-separated list of unit aliases, used in CSS abbreviation. '\n\t\t\t+ 'Each alias should be defined as <code>alias:unit_value</code>.');\n\t\n\tprefs.define('css.color.short', true, \n\t\t\t'Should color values like <code>#ffffff</code> be shortened to '\n\t\t\t+ '<code>#fff</code> after abbreviation with color was expanded.');\n\t\n\tprefs.define('css.color.case', 'keep', \n\t\t\t'Letter case of color values generated by abbreviations with color '\n\t\t\t+ '(like <code>c#0</code>). Possible values are <code>upper</code>, '\n\t\t\t+ '<code>lower</code> and <code>keep</code>.');\n\t\n\tprefs.define('css.fuzzySearch', true, \n\t\t\t'Enable fuzzy search among CSS snippet names. When enabled, every ' \n\t\t\t+ '<em>unknown</em> snippet will be scored against available snippet '\n\t\t\t+ 'names (not values or CSS properties!). The match with best score '\n\t\t\t+ 'will be used to resolve snippet value. For example, with this ' \n\t\t\t+ 'preference enabled, the following abbreviations are equal: '\n\t\t\t+ '<code>ov:h</code> == <code>ov-h</code> == <code>o-h</code> == '\n\t\t\t+ '<code>oh</code>');\n\t\n\tprefs.define('css.fuzzySearchMinScore', 0.3, \n\t\t\t'The minium score (from 0 to 1) that fuzzy-matched abbreviation should ' \n\t\t\t+ 'achive. Lower values may produce many false-positive matches, '\n\t\t\t+ 'higher values may reduce possible matches.');\n\t\n\tprefs.define('css.alignVendor', false, \n\t\t\t'If set to <code>true</code>, all generated vendor-prefixed properties ' \n\t\t\t+ 'will be aligned by real property name.');\n\t\n\t\n\tfunction isNumeric(ch) {\n\t\tvar code = ch && ch.charCodeAt(0);\n\t\treturn (ch && ch == '.' || (code > 47 && code < 58));\n\t}\n\t\n\t/**\n\t * Check if provided snippet contains only one CSS property and value.\n\t * @param {String} snippet\n\t * @returns {Boolean}\n\t */\n\tfunction isSingleProperty(snippet) {\n\t\tvar utils = require('utils');\n\t\tsnippet = utils.trim(snippet);\n\t\t\n\t\t// check if it doesn't contain a comment and a newline\n\t\tif (~snippet.indexOf('/*') || /[\\n\\r]/.test(snippet)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t// check if it's a valid snippet definition\n\t\tif (!/^[a-z0-9\\-]+\\s*\\:/i.test(snippet)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tsnippet = require('tabStops').processText(snippet, {\n\t\t\treplaceCarets: true,\n\t\t\ttabstop: function() {\n\t\t\t\treturn 'value';\n\t\t\t}\n\t\t});\n\t\t\n\t\treturn snippet.split(':').length == 2;\n\t}\n\t\n\t/**\n\t * Normalizes abbreviated value to final CSS one\n\t * @param {String} value\n\t * @returns {String}\n\t */\n\tfunction normalizeValue(value) {\n\t\tif (value.charAt(0) == '-' && !/^\\-[\\.\\d]/.test(value)) {\n\t\t\tvalue = value.replace(/^\\-+/, '');\n\t\t}\n\t\t\n\t\tif (value.charAt(0) == '#') {\n\t\t\treturn normalizeHexColor(value);\n\t\t}\n\t\t\n\t\treturn getKeyword(value);\n\t}\n\t\n\tfunction normalizeHexColor(value) {\n\t\tvar hex = value.replace(/^#+/, '') || '0';\n\t\tif (hex.toLowerCase() == 't') {\n\t\t\treturn 'transparent';\n\t\t}\n\t\t\n\t\tvar repeat = require('utils').repeatString;\n\t\tvar color = null;\n\t\tswitch (hex.length) {\n\t\t\tcase 1:\n\t\t\t\tcolor = repeat(hex, 6);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tcolor = repeat(hex, 3);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tcolor = hex.charAt(0) + hex.charAt(0) + hex.charAt(1) + hex.charAt(1) + hex.charAt(2) + hex.charAt(2);\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tcolor = hex + hex.substr(0, 2);\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tcolor = hex + hex.charAt(0);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcolor = hex.substr(0, 6);\n\t\t}\n\t\t\n\t\t// color must be shortened?\n\t\tif (prefs.get('css.color.short')) {\n\t\t\tvar p = color.split('');\n\t\t\tif (p[0] == p[1] && p[2] == p[3] && p[4] == p[5]) {\n\t\t\t\tcolor = p[0] + p[2] + p[4];\n\t\t\t}\n\t\t}\n\t\t\n\t\t// should transform case?\n\t\tswitch (prefs.get('css.color.case')) {\n\t\t\tcase 'upper':\n\t\t\t\tcolor = color.toUpperCase();\n\t\t\t\tbreak;\n\t\t\tcase 'lower':\n\t\t\t\tcolor = color.toLowerCase();\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\treturn '#' + color;\n\t}\n\t\n\tfunction getKeyword(name) {\n\t\tvar aliases = prefs.getDict('css.keywordAliases');\n\t\treturn name in aliases ? aliases[name] : name;\n\t}\n\t\n\tfunction getUnit(name) {\n\t\tvar aliases = prefs.getDict('css.unitAliases');\n\t\treturn name in aliases ? aliases[name] : name;\n\t}\n\t\n\tfunction isValidKeyword(keyword) {\n\t\treturn _.include(prefs.getArray('css.keywords'), getKeyword(keyword));\n\t}\n\t\n\t/**\n\t * Check if passed CSS property support specified vendor prefix \n\t * @param {String} property\n\t * @param {String} prefix\n\t */\n\tfunction hasPrefix(property, prefix) {\n\t\tvar info = vendorPrefixes[prefix];\n\t\t\n\t\tif (!info)\n\t\t\tinfo = _.find(vendorPrefixes, function(data) {\n\t\t\t\treturn data.prefix == prefix;\n\t\t\t});\n\t\t\n\t\treturn info && info.supports(property);\n\t}\n\t\n\t/**\n\t * Search for a list of supported prefixes for CSS property. This list\n\t * is used to generate all-prefixed snippet\n\t * @param {String} property CSS property name\n\t * @returns {Array}\n\t */\n\tfunction findPrefixes(property, noAutofill) {\n\t\tvar result = [];\n\t\t_.each(vendorPrefixes, function(obj, prefix) {\n\t\t\tif (hasPrefix(property, prefix)) {\n\t\t\t\tresult.push(prefix);\n\t\t\t}\n\t\t});\n\t\t\n\t\tif (!result.length && !noAutofill) {\n\t\t\t// add all non-obsolete prefixes\n\t\t\t_.each(vendorPrefixes, function(obj, prefix) {\n\t\t\t\tif (!obj.obsolete)\n\t\t\t\t\tresult.push(prefix);\n\t\t\t});\n\t\t}\n\t\t\n\t\treturn result;\n\t}\n\t\n\tfunction addPrefix(name, obj) {\n\t\tif (_.isString(obj))\n\t\t\tobj = {prefix: obj};\n\t\t\n\t\tvendorPrefixes[name] = _.extend({}, prefixObj, obj);\n\t}\n\t\n\tfunction getSyntaxPreference(name, syntax) {\n\t\tif (syntax) {\n\t\t\tvar val = prefs.get(syntax + '.' + name);\n\t\t\tif (!_.isUndefined(val))\n\t\t\t\treturn val;\n\t\t}\n\t\t\n\t\treturn prefs.get('css.' + name);\n\t}\n\t\n\t/**\n\t * Format CSS property according to current syntax dialect\n\t * @param {String} property\n\t * @param {String} syntax\n\t * @returns {String}\n\t */\n\tfunction formatProperty(property, syntax) {\n\t\tvar ix = property.indexOf(':');\n\t\tproperty = property.substring(0, ix).replace(/\\s+$/, '') \n\t\t\t+ getSyntaxPreference('valueSeparator', syntax)\n\t\t\t+ require('utils').trim(property.substring(ix + 1));\n\t\t\n\t\treturn property.replace(/\\s*;\\s*$/, getSyntaxPreference('propertyEnd', syntax));\n\t}\n\t\n\t/**\n\t * Transforms snippet value if required. For example, this transformation\n\t * may add <i>!important</i> declaration to CSS property\n\t * @param {String} snippet\n\t * @param {Boolean} isImportant\n\t * @returns {String}\n\t */\n\tfunction transformSnippet(snippet, isImportant, syntax) {\n\t\tif (!_.isString(snippet))\n\t\t\tsnippet = snippet.data;\n\t\t\n\t\tif (!isSingleProperty(snippet))\n\t\t\treturn snippet;\n\t\t\n\t\tif (isImportant) {\n\t\t\tif (~snippet.indexOf(';')) {\n\t\t\t\tsnippet = snippet.split(';').join(' !important;');\n\t\t\t} else {\n\t\t\t\tsnippet += ' !important';\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn formatProperty(snippet, syntax);\n\t}\n\t\n\t/**\n\t * Helper function that parses comma-separated list of elements into array\n\t * @param {String} list\n\t * @returns {Array}\n\t */\n\tfunction parseList(list) {\n\t\tvar result = _.map((list || '').split(','), require('utils').trim);\n\t\treturn result.length ? result : null;\n\t}\n\t\n\tfunction getProperties(key) {\n\t\tvar list = prefs.getArray(key);\n\t\t_.each(prefs.getArray(key + 'Addon'), function(prop) {\n\t\t\tif (prop.charAt(0) == '-') {\n\t\t\t\tlist = _.without(list, prop.substr(1));\n\t\t\t} else {\n\t\t\t\tif (prop.charAt(0) == '+')\n\t\t\t\t\tprop = prop.substr(1);\n\t\t\t\t\n\t\t\t\tlist.push(prop);\n\t\t\t}\n\t\t});\n\t\t\n\t\treturn list;\n\t}\n\t\n\t\n\t// TODO refactor, this looks awkward now\n\taddPrefix('w', {\n\t\tprefix: 'webkit'\n\t});\n\taddPrefix('m', {\n\t\tprefix: 'moz'\n\t});\n\taddPrefix('s', {\n\t\tprefix: 'ms'\n\t});\n\taddPrefix('o', {\n\t\tprefix: 'o'\n\t});\n\t\n\t// I think nobody uses it\n//\taddPrefix('k', {\n//\t\tprefix: 'khtml',\n//\t\tobsolete: true\n//\t});\n\t\n\tvar cssSyntaxes = ['css', 'less', 'sass', 'scss', 'stylus'];\n\t\n\t/**\n\t * XXX register resolver\n\t * @param {TreeNode} node\n\t * @param {String} syntax\n\t */\n\trequire('resources').addResolver(function(node, syntax) {\n\t\tif (_.include(cssSyntaxes, syntax) && node.isElement()) {\n\t\t\treturn module.expandToSnippet(node.abbreviation, syntax);\n\t\t}\n\t\t\n\t\treturn null;\n\t});\n\t\n\tvar ea = require('expandAbbreviation');\n\t/**\n\t * For CSS-like syntaxes, we need to handle a special use case. Some editors\n\t * (like Sublime Text 2) may insert semicolons automatically when user types\n\t * abbreviation. After expansion, user receives a double semicolon. This\n\t * handler automatically removes semicolon from generated content in such cases.\n\t * @param {IEmmetEditor} editor\n\t * @param {String} syntax\n\t * @param {String} profile\n\t */\n\tea.addHandler(function(editor, syntax, profile) {\n\t\tif (!_.include(cssSyntaxes, syntax)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tvar caretPos = editor.getSelectionRange().end;\n\t\tvar abbr = ea.findAbbreviation(editor);\n\t\t\t\n\t\tif (abbr) {\n\t\t\tvar content = emmet.expandAbbreviation(abbr, syntax, profile);\n\t\t\tif (content) {\n\t\t\t\tvar replaceFrom = caretPos - abbr.length;\n\t\t\t\tvar replaceTo = caretPos;\n\t\t\t\tif (editor.getContent().charAt(caretPos) == ';' && content.charAt(content.length - 1) == ';') {\n\t\t\t\t\treplaceTo++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\teditor.replaceContent(content, replaceFrom, replaceTo);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t});\n\t\n\treturn module = {\n\t\t/**\n\t\t * Adds vendor prefix\n\t\t * @param {String} name One-character prefix name\n\t\t * @param {Object} obj Object describing vendor prefix\n\t\t * @memberOf cssResolver\n\t\t */\n\t\taddPrefix: addPrefix,\n\t\t\n\t\t/**\n\t\t * Check if passed CSS property supports specified vendor prefix\n\t\t * @param {String} property\n\t\t * @param {String} prefix\n\t\t */\n\t\tsupportsPrefix: hasPrefix,\n\t\t\n\t\t/**\n\t\t * Returns prefixed version of passed CSS property, only if this\n\t\t * property supports such prefix\n\t\t * @param {String} property\n\t\t * @param {String} prefix\n\t\t * @returns\n\t\t */\n\t\tprefixed: function(property, prefix) {\n\t\t\treturn hasPrefix(property, prefix) \n\t\t\t\t? '-' + prefix + '-' + property \n\t\t\t\t: property;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns list of all registered vendor prefixes\n\t\t * @returns {Array}\n\t\t */\n\t\tlistPrefixes: function() {\n\t\t\treturn _.map(vendorPrefixes, function(obj) {\n\t\t\t\treturn obj.prefix;\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns object describing vendor prefix\n\t\t * @param {String} name\n\t\t * @returns {Object}\n\t\t */\n\t\tgetPrefix: function(name) {\n\t\t\treturn vendorPrefixes[name];\n\t\t},\n\t\t\n\t\t/**\n\t\t * Removes prefix object\n\t\t * @param {String} name\n\t\t */\n\t\tremovePrefix: function(name) {\n\t\t\tif (name in vendorPrefixes)\n\t\t\t\tdelete vendorPrefixes[name];\n\t\t},\n\t\t\n\t\t/**\n\t\t * Extract vendor prefixes from abbreviation\n\t\t * @param {String} abbr\n\t\t * @returns {Object} Object containing array of prefixes and clean \n\t\t * abbreviation name\n\t\t */\n\t\textractPrefixes: function(abbr) {\n\t\t\tif (abbr.charAt(0) != '-') {\n\t\t\t\treturn {\n\t\t\t\t\tproperty: abbr,\n\t\t\t\t\tprefixes: null\n\t\t\t\t};\n\t\t\t}\n\t\t\t\n\t\t\t// abbreviation may either contain sequence of one-character prefixes\n\t\t\t// or just dash, meaning that user wants to produce all possible\n\t\t\t// prefixed properties\n\t\t\tvar i = 1, il = abbr.length, ch;\n\t\t\tvar prefixes = [];\n\t\t\t\n\t\t\twhile (i < il) {\n\t\t\t\tch = abbr.charAt(i);\n\t\t\t\tif (ch == '-') {\n\t\t\t\t\t// end-sequence character found, stop searching\n\t\t\t\t\ti++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (ch in vendorPrefixes) {\n\t\t\t\t\tprefixes.push(ch);\n\t\t\t\t} else {\n\t\t\t\t\t// no prefix found, meaning user want to produce all\n\t\t\t\t\t// vendor-prefixed properties\n\t\t\t\t\tprefixes.length = 0;\n\t\t\t\t\ti = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ti++;\n\t\t\t}\n\t\t\t\n\t\t\t// reached end of abbreviation and no property name left\n\t\t\tif (i == il -1) {\n\t\t\t\ti = 1;\n\t\t\t\tprefixes.length = 1;\n\t\t\t}\n\t\t\t\n\t\t\treturn {\n\t\t\t\tproperty: abbr.substring(i),\n\t\t\t\tprefixes: prefixes.length ? prefixes : 'all'\n\t\t\t};\n\t\t},\n\t\t\n\t\t/**\n\t\t * Search for value substring in abbreviation\n\t\t * @param {String} abbr\n\t\t * @returns {String} Value substring\n\t\t */\n\t\tfindValuesInAbbreviation: function(abbr, syntax) {\n\t\t\tsyntax = syntax || 'css';\n\t\t\t\n\t\t\tvar i = 0, il = abbr.length, value = '', ch;\n\t\t\twhile (i < il) {\n\t\t\t\tch = abbr.charAt(i);\n\t\t\t\tif (isNumeric(ch) || ch == '#' || (ch == '-' && isNumeric(abbr.charAt(i + 1)))) {\n\t\t\t\t\tvalue = abbr.substring(i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ti++;\n\t\t\t}\n\t\t\t\n\t\t\t// try to find keywords in abbreviation\n\t\t\tvar property = abbr.substring(0, abbr.length - value.length);\n\t\t\tvar res = require('resources');\n\t\t\tvar keywords = [];\n\t\t\t// try to extract some commonly-used properties\n\t\t\twhile (~property.indexOf('-') && !res.findSnippet(syntax, property)) {\n\t\t\t\tvar parts = property.split('-');\n\t\t\t\tvar lastPart = parts.pop();\n\t\t\t\tif (!isValidKeyword(lastPart)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tkeywords.unshift(lastPart);\n\t\t\t\tproperty = parts.join('-');\n\t\t\t}\n\t\t\t\n\t\t\treturn keywords.join('-') + value;\n\t\t},\n\t\t\n\t\tparseValues: function(str) {\n\t\t\t/** @type StringStream */\n\t\t\tvar stream = require('stringStream').create(str);\n\t\t\tvar values = [];\n\t\t\tvar ch = null;\n\t\t\t\n\t\t\twhile (ch = stream.next()) {\n\t\t\t\tif (ch == '#') {\n\t\t\t\t\tstream.match(/^t|[0-9a-f]+/i, true);\n\t\t\t\t\tvalues.push(stream.current());\n\t\t\t\t} else if (ch == '-') {\n\t\t\t\t\tif (isValidKeyword(_.last(values)) || \n\t\t\t\t\t\t\t( stream.start && isNumeric(str.charAt(stream.start - 1)) )\n\t\t\t\t\t\t) {\n\t\t\t\t\t\tstream.start = stream.pos;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tstream.match(/^\\-?[0-9]*(\\.[0-9]+)?[a-z%\\.]*/, true);\n\t\t\t\t\tvalues.push(stream.current());\n\t\t\t\t} else {\n\t\t\t\t\tstream.match(/^[0-9]*(\\.[0-9]*)?[a-z%]*/, true);\n\t\t\t\t\tvalues.push(stream.current());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tstream.start = stream.pos;\n\t\t\t}\n\t\t\t\n\t\t\treturn _.map(_.compact(values), normalizeValue);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Extracts values from abbreviation\n\t\t * @param {String} abbr\n\t\t * @returns {Object} Object containing array of values and clean \n\t\t * abbreviation name\n\t\t */\n\t\textractValues: function(abbr) {\n\t\t\t// search for value start\n\t\t\tvar abbrValues = this.findValuesInAbbreviation(abbr);\n\t\t\tif (!abbrValues) {\n\t\t\t\treturn {\n\t\t\t\t\tproperty: abbr,\n\t\t\t\t\tvalues: null\n\t\t\t\t};\n\t\t\t}\n\t\t\t\n\t\t\treturn {\n\t\t\t\tproperty: abbr.substring(0, abbr.length - abbrValues.length).replace(/-$/, ''),\n\t\t\t\tvalues: this.parseValues(abbrValues)\n\t\t\t};\n\t\t},\n\t\t\n\t\t/**\n\t\t * Normalizes value, defined in abbreviation.\n\t\t * @param {String} value\n\t\t * @param {String} property\n\t\t * @returns {String}\n\t\t */\n\t\tnormalizeValue: function(value, property) {\n\t\t\tproperty = (property || '').toLowerCase();\n\t\t\tvar unitlessProps = prefs.getArray('css.unitlessProperties');\n\t\t\treturn value.replace(/^(\\-?[0-9\\.]+)([a-z]*)$/, function(str, val, unit) {\n\t\t\t\tif (!unit && (val == '0' || _.include(unitlessProps, property)))\n\t\t\t\t\treturn val;\n\t\t\t\t\n\t\t\t\tif (!unit)\n\t\t\t\t\treturn val.replace(/\\.$/, '') + prefs.get(~val.indexOf('.') ? 'css.floatUnit' : 'css.intUnit');\n\t\t\t\t\n\t\t\t\treturn val + getUnit(unit);\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Expands abbreviation into a snippet\n\t\t * @param {String} abbr Abbreviation name to expand\n\t\t * @param {String} value Abbreviation value\n\t\t * @param {String} syntax Currect syntax or dialect. Default is 'css'\n\t\t * @returns {Object} Array of CSS properties and values or predefined\n\t\t * snippet (string or element)\n\t\t */\n\t\texpand: function(abbr, value, syntax) {\n\t\t\tsyntax = syntax || 'css';\n\t\t\tvar resources = require('resources');\n\t\t\tvar autoInsertPrefixes = prefs.get('css.autoInsertVendorPrefixes');\n\t\t\t\n\t\t\t// check if snippet should be transformed to !important\n\t\t\tvar isImportant;\n\t\t\tif (isImportant = /^(.+)\\!$/.test(abbr)) {\n\t\t\t\tabbr = RegExp.$1;\n\t\t\t}\n\t\t\t\n\t\t\t// check if we have abbreviated resource\n\t\t\tvar snippet = resources.findSnippet(syntax, abbr);\n\t\t\tif (snippet && !autoInsertPrefixes) {\n\t\t\t\treturn transformSnippet(snippet, isImportant, syntax);\n\t\t\t}\n\t\t\t\n\t\t\t// no abbreviated resource, parse abbreviation\n\t\t\tvar prefixData = this.extractPrefixes(abbr);\n\t\t\tvar valuesData = this.extractValues(prefixData.property);\n\t\t\tvar abbrData = _.extend(prefixData, valuesData);\n\t\t\t\n\t\t\tif (!snippet) {\n\t\t\t\tsnippet = resources.findSnippet(syntax, abbrData.property);\n\t\t\t} else {\n\t\t\t\tabbrData.values = null;\n\t\t\t}\n\t\t\t\n\t\t\tif (!snippet && prefs.get('css.fuzzySearch')) {\n\t\t\t\t// let’s try fuzzy search\n\t\t\t\tsnippet = resources.fuzzyFindSnippet(syntax, abbrData.property, parseFloat(prefs.get('css.fuzzySearchMinScore')));\n\t\t\t}\n\t\t\t\n\t\t\tif (!snippet) {\n\t\t\t\tsnippet = abbrData.property + ':' + defaultValue;\n\t\t\t} else if (!_.isString(snippet)) {\n\t\t\t\tsnippet = snippet.data;\n\t\t\t}\n\t\t\t\n\t\t\tif (!isSingleProperty(snippet)) {\n\t\t\t\treturn snippet;\n\t\t\t}\n\t\t\t\n\t\t\tvar snippetObj = this.splitSnippet(snippet);\n\t\t\tvar result = [];\n\t\t\tif (!value && abbrData.values) {\n\t\t\t\tvalue = _.map(abbrData.values, function(val) {\n\t\t\t\t\treturn this.normalizeValue(val, snippetObj.name);\n\t\t\t\t}, this).join(' ') + ';';\n\t\t\t}\n\t\t\t\n\t\t\tsnippetObj.value = value || snippetObj.value;\n\t\t\t\n\t\t\tvar prefixes = abbrData.prefixes == 'all' || (!abbrData.prefixes && autoInsertPrefixes) \n\t\t\t\t? findPrefixes(snippetObj.name, autoInsertPrefixes && abbrData.prefixes != 'all')\n\t\t\t\t: abbrData.prefixes;\n\t\t\t\t\n\t\t\t\t\n\t\t\tvar names = [], propName;\n\t\t\t_.each(prefixes, function(p) {\n\t\t\t\tif (p in vendorPrefixes) {\n\t\t\t\t\tpropName = vendorPrefixes[p].transformName(snippetObj.name);\n\t\t\t\t\tnames.push(propName);\n\t\t\t\t\tresult.push(transformSnippet(propName + ':' + snippetObj.value,\n\t\t\t\t\t\t\tisImportant, syntax));\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\t// put the original property\n\t\t\tresult.push(transformSnippet(snippetObj.name + ':' + snippetObj.value, isImportant, syntax));\n\t\t\tnames.push(snippetObj.name);\n\t\t\t\n\t\t\tif (prefs.get('css.alignVendor')) {\n\t\t\t\tvar pads = require('utils').getStringsPads(names);\n\t\t\t\tresult = _.map(result, function(prop, i) {\n\t\t\t\t\treturn pads[i] + prop;\n\t\t\t\t});\n\t\t\t}\n\t\t\t\n\t\t\treturn result;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Same as <code>expand</code> method but transforms output into \n\t\t * Emmet snippet\n\t\t * @param {String} abbr\n\t\t * @param {String} syntax\n\t\t * @returns {String}\n\t\t */\n\t\texpandToSnippet: function(abbr, syntax) {\n\t\t\tvar snippet = this.expand(abbr, null, syntax);\n\t\t\tif (_.isArray(snippet)) {\n\t\t\t\treturn snippet.join('\\n');\n\t\t\t}\n\t\t\t\n\t\t\tif (!_.isString(snippet))\n\t\t\t\treturn snippet.data;\n\t\t\t\n\t\t\treturn String(snippet);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Split snippet into a CSS property-value pair\n\t\t * @param {String} snippet\n\t\t */\n\t\tsplitSnippet: function(snippet) {\n\t\t\tvar utils = require('utils');\n\t\t\tsnippet = utils.trim(snippet);\n\t\t\tif (snippet.indexOf(':') == -1) {\n\t\t\t\treturn {\n\t\t\t\t\tname: snippet,\n\t\t\t\t\tvalue: defaultValue\n\t\t\t\t};\n\t\t\t}\n\t\t\t\n\t\t\tvar pair = snippet.split(':');\n\t\t\t\n\t\t\treturn {\n\t\t\t\tname: utils.trim(pair.shift()),\n\t\t\t\t// replace ${0} tabstop to produce valid vendor-prefixed values\n\t\t\t\t// where possible\n\t\t\t\tvalue: utils.trim(pair.join(':')).replace(/^(\\$\\{0\\}|\\$0)(\\s*;?)$/, '${1}$2')\n\t\t\t};\n\t\t},\n\t\t\n\t\tgetSyntaxPreference: getSyntaxPreference,\n\t\ttransformSnippet: transformSnippet\n\t};\n});\n/**\n * 'Expand Abbreviation' handler that parses gradient definition from under \n * cursor and updates CSS rule with vendor-prefixed values.\n * \n * @memberOf __cssGradientHandlerDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.define('cssGradient', function(require, _) {\n\tvar defaultLinearDirections = ['top', 'to bottom', '0deg'];\n\t/** Back-reference to current module */\n\tvar module = null;\n\t\n\tvar cssSyntaxes = ['css', 'less', 'sass', 'scss', 'stylus', 'styl'];\n\t\n\tvar reDeg = /\\d+deg/i;\n\tvar reKeyword = /top|bottom|left|right/i;\n\t\n\t// XXX define preferences\n\t/** @type preferences */\n\tvar prefs = require('preferences');\n\tprefs.define('css.gradient.prefixes', 'webkit, moz, o',\n\t\t\t'A comma-separated list of vendor-prefixes for which values should ' \n\t\t\t+ 'be generated.');\n\t\n\tprefs.define('css.gradient.oldWebkit', true,\n\t\t\t'Generate gradient definition for old Webkit implementations');\n\t\n\tprefs.define('css.gradient.omitDefaultDirection', true,\n\t\t'Do not output default direction definition in generated gradients.');\n\t\n\tprefs.define('css.gradient.defaultProperty', 'background-image',\n\t\t'When gradient expanded outside CSS value context, it will produce '\n\t\t\t+ 'properties with this name.');\n\t\n\tprefs.define('css.gradient.fallback', false,\n\t\t\t'With this option enabled, CSS gradient generator will produce '\n\t\t\t+ '<code>background-color</code> property with gradient first color '\n\t\t\t+ 'as fallback for old browsers.');\n\t\n\tfunction normalizeSpace(str) {\n\t\treturn require('utils').trim(str).replace(/\\s+/g, ' ');\n\t}\n\t\n\t/**\n\t * Parses linear gradient definition\n\t * @param {String}\n\t */\n\tfunction parseLinearGradient(gradient) {\n\t\tvar direction = defaultLinearDirections[0];\n\t\t\n\t\t// extract tokens\n\t\t/** @type StringStream */\n\t\tvar stream = require('stringStream').create(require('utils').trim(gradient));\n\t\tvar colorStops = [], ch;\n\t\twhile (ch = stream.next()) {\n\t\t\tif (stream.peek() == ',') {\n\t\t\t\tcolorStops.push(stream.current());\n\t\t\t\tstream.next();\n\t\t\t\tstream.eatSpace();\n\t\t\t\tstream.start = stream.pos;\n\t\t\t} else if (ch == '(') { // color definition, like 'rgb(0,0,0)'\n\t\t\t\tstream.skipTo(')');\n\t\t\t}\n\t\t}\n\t\t\n\t\t// add last token\n\t\tcolorStops.push(stream.current());\n\t\tcolorStops = _.compact(_.map(colorStops, normalizeSpace));\n\t\t\n\t\tif (!colorStops.length)\n\t\t\treturn null;\n\t\t\n\t\t// let's see if the first color stop is actually a direction\n\t\tif (reDeg.test(colorStops[0]) || reKeyword.test(colorStops[0])) {\n\t\t\tdirection = colorStops.shift();\n\t\t}\n\t\t\n\t\treturn {\n\t\t\ttype: 'linear',\n\t\t\tdirection: direction,\n\t\t\tcolorStops: _.map(colorStops, parseColorStop)\n\t\t};\n\t}\n\t\n\t/**\n\t * Parses color stop definition\n\t * @param {String} colorStop\n\t * @returns {Object}\n\t */\n\tfunction parseColorStop(colorStop) {\n\t\tcolorStop = normalizeSpace(colorStop);\n\t\t\n\t\t// find color declaration\n\t\t// first, try complex color declaration, like rgb(0,0,0)\n\t\tvar color = null;\n\t\tcolorStop = colorStop.replace(/^(\\w+\\(.+?\\))\\s*/, function(str, c) {\n\t\t\tcolor = c;\n\t\t\treturn '';\n\t\t});\n\t\t\n\t\tif (!color) {\n\t\t\t// try simple declaration, like yellow, #fco, #ffffff, etc.\n\t\t\tvar parts = colorStop.split(' ');\n\t\t\tcolor = parts[0];\n\t\t\tcolorStop = parts[1] || '';\n\t\t}\n\t\t\n\t\tvar result = {\n\t\t\tcolor: color\n\t\t};\n\t\t\n\t\tif (colorStop) {\n\t\t\t// there's position in color stop definition\n\t\t\tcolorStop.replace(/^(\\-?[\\d\\.]+)([a-z%]+)?$/, function(str, pos, unit) {\n\t\t\t\tresult.position = pos;\n\t\t\t\tif (~pos.indexOf('.')) {\n\t\t\t\t\tunit = '';\n\t\t\t\t} else if (!unit) {\n\t\t\t\t\tunit = '%';\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (unit)\n\t\t\t\t\tresult.unit = unit;\n\t\t\t});\n\t\t}\n\t\t\n\t\treturn result;\n\t}\n\t\n\t/**\n\t * Resolves property name (abbreviation): searches for snippet definition in \n\t * 'resources' and returns new name of matched property\n\t */\n\tfunction resolvePropertyName(name, syntax) {\n\t\tvar res = require('resources');\n\t\tvar prefs = require('preferences');\n\t\tvar snippet = res.findSnippet(syntax, name);\n\t\t\n\t\tif (!snippet && prefs.get('css.fuzzySearch')) {\n\t\t\tsnippet = res.fuzzyFindSnippet(syntax, name, \n\t\t\t\t\tparseFloat(prefs.get('css.fuzzySearchMinScore')));\n\t\t}\n\t\t\n\t\tif (snippet) {\n\t\t\tif (!_.isString(snippet)) {\n\t\t\t\tsnippet = snippet.data;\n\t\t\t}\n\t\t\t\n\t\t\treturn require('cssResolver').splitSnippet(snippet).name;\n\t\t}\n\t}\n\t\n\t/**\n\t * Fills-out implied positions in color-stops. This function is useful for\n\t * old Webkit gradient definitions\n\t */\n\tfunction fillImpliedPositions(colorStops) {\n\t\tvar from = 0;\n\t\t\n\t\t_.each(colorStops, function(cs, i) {\n\t\t\t// make sure that first and last positions are defined\n\t\t\tif (!i)\n\t\t\t\treturn cs.position = cs.position || 0;\n\t\t\t\n\t\t\tif (i == colorStops.length - 1 && !('position' in cs))\n\t\t\t\tcs.position = 1;\n\t\t\t\n\t\t\tif ('position' in cs) {\n\t\t\t\tvar start = colorStops[from].position || 0;\n\t\t\t\tvar step = (cs.position - start) / (i - from);\n\t\t\t\t_.each(colorStops.slice(from, i), function(cs2, j) {\n\t\t\t\t\tcs2.position = start + step * j;\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tfrom = i;\n\t\t\t}\n\t\t});\n\t}\n\t\n\t/**\n\t * Returns textual version of direction expressed in degrees\n\t * @param {String} direction\n\t * @returns {String}\n\t */\n\tfunction textualDirection(direction) {\n\t\tvar angle = parseFloat(direction);\n\t\t\n\t\tif(!_.isNaN(angle)) {\n\t\t\tswitch(angle % 360) {\n\t\t\t\tcase 0:   return 'left';\n\t\t\t\tcase 90:  return 'bottom';\n\t\t\t\tcase 180: return 'right';\n\t\t\t\tcase 240: return 'top';\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn direction;\n\t}\n\t\n\t/**\n\t * Creates direction definition for old Webkit gradients\n\t * @param {String} direction\n\t * @returns {String}\n\t */\n\tfunction oldWebkitDirection(direction) {\n\t\tdirection = textualDirection(direction);\n\t\t\n\t\tif(reDeg.test(direction))\n\t\t\tthrow \"The direction is an angle that can’t be converted.\";\n\t\t\n\t\tvar v = function(pos) {\n\t\t\treturn ~direction.indexOf(pos) ? '100%' : '0';\n\t\t};\n\t\t\n\t\treturn v('right') + ' ' + v('bottom') + ', ' + v('left') + ' ' + v('top');\n\t}\n\t\n\tfunction getPrefixedNames(name) {\n\t\tvar prefixes = prefs.getArray('css.gradient.prefixes');\n\t\tvar names = prefixes \n\t\t\t? _.map(prefixes, function(p) {\n\t\t\t\treturn '-' + p + '-' + name;\n\t\t\t}) \n\t\t\t: [];\n\t\t\n\t\tnames.push(name);\n\t\t\n\t\treturn names;\n\t}\n\t\n\t/**\n\t * Returns list of CSS properties with gradient\n\t * @param {Object} gradient\n\t * @param {String} propertyName Original CSS property name\n\t * @returns {Array}\n\t */\n\tfunction getPropertiesForGradient(gradient, propertyName) {\n\t\tvar props = [];\n\t\tvar css = require('cssResolver');\n\t\t\n\t\tif (prefs.get('css.gradient.fallback') && ~propertyName.toLowerCase().indexOf('background')) {\n\t\t\tprops.push({\n\t\t\t\tname: 'background-color',\n\t\t\t\tvalue: '${1:' + gradient.colorStops[0].color + '}'\n\t\t\t});\n\t\t}\n\t\t\n\t\t_.each(prefs.getArray('css.gradient.prefixes'), function(prefix) {\n\t\t\tvar name = css.prefixed(propertyName, prefix);\n\t\t\tif (prefix == 'webkit' && prefs.get('css.gradient.oldWebkit')) {\n\t\t\t\ttry {\n\t\t\t\t\tprops.push({\n\t\t\t\t\t\tname: name,\n\t\t\t\t\t\tvalue: module.oldWebkitLinearGradient(gradient)\n\t\t\t\t\t});\n\t\t\t\t} catch(e) {}\n\t\t\t}\n\t\t\t\n\t\t\tprops.push({\n\t\t\t\tname: name,\n\t\t\t\tvalue: module.toString(gradient, prefix)\n\t\t\t});\n\t\t});\n\t\t\n\t\treturn props.sort(function(a, b) {\n\t\t\treturn b.name.length - a.name.length;\n\t\t});\n\t}\n\t\n\t/**\n\t * Pastes gradient definition into CSS rule with correct vendor-prefixes\n\t * @param {EditElement} property Matched CSS property\n\t * @param {Object} gradient Parsed gradient\n\t * @param {Range} valueRange If passed, only this range within property \n\t * value will be replaced with gradient. Otherwise, full value will be \n\t * replaced\n\t */\n\tfunction pasteGradient(property, gradient, valueRange) {\n\t\tvar rule = property.parent;\n\t\tvar utils = require('utils');\n\t\tvar alignVendor = require('preferences').get('css.alignVendor');\n\t\t\n\t\t// we may have aligned gradient definitions: find the smallest value\n\t\t// separator\n\t\tvar sep = property.styleSeparator;\n\t\tvar before = property.styleBefore;\n\t\t\n\t\t// first, remove all properties within CSS rule with the same name and\n\t\t// gradient definition\n\t\t_.each(rule.getAll(getPrefixedNames(property.name())), function(item) {\n\t\t\tif (item != property && /gradient/i.test(item.value())) {\n\t\t\t\tif (item.styleSeparator.length < sep.length) {\n\t\t\t\t\tsep = item.styleSeparator;\n\t\t\t\t}\n\t\t\t\tif (item.styleBefore.length < before.length) {\n\t\t\t\t\tbefore = item.styleBefore;\n\t\t\t\t}\n\t\t\t\trule.remove(item);\n\t\t\t}\n\t\t});\n\t\t\n\t\tif (alignVendor) {\n\t\t\t// update prefix\n\t\t\tif (before != property.styleBefore) {\n\t\t\t\tvar fullRange = property.fullRange();\n\t\t\t\trule._updateSource(before, fullRange.start, fullRange.start + property.styleBefore.length);\n\t\t\t\tproperty.styleBefore = before;\n\t\t\t}\n\t\t\t\n\t\t\t// update separator value\n\t\t\tif (sep != property.styleSeparator) {\n\t\t\t\trule._updateSource(sep, property.nameRange().end, property.valueRange().start);\n\t\t\t\tproperty.styleSeparator = sep;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar value = property.value();\n\t\tif (!valueRange)\n\t\t\tvalueRange = require('range').create(0, property.value());\n\t\t\n\t\tvar val = function(v) {\n\t\t\treturn utils.replaceSubstring(value, v, valueRange);\n\t\t};\n\t\t\n\t\t// put vanilla-clean gradient definition into current rule\n\t\tproperty.value(val(module.toString(gradient)) + '${2}');\n\t\t\n\t\t// create list of properties to insert\n\t\tvar propsToInsert = getPropertiesForGradient(gradient, property.name());\n\t\t\n\t\t// align prefixed values\n\t\tif (alignVendor) {\n\t\t\tvar values = _.pluck(propsToInsert, 'value');\n\t\t\tvar names = _.pluck(propsToInsert, 'name');\n\t\t\tvalues.push(property.value());\n\t\t\tnames.push(property.name());\n\t\t\t\n\t\t\tvar valuePads = utils.getStringsPads(_.map(values, function(v) {\n\t\t\t\treturn v.substring(0, v.indexOf('('));\n\t\t\t}));\n\t\t\t\n\t\t\tvar namePads = utils.getStringsPads(names);\n\t\t\tproperty.name(_.last(namePads) + property.name());\n\t\t\t\n\t\t\t_.each(propsToInsert, function(prop, i) {\n\t\t\t\tprop.name = namePads[i] + prop.name;\n\t\t\t\tprop.value = valuePads[i] + prop.value;\n\t\t\t});\n\t\t\t\n\t\t\tproperty.value(_.last(valuePads) + property.value());\n\t\t}\n\t\t\n\t\t// put vendor-prefixed definitions before current rule\n\t\t_.each(propsToInsert, function(prop) {\n\t\t\trule.add(prop.name, prop.value, rule.indexOf(property));\n\t\t});\n\t}\n\t\n\t/**\n\t * Search for gradient definition inside CSS property value\n\t */\n\tfunction findGradient(cssProp) {\n\t\tvar value = cssProp.value();\n\t\tvar gradient = null;\n\t\tvar matchedPart = _.find(cssProp.valueParts(), function(part) {\n\t\t\treturn gradient = module.parse(part.substring(value));\n\t\t});\n\t\t\n\t\tif (matchedPart && gradient) {\n\t\t\treturn {\n\t\t\t\tgradient: gradient,\n\t\t\t\tvalueRange: matchedPart\n\t\t\t};\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\t\n\t/**\n\t * Tries to expand gradient outside CSS value \n\t * @param {IEmmetEditor} editor\n\t * @param {String} syntax\n\t */\n\tfunction expandGradientOutsideValue(editor, syntax) {\n\t\tvar propertyName = prefs.get('css.gradient.defaultProperty');\n\t\t\n\t\tif (!propertyName)\n\t\t\treturn false;\n\t\t\n\t\t// assuming that gradient definition is written on new line,\n\t\t// do a simplified parsing\n\t\tvar content = String(editor.getContent());\n\t\t/** @type Range */\n\t\tvar lineRange = require('range').create(editor.getCurrentLineRange());\n\t\t\n\t\t// get line content and adjust range with padding\n\t\tvar line = lineRange.substring(content)\n\t\t\t.replace(/^\\s+/, function(pad) {\n\t\t\t\tlineRange.start += pad.length;\n\t\t\t\treturn '';\n\t\t\t})\n\t\t\t.replace(/\\s+$/, function(pad) {\n\t\t\t\tlineRange.end -= pad.length;\n\t\t\t\treturn '';\n\t\t\t});\n\t\t\n\t\tvar css = require('cssResolver');\n\t\tvar gradient = module.parse(line);\n\t\tif (gradient) {\n\t\t\tvar props = getPropertiesForGradient(gradient, propertyName);\n\t\t\tprops.push({\n\t\t\t\tname: propertyName,\n\t\t\t\tvalue: module.toString(gradient) + '${2}'\n\t\t\t});\n\t\t\t\n\t\t\tvar sep = css.getSyntaxPreference('valueSeparator', syntax);\n\t\t\tvar end = css.getSyntaxPreference('propertyEnd', syntax);\n\t\t\t\n\t\t\tif (require('preferences').get('css.alignVendor')) {\n\t\t\t\tvar pads = require('utils').getStringsPads(_.map(props, function(prop) {\n\t\t\t\t\treturn prop.value.substring(0, prop.value.indexOf('('));\n\t\t\t\t}));\n\t\t\t\t_.each(props, function(prop, i) {\n\t\t\t\t\tprop.value = pads[i] + prop.value;\n\t\t\t\t});\n\t\t\t}\n\t\t\t\n\t\t\tprops = _.map(props, function(item) {\n\t\t\t\treturn item.name + sep + item.value + end;\n\t\t\t});\n\t\t\t\n\t\t\teditor.replaceContent(props.join('\\n'), lineRange.start, lineRange.end);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * Search for gradient definition inside CSS value under cursor\n\t * @param {String} content\n\t * @param {Number} pos\n\t * @returns {Object}\n\t */\n\tfunction findGradientFromPosition(content, pos) {\n\t\tvar cssProp = null;\n\t\t/** @type EditContainer */\n\t\tvar cssRule = require('cssEditTree').parseFromPosition(content, pos, true);\n\t\t\n\t\tif (cssRule) {\n\t\t\tcssProp = cssRule.itemFromPosition(pos, true);\n\t\t\tif (!cssProp) {\n\t\t\t\t// in case user just started writing CSS property\n\t\t\t\t// and didn't include semicolon–try another approach\n\t\t\t\tcssProp = _.find(cssRule.list(), function(elem) {\n\t\t\t\t\treturn elem.range(true).end == pos;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn {\n\t\t\trule: cssRule,\n\t\t\tproperty: cssProp\n\t\t};\n\t}\n\t\n\t// XXX register expand abbreviation handler\n\t/**\n\t * @param {IEmmetEditor} editor\n\t * @param {String} syntax\n\t * @param {String} profile\n\t */\n\trequire('expandAbbreviation').addHandler(function(editor, syntax, profile) {\n\t\tvar info = require('editorUtils').outputInfo(editor, syntax, profile);\n\t\tif (!_.include(cssSyntaxes, info.syntax))\n\t\t\treturn false;\n\t\t\n\t\t// let's see if we are expanding gradient definition\n\t\tvar caret = editor.getCaretPos();\n\t\tvar content = info.content;\n\t\tvar css = findGradientFromPosition(content, caret);\n\t\t\n\t\tif (css.property) {\n\t\t\t// make sure that caret is inside property value with gradient \n\t\t\t// definition\n\t\t\tvar g = findGradient(css.property);\n\t\t\tif (g) {\n\t\t\t\tvar ruleStart = css.rule.options.offset || 0;\n\t\t\t\tvar ruleEnd = ruleStart + css.rule.toString().length;\n\t\t\t\t\n\t\t\t\t// Handle special case:\n\t\t\t\t// user wrote gradient definition between existing CSS \n\t\t\t\t// properties and did not finished it with semicolon.\n\t\t\t\t// In this case, we have semicolon right after gradient \n\t\t\t\t// definition and re-parse rule again\n\t\t\t\tif (/[\\n\\r]/.test(css.property.value())) {\n\t\t\t\t\t// insert semicolon at the end of gradient definition\n\t\t\t\t\tvar insertPos = css.property.valueRange(true).start + g.valueRange.end;\n\t\t\t\t\tcontent = require('utils').replaceSubstring(content, ';', insertPos);\n\t\t\t\t\tvar newCss = findGradientFromPosition(content, caret);\n\t\t\t\t\tif (newCss.property) {\n\t\t\t\t\t\tg = findGradient(newCss.property);\n\t\t\t\t\t\tcss = newCss;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// make sure current property has terminating semicolon\n\t\t\t\tcss.property.end(';');\n\t\t\t\t\n\t\t\t\t// resolve CSS property name\n\t\t\t\tvar resolvedName = resolvePropertyName(css.property.name(), syntax);\n\t\t\t\tif (resolvedName) {\n\t\t\t\t\tcss.property.name(resolvedName);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpasteGradient(css.property, g.gradient, g.valueRange);\n\t\t\t\teditor.replaceContent(css.rule.toString(), ruleStart, ruleEnd, true);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn expandGradientOutsideValue(editor, syntax);\n\t});\n\t\n\t// XXX register \"Reflect CSS Value\" action delegate\n\t/**\n\t * @param {EditElement} property\n\t */\n\trequire('reflectCSSValue').addHandler(function(property) {\n\t\tvar utils = require('utils');\n\t\t\n\t\tvar g = findGradient(property);\n\t\tif (!g)\n\t\t\treturn false;\n\t\t\n\t\tvar value = property.value();\n\t\tvar val = function(v) {\n\t\t\treturn utils.replaceSubstring(value, v, g.valueRange);\n\t\t};\n\t\t\n\t\t// reflect value for properties with the same name\n\t\t_.each(property.parent.getAll(getPrefixedNames(property.name())), function(prop) {\n\t\t\tif (prop === property)\n\t\t\t\treturn;\n\t\t\t\n\t\t\t// check if property value starts with gradient definition\n\t\t\tvar m = prop.value().match(/^\\s*(\\-([a-z]+)\\-)?linear\\-gradient/);\n\t\t\tif (m) {\n\t\t\t\tprop.value(val(module.toString(g.gradient, m[2] || '')));\n\t\t\t} else if (m = prop.value().match(/\\s*\\-webkit\\-gradient/)) {\n\t\t\t\t// old webkit gradient definition\n\t\t\t\tprop.value(val(module.oldWebkitLinearGradient(g.gradient)));\n\t\t\t}\n\t\t});\n\t\t\n\t\treturn true;\n\t});\n\t\n\treturn module = {\n\t\t/**\n\t\t * Parses gradient definition\n\t\t * @param {String} gradient\n\t\t * @returns {Object}\n\t\t */\n\t\tparse: function(gradient) {\n\t\t\tvar result = null;\n\t\t\trequire('utils').trim(gradient).replace(/^([\\w\\-]+)\\((.+?)\\)$/, function(str, type, definition) {\n\t\t\t\t// remove vendor prefix\n\t\t\t\ttype = type.toLowerCase().replace(/^\\-[a-z]+\\-/, '');\n\t\t\t\tif (type == 'linear-gradient' || type == 'lg') {\n\t\t\t\t\tresult = parseLinearGradient(definition);\n\t\t\t\t\treturn '';\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn str;\n\t\t\t});\n\t\t\t\n\t\t\treturn result;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Produces linear gradient definition used in early Webkit \n\t\t * implementations\n\t\t * @param {Object} gradient Parsed gradient\n\t\t * @returns {String}\n\t\t */\n\t\toldWebkitLinearGradient: function(gradient) {\n\t\t\tif (_.isString(gradient))\n\t\t\t\tgradient = this.parse(gradient);\n\t\t\t\n\t\t\tif (!gradient)\n\t\t\t\treturn null;\n\t\t\t\n\t\t\tvar colorStops = _.map(gradient.colorStops, _.clone);\n\t\t\t\n\t\t\t// normalize color-stops position\n\t\t\t_.each(colorStops, function(cs) {\n\t\t\t\tif (!('position' in cs)) // implied position\n\t\t\t\t\treturn;\n\t\t\t\t\n\t\t\t\tif (~cs.position.indexOf('.') || cs.unit == '%') {\n\t\t\t\t\tcs.position = parseFloat(cs.position) / (cs.unit == '%' ? 100 : 1);\n\t\t\t\t} else {\n\t\t\t\t\tthrow \"Can't convert color stop '\" + (cs.position + (cs.unit || '')) + \"'\";\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\tfillImpliedPositions(colorStops);\n\t\t\t\n\t\t\t// transform color-stops into string representation\n\t\t\tcolorStops = _.map(colorStops, function(cs, i) {\n\t\t\t\tif (!cs.position && !i)\n\t\t\t\t\treturn 'from(' + cs.color + ')';\n\t\t\t\t\n\t\t\t\tif (cs.position == 1 && i == colorStops.length - 1)\n\t\t\t\t\treturn 'to(' + cs.color + ')';\n\t\t\t\t\n\t\t\t\treturn 'color-stop(' + (cs.position.toFixed(2).replace(/\\.?0+$/, '')) + ', ' + cs.color + ')';\n\t\t\t});\n\t\t\t\n\t\t\treturn '-webkit-gradient(linear, ' \n\t\t\t\t+ oldWebkitDirection(gradient.direction)\n\t\t\t\t+ ', '\n\t\t\t\t+ colorStops.join(', ')\n\t\t\t\t+ ')';\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns string representation of parsed gradient\n\t\t * @param {Object} gradient Parsed gradient\n\t\t * @param {String} prefix Vendor prefix\n\t\t * @returns {String}\n\t\t */\n\t\ttoString: function(gradient, prefix) {\n\t\t\tif (gradient.type == 'linear') {\n\t\t\t\tvar fn = (prefix ? '-' + prefix + '-' : '') + 'linear-gradient';\n\t\t\t\t\n\t\t\t\t// transform color-stops\n\t\t\t\tvar colorStops = _.map(gradient.colorStops, function(cs) {\n\t\t\t\t\treturn cs.color + ('position' in cs \n\t\t\t\t\t\t\t? ' ' + cs.position + (cs.unit || '')\n\t\t\t\t\t\t\t: '');\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tif (gradient.direction \n\t\t\t\t\t\t&& (!prefs.get('css.gradient.omitDefaultDirection') \n\t\t\t\t\t\t|| !_.include(defaultLinearDirections, gradient.direction))) {\n\t\t\t\t\tcolorStops.unshift(gradient.direction);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn fn + '(' + colorStops.join(', ') + ')';\n\t\t\t}\n\t\t}\n\t};\n});/**\n * Module adds support for generators: a regexp-based abbreviation resolver \n * that can produce custom output.\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\t/** @type HandlerList */\n\tvar generators = require('handlerList').create();\n\tvar resources = require('resources');\n\t\n\t_.extend(resources, {\n\t\t/**\n\t\t * Add generator. A generator function <code>fn</code> will be called \n\t\t * only if current abbreviation matches <code>regexp</code> regular \n\t\t * expression and this function should return <code>null</code> if\n\t\t * abbreviation cannot be resolved\n\t\t * @param {RegExp} regexp Regular expression for abbreviation element name\n\t\t * @param {Function} fn Resolver function\n\t\t * @param {Object} options Options list as described in \n\t\t * {@link HandlerList#add()} method\n\t\t */\n\t\taddGenerator: function(regexp, fn, options) {\n\t\t\tif (_.isString(regexp))\n\t\t\t\tregexp = new RegExp(regexp);\n\t\t\t\n\t\t\tgenerators.add(function(node, syntax) {\n\t\t\t\tvar m;\n\t\t\t\tif ((m = regexp.exec(node.name()))) {\n\t\t\t\t\treturn fn(m, node, syntax);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn null;\n\t\t\t}, options);\n\t\t}\n\t});\n\t\n\tresources.addResolver(function(node, syntax) {\n\t\treturn generators.exec(null, _.toArray(arguments));\n\t});\n});/**\n * Module for resolving tag names: returns best matched tag name for child\n * element based on passed parent's tag name. Also provides utility function\n * for element type detection (inline, block-level, empty)\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.define('tagName', function(require, _) {\n\tvar elementTypes = {\n//\t\tempty: 'area,base,basefont,br,col,frame,hr,img,input,isindex,link,meta,param,embed,keygen,command'.split(','),\n\t\tempty: [],\n\t\tblockLevel: 'address,applet,blockquote,button,center,dd,del,dir,div,dl,dt,fieldset,form,frameset,hr,iframe,ins,isindex,li,link,map,menu,noframes,noscript,object,ol,p,pre,script,table,tbody,td,tfoot,th,thead,tr,ul,h1,h2,h3,h4,h5,h6'.split(','),\n\t\tinlineLevel: 'a,abbr,acronym,applet,b,basefont,bdo,big,br,button,cite,code,del,dfn,em,font,i,iframe,img,input,ins,kbd,label,map,object,q,s,samp,select,small,span,strike,strong,sub,sup,textarea,tt,u,var'.split(',')\n\t};\n\t\n\tvar elementMap = {\n\t\t'p': 'span',\n\t\t'ul': 'li',\n\t\t'ol': 'li',\n\t\t'table': 'tr',\n\t\t'tr': 'td',\n\t\t'tbody': 'tr',\n\t\t'thead': 'tr',\n\t\t'tfoot': 'tr',\n\t\t'colgroup': 'col',\n\t\t'select': 'option',\n\t\t'optgroup': 'option',\n\t\t'audio': 'source',\n\t\t'video': 'source',\n\t\t'object': 'param',\n\t\t'map': 'area'\n\t};\n\t\n\treturn {\n\t\t/**\n\t\t * Returns best matched child element name for passed parent's\n\t\t * tag name\n\t\t * @param {String} name\n\t\t * @returns {String}\n\t\t * @memberOf tagName\n\t\t */\n\t\tresolve: function(name) {\n\t\t\tname = (name || '').toLowerCase();\n\t\t\t\n\t\t\tif (name in elementMap)\n\t\t\t\treturn this.getMapping(name);\n\t\t\t\n\t\t\tif (this.isInlineLevel(name))\n\t\t\t\treturn 'span';\n\t\t\t\n\t\t\treturn 'div';\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns mapped child element name for passed parent's name \n\t\t * @param {String} name\n\t\t * @returns {String}\n\t\t */\n\t\tgetMapping: function(name) {\n\t\t\treturn elementMap[name.toLowerCase()];\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if passed element name belongs to inline-level element\n\t\t * @param {String} name\n\t\t * @returns {Boolean}\n\t\t */\n\t\tisInlineLevel: function(name) {\n\t\t\treturn this.isTypeOf(name, 'inlineLevel');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if passed element belongs to block-level element.\n\t\t * For better matching of unknown elements (for XML, for example), \n\t\t * you should use <code>!this.isInlineLevel(name)</code>\n\t\t * @returns {Boolean}\n\t\t */\n\t\tisBlockLevel: function(name) {\n\t\t\treturn this.isTypeOf(name, 'blockLevel');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if passed element is void (i.e. should not have closing tag).\n\t\t * @returns {Boolean}\n\t\t */\n\t\tisEmptyElement: function(name) {\n\t\t\treturn this.isTypeOf(name, 'empty');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Generic function for testing if element name belongs to specified\n\t\t * elements collection\n\t\t * @param {String} name Element name\n\t\t * @param {String} type Collection name\n\t\t * @returns {Boolean}\n\t\t */\n\t\tisTypeOf: function(name, type) {\n\t\t\treturn _.include(elementTypes[type], name);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Adds new parent–child mapping\n\t\t * @param {String} parent\n\t\t * @param {String} child\n\t\t */\n\t\taddMapping: function(parent, child) {\n\t\t\telementMap[parent] = child;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Removes parent-child mapping\n\t\t */\n\t\tremoveMapping: function(parent) {\n\t\t\tif (parent in elementMap)\n\t\t\t\tdelete elementMap[parent];\n\t\t},\n\t\t\n\t\t/**\n\t\t * Adds new element into collection\n\t\t * @param {String} name Element name\n\t\t * @param {String} collection Collection name\n\t\t */\n\t\taddElementToCollection: function(name, collection) {\n\t\t\tif (!elementTypes[collection])\n\t\t\t\telementTypes[collection] = [];\n\t\t\t\n\t\t\tvar col = this.getCollection(collection);\n\t\t\tif (!_.include(col, name))\n\t\t\t\tcol.push(name);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Removes element name from specified collection\n\t\t * @param {String} name Element name\n\t\t * @param {String} collection Collection name\n\t\t * @returns\n\t\t */\n\t\tremoveElementFromCollection: function(name, collection) {\n\t\t\tif (collection in elementTypes) {\n\t\t\t\telementTypes[collection] = _.without(this.getCollection(collection), name);\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns elements name collection\n\t\t * @param {String} name Collection name\n\t\t * @returns {Array}\n\t\t */\n\t\tgetCollection: function(name) {\n\t\t\treturn elementTypes[name];\n\t\t}\n\t};\n});/**\n * Filter for aiding of writing elements with complex class names as described\n * in Yandex's BEM (Block, Element, Modifier) methodology. This filter will\n * automatically inherit block and element names from parent elements and insert\n * them into child element classes\n * @memberOf __bemFilterDefine\n * @constructor\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\tvar prefs = require('preferences');\n\tprefs.define('bem.elementSeparator', '__', 'Class name’s element separator.');\n\tprefs.define('bem.modifierSeparator', '_', 'Class name’s modifier separator.');\n\tprefs.define('bem.shortElementPrefix', '-', \n\t\t\t'Symbol for describing short “block-element” notation. Class names '\n\t\t\t+ 'prefixed with this symbol will be treated as element name for parent‘s '\n\t\t\t+ 'block name. Each symbol instance traverses one level up in parsed ' \n\t\t\t+ 'tree for block name lookup. Empty value will disable short notation.');\n\t\n\tvar shouldRunHtmlFilter = false;\n\t\n\tfunction getSeparators() {\n\t\treturn {\n\t\t\telement: prefs.get('bem.elementSeparator'),\n\t\t\tmodifier: prefs.get('bem.modifierSeparator')\n\t\t};\n\t}\n\t\n\t/**\n\t * @param {AbbreviationNode} item\n\t */\n\tfunction bemParse(item) {\n\t\tif (require('abbreviationUtils').isSnippet(item))\n\t\t\treturn item;\n\t\t\n\t\t// save BEM stuff in cache for faster lookups\n\t\titem.__bem = {\n\t\t\tblock: '',\n\t\t\telement: '',\n\t\t\tmodifier: ''\n\t\t};\n\t\t\n\t\tvar classNames = normalizeClassName(item.attribute('class')).split(' ');\n\t\t\n\t\t// guess best match for block name\n\t\tvar reBlockName = /^[a-z]\\-/i;\n\t\titem.__bem.block = _.find(classNames, function(name) {\n\t\t\treturn reBlockName.test(name);\n\t\t});\n\t\t\n\t\t// guessing doesn't worked, pick first class name as block name\n\t\tif (!item.__bem.block) {\n\t\t\treBlockName = /^[a-z]/i;\n\t\t\titem.__bem.block = _.find(classNames, function(name) {\n\t\t\t\treturn reBlockName.test(name);\n\t\t\t}) || '';\n\t\t}\n\t\t\n\t\tclassNames = _.chain(classNames)\n\t\t\t.map(function(name) {return processClassName(name, item);})\n\t\t\t.flatten()\n\t\t\t.uniq()\n\t\t\t.value()\n\t\t\t.join(' ');\n\t\t\n\t\tif (classNames)\n\t\t\titem.attribute('class', classNames);\n\t\t\n\t\treturn item;\n\t}\n\t\n\t/**\n\t * @param {String} className\n\t * @returns {String}\n\t */\n\tfunction normalizeClassName(className) {\n\t\tvar utils = require('utils');\n\t\tclassName = (' ' + (className || '') + ' ').replace(/\\s+/g, ' ');\n\t\t\n\t\tvar shortSymbol = prefs.get('bem.shortElementPrefix');\n\t\tif (shortSymbol) {\n\t\t\tvar re = new RegExp('\\\\s(' + utils.escapeForRegexp(shortSymbol) + '+)', 'g');\n\t\t\tclassName = className.replace(re, function(str, p1) {\n\t\t\t\treturn ' ' + utils.repeatString(getSeparators().element, p1.length);\n\t\t\t});\n\t\t}\n\t\t\n\t\treturn utils.trim(className);\n\t}\n\t\n\t/**\n\t * Processes class name\n\t * @param {String} name Class name item to process\n\t * @param {AbbreviationNode} item Host node for provided class name\n\t * @returns Processed class name. May return <code>Array</code> of\n\t * class names \n\t */\n\tfunction processClassName(name, item) {\n\t\tname = transformClassName(name, item, 'element');\n\t\tname = transformClassName(name, item, 'modifier');\n\t\t\n\t\t// expand class name\n\t\t// possible values:\n\t\t// * block__element\n\t\t// * block__element_modifier\n\t\t// * block__element_modifier1_modifier2\n\t\t// * block_modifier\n\t\tvar block = '', element = '', modifier = '';\n\t\tvar separators = getSeparators();\n\t\tif (~name.indexOf(separators.element)) {\n\t\t\tvar blockElem = name.split(separators.element);\n\t\t\tvar elemModifiers = blockElem[1].split(separators.modifier);\n\t\t\t\n\t\t\tblock = blockElem[0];\n\t\t\telement = elemModifiers.shift();\n\t\t\tmodifier = elemModifiers.join(separators.modifier);\n\t\t} else if (~name.indexOf(separators.modifier)) {\n\t\t\tvar blockModifiers = name.split(separators.modifier);\n\t\t\t\n\t\t\tblock = blockModifiers.shift();\n\t\t\tmodifier = blockModifiers.join(separators.modifier);\n\t\t}\n\t\t\n\t\tif (block || element || modifier) {\n\t\t\tif (!block) {\n\t\t\t\tblock = item.__bem.block;\n\t\t\t}\n\t\t\t\n\t\t\t// inherit parent bem element, if exists\n//\t\t\tif (item.parent && item.parent.__bem && item.parent.__bem.element)\n//\t\t\t\telement = item.parent.__bem.element + separators.element + element;\n\t\t\t\n\t\t\t// produce multiple classes\n\t\t\tvar prefix = block;\n\t\t\tvar result = [];\n\t\t\t\n\t\t\tif (element) {\n\t\t\t\tprefix += separators.element + element;\n\t\t\t\tresult.push(prefix);\n\t\t\t} else {\n\t\t\t\tresult.push(prefix);\n\t\t\t}\n\t\t\t\n\t\t\tif (modifier) {\n\t\t\t\tresult.push(prefix + separators.modifier + modifier);\n\t\t\t}\n\t\t\t\n\t\t\titem.__bem.block = block;\n\t\t\titem.__bem.element = element;\n\t\t\titem.__bem.modifier = modifier;\n\t\t\t\n\t\t\treturn result;\n\t\t}\n\t\t\n\t\t// ...otherwise, return processed or original class name\n\t\treturn name;\n\t}\n\t\n\t/**\n\t * Low-level function to transform user-typed class name into full BEM class\n\t * @param {String} name Class name item to process\n\t * @param {AbbreviationNode} item Host node for provided class name\n\t * @param {String} entityType Type of entity to be tried to transform \n\t * ('element' or 'modifier')\n\t * @returns {String} Processed class name or original one if it can't be\n\t * transformed\n\t */\n\tfunction transformClassName(name, item, entityType) {\n\t\tvar separators = getSeparators();\n\t\tvar reSep = new RegExp('^(' + separators[entityType] + ')+', 'g');\n\t\tif (reSep.test(name)) {\n\t\t\tvar depth = 0; // parent lookup depth\n\t\t\tvar cleanName = name.replace(reSep, function(str, p1) {\n\t\t\t\tdepth = str.length / separators[entityType].length;\n\t\t\t\treturn '';\n\t\t\t});\n\t\t\t\n\t\t\t// find donor element\n\t\t\tvar donor = item;\n\t\t\twhile (donor.parent && depth--) {\n\t\t\t\tdonor = donor.parent;\n\t\t\t}\n\t\t\t\n\t\t\tif (!donor || !donor.__bem)\n\t\t\t\tdonor = item;\n\t\t\t\n\t\t\tif (donor && donor.__bem) {\n\t\t\t\tvar prefix = donor.__bem.block;\n\t\t\t\t\n\t\t\t\t// decide if we should inherit element name\n//\t\t\t\tif (entityType == 'element') {\n//\t\t\t\t\tvar curElem = cleanName.split(separators.modifier, 1)[0];\n//\t\t\t\t\tif (donor.__bem.element && donor.__bem.element != curElem)\n//\t\t\t\t\t\tprefix += separators.element + donor.__bem.element;\n//\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (entityType == 'modifier' &&  donor.__bem.element)\n\t\t\t\t\tprefix += separators.element + donor.__bem.element;\n\t\t\t\t\n\t\t\t\treturn prefix + separators[entityType] + cleanName;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn name;\n\t}\n\t\n\t/**\n\t * Recursive function for processing tags, which extends class names \n\t * according to BEM specs: http://bem.github.com/bem-method/pages/beginning/beginning.ru.html\n\t * <br><br>\n\t * It does several things:<br>\n\t * <ul>\n\t * <li>Expands complex class name (according to BEM symbol semantics):\n\t * .block__elem_modifier → .block.block__elem.block__elem_modifier\n\t * </li>\n\t * <li>Inherits block name on child elements: \n\t * .b-block > .__el > .__el → .b-block > .b-block__el > .b-block__el__el\n\t * </li>\n\t * <li>Treats first dash symbol as '__'</li>\n\t * <li>Double underscore (or typographic '–') is also treated as an element \n\t * level lookup, e.g. ____el will search for element definition in parent’s \n\t * parent element:\n\t * .b-block > .__el1 > .____el2 → .b-block > .b-block__el1 > .b-block__el2\n\t * </li>\n\t * </ul>\n\t * \n\t * @param {AbbreviationNode} tree\n\t * @param {Object} profile\n\t */\n\tfunction process(tree, profile) {\n\t\tif (tree.name)\n\t\t\tbemParse(tree, profile);\n\t\t\n\t\tvar abbrUtils = require('abbreviationUtils');\n\t\t_.each(tree.children, function(item) {\n\t\t\tprocess(item, profile);\n\t\t\tif (!abbrUtils.isSnippet(item) && item.start)\n\t\t\t\tshouldRunHtmlFilter = true;\n\t\t});\n\t\t\n\t\treturn tree;\n\t};\n\t\n\trequire('filters').add('bem', function(tree, profile) {\n\t\tshouldRunHtmlFilter = false;\n\t\ttree = process(tree, profile);\n\t\t// in case 'bem' filter is applied after 'html' filter: run it again\n\t\t// to update output\n\t\tif (shouldRunHtmlFilter) {\n\t\t\ttree = require('filters').apply(tree, 'html', profile);\n\t\t}\n\t\t\n\t\treturn tree;\n\t});\n});\n\n/**\n * Comment important tags (with 'id' and 'class' attributes)\n * @author Sergey Chikuyonok (serge.che@gmail.com)\n * @link http://chikuyonok.ru\n * @constructor\n * @memberOf __commentFilterDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\t// define some preferences\n\t/** @type emmet.preferences */\n\tvar prefs = require('preferences');\n\t\n\tprefs.define('filter.commentAfter', \n\t\t\t'\\n<!-- /<%= attr(\"id\", \"#\") %><%= attr(\"class\", \".\") %> -->',\n\t\t\t'A definition of comment that should be placed <i>after</i> matched '\n\t\t\t+ 'element when <code>comment</code> filter is applied. This definition '\n\t\t\t+ 'is an ERB-style template passed to <code>_.template()</code> '\n\t\t\t+ 'function (see Underscore.js docs for details). In template context, '\n\t\t\t+ 'the following properties and functions are availabe:\\n'\n\t\t\t+ '<ul>'\n\t\t\t\n\t\t\t+ '<li><code>attr(name, before, after)</code> – a function that outputs' \n\t\t\t+ 'specified attribute value concatenated with <code>before</code> ' \n\t\t\t+ 'and <code>after</code> strings. If attribute doesn\\'t exists, the ' \n\t\t\t+ 'empty string will be returned.</li>'\n\t\t\t\n\t\t\t+ '<li><code>node</code> – current node (instance of <code>AbbreviationNode</code>)</li>'\n\t\t\t\n\t\t\t+ '<li><code>name</code> – name of current tag</li>'\n\t\t\t\n\t\t\t+ '<li><code>padding</code> – current string padding, can be used ' \n\t\t\t+ 'for formatting</li>'\n\t\t\t\n\t\t\t+'</ul>');\n\t\n\tprefs.define('filter.commentBefore', \n\t\t\t'',\n\t\t\t'A definition of comment that should be placed <i>before</i> matched '\n\t\t\t+ 'element when <code>comment</code> filter is applied. '\n\t\t\t+ 'For more info, read description of <code>filter.commentAfter</code> '\n\t\t\t+ 'property');\n\t\n\tprefs.define('filter.commentTrigger', 'id, class',\n\t\t\t'A comma-separated list of attribute names that should exist in abbreviatoin '\n\t\t\t+ 'where comment should be added. If you wish to add comment for '\n\t\t\t+ 'every element, set this option to <code>*</code>');\n\t\n\t/**\n\t * Add comments to tag\n\t * @param {AbbreviationNode} node\n\t */\n\tfunction addComments(node, templateBefore, templateAfter) {\n\t\tvar utils = require('utils');\n\t\t\n\t\t// check if comments should be added\n\t\tvar trigger = prefs.get('filter.commentTrigger');\n\t\tif (trigger != '*') {\n\t\t\tvar shouldAdd = _.find(trigger.split(','), function(name) {\n\t\t\t\treturn !!node.attribute(utils.trim(name));\n\t\t\t});\n\t\t\tif (!shouldAdd) return;\n\t\t}\n\t\t\n\t\tvar ctx = {\n\t\t\tnode: node,\n\t\t\tname: node.name(),\n\t\t\tpadding: node.parent ? node.parent.padding : '',\n\t\t\tattr: function(name, before, after) {\n\t\t\t\tvar attr = node.attribute(name);\n\t\t\t\tif (attr) {\n\t\t\t\t\treturn (before || '') + attr + (after || '');\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn '';\n\t\t\t}\n\t\t};\n\t\t\n\t\tvar nodeBefore = utils.normalizeNewline(templateBefore ? templateBefore(ctx) : '');\n\t\tvar nodeAfter = utils.normalizeNewline(templateAfter ? templateAfter(ctx) : '');\n\t\t\n\t\tnode.start = node.start.replace(/</, nodeBefore + '<');\n\t\tnode.end = node.end.replace(/>/, '>' + nodeAfter);\n\t}\n\t\n\tfunction process(tree, before, after) {\n\t\tvar abbrUtils = require('abbreviationUtils');\n\t\t_.each(tree.children, function(item) {\n\t\t\tif (abbrUtils.isBlock(item))\n\t\t\t\taddComments(item, before, after);\n\t\t\t\n\t\t\tprocess(item, before, after);\n\t\t});\n\t\t\t\n\t\treturn tree;\n\t}\n\t\n\trequire('filters').add('c', function(tree) {\n\t\tvar templateBefore = _.template(prefs.get('filter.commentBefore'));\n\t\tvar templateAfter = _.template(prefs.get('filter.commentAfter'));\n\t\t\n\t\treturn process(tree, templateBefore, templateAfter);\n\t});\n});\n/**\n * Filter for escaping unsafe XML characters: <, >, &\n * @author Sergey Chikuyonok (serge.che@gmail.com)\n * @link http://chikuyonok.ru\n */\nemmet.exec(function(require, _) {\n\tvar charMap = {\n\t\t'<': '&lt;',\n\t\t'>': '&gt;',\n\t\t'&': '&amp;'\n\t};\n\t\n\tfunction escapeChars(str) {\n\t\treturn str.replace(/([<>&])/g, function(str, p1){\n\t\t\treturn charMap[p1];\n\t\t});\n\t}\n\t\n\trequire('filters').add('e', function process(tree) {\n\t\t_.each(tree.children, function(item) {\n\t\t\titem.start = escapeChars(item.start);\n\t\t\titem.end = escapeChars(item.end);\n\t\t\titem.content = escapeChars(item.content);\n\t\t\tprocess(item);\n\t\t});\n\t\t\n\t\treturn tree;\n\t});\n});/**\n * Generic formatting filter: creates proper indentation for each tree node,\n * placing \"%s\" placeholder where the actual output should be. You can use\n * this filter to preformat tree and then replace %s placeholder to whatever you\n * need. This filter should't be called directly from editor as a part \n * of abbreviation.\n * @author Sergey Chikuyonok (serge.che@gmail.com)\n * @link http://chikuyonok.ru\n * @constructor\n * @memberOf __formatFilterDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _){\n\tvar placeholder = '%s';\n\t\n\t/** @type preferences */\n\tvar prefs = require('preferences');\n\tprefs.define('format.noIndentTags', 'html', \n\t\t\t'A comma-separated list of tag names that should not get inner indentation.');\n\t\n\tprefs.define('format.forceIndentationForTags', 'body', \n\t\t'A comma-separated list of tag names that should <em>always</em> get inner indentation.');\n\t\n\t/**\n\t * Get indentation for given node\n\t * @param {AbbreviationNode} node\n\t * @returns {String}\n\t */\n\tfunction getIndentation(node) {\n\t\tif (_.include(prefs.getArray('format.noIndentTags') || [], node.name())) {\n\t\t\treturn '';\n\t\t}\n\t\t\n\t\treturn require('resources').getVariable('indentation');\n\t}\n\t\n\t/**\n\t * Test if passed node has block-level sibling element\n\t * @param {AbbreviationNode} item\n\t * @return {Boolean}\n\t */\n\tfunction hasBlockSibling(item) {\n\t\treturn item.parent && require('abbreviationUtils').hasBlockChildren(item.parent);\n\t}\n\t\n\t/**\n\t * Test if passed item is very first child in parsed tree\n\t * @param {AbbreviationNode} item\n\t */\n\tfunction isVeryFirstChild(item) {\n\t\treturn item.parent && !item.parent.parent && !item.index();\n\t}\n\t\n\t/**\n\t * Check if a newline should be added before element\n\t * @param {AbbreviationNode} node\n\t * @param {OutputProfile} profile\n\t * @return {Boolean}\n\t */\n\tfunction shouldAddLineBreak(node, profile) {\n\t\tvar abbrUtils = require('abbreviationUtils');\n\t\tif (profile.tag_nl === true || abbrUtils.isBlock(node))\n\t\t\treturn true;\n\t\t\n\t\tif (!node.parent || !profile.inline_break)\n\t\t\treturn false;\n\t\t\n\t\t// check if there are required amount of adjacent inline element\n\t\treturn shouldFormatInline(node.parent, profile);\n}\n\t\n\t/**\n\t * Need to add newline because <code>item</code> has too many inline children\n\t * @param {AbbreviationNode} node\n\t * @param {OutputProfile} profile\n\t */\n\tfunction shouldBreakChild(node, profile) {\n\t\t// we need to test only one child element, because \n\t\t// hasBlockChildren() method will do the rest\n\t\treturn node.children.length && shouldAddLineBreak(node.children[0], profile);\n\t}\n\t\n\tfunction shouldFormatInline(node, profile) {\n\t\tvar nodeCount = 0;\n\t\tvar abbrUtils = require('abbreviationUtils');\n\t\treturn !!_.find(node.children, function(child) {\n\t\t\tif (child.isTextNode() || !abbrUtils.isInline(child))\n\t\t\t\tnodeCount = 0;\n\t\t\telse if (abbrUtils.isInline(child))\n\t\t\t\tnodeCount++;\n\t\t\t\n\t\t\tif (nodeCount >= profile.inline_break)\n\t\t\t\treturn true;\n\t\t});\n\t}\n\t\n\tfunction isRoot(item) {\n\t\treturn !item.parent;\n\t}\n\t\n\t/**\n\t * Processes element with matched resource of type <code>snippet</code>\n\t * @param {AbbreviationNode} item\n\t * @param {OutputProfile} profile\n\t * @param {Number} level Depth level\n\t */\n\tfunction processSnippet(item, profile, level) {\n\t\titem.start = item.end = '';\n\t\tif (!isVeryFirstChild(item) && profile.tag_nl !== false && shouldAddLineBreak(item, profile)) {\n\t\t\t// check if we’re not inside inline element\n\t\t\tif (isRoot(item.parent) || !require('abbreviationUtils').isInline(item.parent)) {\n\t\t\t\titem.start = require('utils').getNewline() + item.start;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn item;\n\t}\n\t\n\t/**\n\t * Check if we should add line breaks inside inline element\n\t * @param {AbbreviationNode} node\n\t * @param {OutputProfile} profile\n\t * @return {Boolean}\n\t */\n\tfunction shouldBreakInsideInline(node, profile) {\n\t\tvar abbrUtils = require('abbreviationUtils');\n\t\tvar hasBlockElems = _.any(node.children, function(child) {\n\t\t\tif (abbrUtils.isSnippet(child))\n\t\t\t\treturn false;\n\t\t\t\n\t\t\treturn !abbrUtils.isInline(child);\n\t\t});\n\t\t\n\t\tif (!hasBlockElems) {\n\t\t\treturn shouldFormatInline(node, profile);\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\t/**\n\t * Processes element with <code>tag</code> type\n\t * @param {AbbreviationNode} item\n\t * @param {OutputProfile} profile\n\t * @param {Number} level Depth level\n\t */\n\tfunction processTag(item, profile, level) {\n\t\titem.start = item.end = placeholder;\n\t\tvar utils = require('utils');\n\t\tvar abbrUtils = require('abbreviationUtils');\n\t\tvar isUnary = abbrUtils.isUnary(item);\n\t\tvar nl = utils.getNewline();\n\t\tvar indent = getIndentation(item);\n\t\t\t\n\t\t// formatting output\n\t\tif (profile.tag_nl !== false) {\n\t\t\tvar forceNl = profile.tag_nl === true && (profile.tag_nl_leaf || item.children.length);\n\t\t\tif (!forceNl) {\n\t\t\t\tforceNl = _.include(prefs.getArray('format.forceIndentationForTags') || [], item.name());\n\t\t\t}\n\t\t\t\n\t\t\t// formatting block-level elements\n\t\t\tif (!item.isTextNode()) {\n\t\t\t\tif (shouldAddLineBreak(item, profile)) {\n\t\t\t\t\t// - do not indent the very first element\n\t\t\t\t\t// - do not indent first child of a snippet\n\t\t\t\t\tif (!isVeryFirstChild(item) && (!abbrUtils.isSnippet(item.parent) || item.index()))\n\t\t\t\t\t\titem.start = nl + item.start;\n\t\t\t\t\t\t\n\t\t\t\t\tif (abbrUtils.hasBlockChildren(item) || shouldBreakChild(item, profile) || (forceNl && !isUnary))\n\t\t\t\t\t\titem.end = nl + item.end;\n\t\t\t\t\t\t\n\t\t\t\t\tif (abbrUtils.hasTagsInContent(item) || (forceNl && !item.children.length && !isUnary))\n\t\t\t\t\t\titem.start += nl + indent;\n\t\t\t\t} else if (abbrUtils.isInline(item) && hasBlockSibling(item) && !isVeryFirstChild(item)) {\n\t\t\t\t\titem.start = nl + item.start;\n\t\t\t\t} else if (abbrUtils.isInline(item) && shouldBreakInsideInline(item, profile)) {\n\t\t\t\t\titem.end = nl + item.end;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\titem.padding = indent;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn item;\n\t}\n\t\n\t/**\n\t * Processes simplified tree, making it suitable for output as HTML structure\n\t * @param {AbbreviationNode} tree\n\t * @param {OutputProfile} profile\n\t * @param {Number} level Depth level\n\t */\n\trequire('filters').add('_format', function process(tree, profile, level) {\n\t\tlevel = level || 0;\n\t\tvar abbrUtils = require('abbreviationUtils');\n\t\t\n\t\t_.each(tree.children, function(item) {\n\t\t\tif (abbrUtils.isSnippet(item))\n\t\t\t\tprocessSnippet(item, profile, level);\n\t\t\telse\n\t\t\t\tprocessTag(item, profile, level);\n\t\t\t\n\t\t\tprocess(item, profile, level + 1);\n\t\t});\n\t\t\n\t\treturn tree;\n\t});\n});/**\n * Filter for producing HAML code from abbreviation.\n * @author Sergey Chikuyonok (serge.che@gmail.com)\n * @link http://chikuyonok.ru\n * @constructor\n * @memberOf __hamlFilterDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\tvar childToken = '${child}';\n\t\n\tfunction transformClassName(className) {\n\t\treturn require('utils').trim(className).replace(/\\s+/g, '.');\n\t}\n\t\n\t/**\n\t * Creates HAML attributes string from tag according to profile settings\n\t * @param {AbbreviationNode} tag\n\t * @param {Object} profile\n\t */\n\tfunction makeAttributesString(tag, profile) {\n\t\tvar attrs = '';\n\t\tvar otherAttrs = [];\n\t\tvar attrQuote = profile.attributeQuote();\n\t\tvar cursor = profile.cursor();\n\t\t\n\t\t_.each(tag.attributeList(), function(a) {\n\t\t\tvar attrName = profile.attributeName(a.name);\n\t\t\tswitch (attrName.toLowerCase()) {\n\t\t\t\t// use short notation for ID and CLASS attributes\n\t\t\t\tcase 'id':\n\t\t\t\t\tattrs += '#' + (a.value || cursor);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'class':\n\t\t\t\t\tattrs += '.' + transformClassName(a.value || cursor);\n\t\t\t\t\tbreak;\n\t\t\t\t// process other attributes\n\t\t\t\tdefault:\n\t\t\t\t\totherAttrs.push(':' +attrName + ' => ' + attrQuote + (a.value || cursor) + attrQuote);\n\t\t\t}\n\t\t});\n\t\t\n\t\tif (otherAttrs.length)\n\t\t\tattrs += '{' + otherAttrs.join(', ') + '}';\n\t\t\n\t\treturn attrs;\n\t}\n\t\n\t/**\n\t * Test if passed node has block-level sibling element\n\t * @param {AbbreviationNode} item\n\t * @return {Boolean}\n\t */\n\tfunction hasBlockSibling(item) {\n\t\treturn item.parent && item.parent.hasBlockChildren();\n\t}\n\t\n\t/**\n\t * Processes element with <code>tag</code> type\n\t * @param {AbbreviationNode} item\n\t * @param {OutputProfile} profile\n\t * @param {Number} level Depth level\n\t */\n\tfunction processTag(item, profile, level) {\n\t\tif (!item.parent)\n\t\t\t// looks like it's root element\n\t\t\treturn item;\n\t\t\n\t\tvar abbrUtils = require('abbreviationUtils');\n\t\tvar utils = require('utils');\n\t\t\n\t\tvar attrs = makeAttributesString(item, profile);\n\t\tvar cursor = profile.cursor();\n\t\tvar isUnary = abbrUtils.isUnary(item);\n\t\tvar selfClosing = profile.self_closing_tag && isUnary ? '/' : '';\n\t\tvar start= '';\n\t\t\t\n\t\t// define tag name\n\t\tvar tagName = '%' + profile.tagName(item.name());\n\t\tif (tagName.toLowerCase() == '%div' && attrs && attrs.indexOf('{') == -1)\n\t\t\t// omit div tag\n\t\t\ttagName = '';\n\t\t\t\n\t\titem.end = '';\n\t\tstart = tagName + attrs + selfClosing + ' ';\n\t\t\n\t\tvar placeholder = '%s';\n\t\t// We can't just replace placeholder with new value because\n\t\t// JavaScript will treat double $ character as a single one, assuming\n\t\t// we're using RegExp literal.\n\t\titem.start = utils.replaceSubstring(item.start, start, item.start.indexOf(placeholder), placeholder);\n\t\t\n\t\tif (!item.children.length && !isUnary)\n\t\t\titem.start += cursor;\n\t\t\n\t\treturn item;\n\t}\n\t\n\t/**\n\t * Processes simplified tree, making it suitable for output as HTML structure\n\t * @param {AbbreviationNode} tree\n\t * @param {Object} profile\n\t * @param {Number} level Depth level\n\t */\n\trequire('filters').add('haml', function process(tree, profile, level) {\n\t\tlevel = level || 0;\n\t\tvar abbrUtils = require('abbreviationUtils');\n\t\t\n\t\tif (!level) {\n\t\t\ttree = require('filters').apply(tree, '_format', profile);\n\t\t}\n\t\t\n\t\t_.each(tree.children, function(item) {\n\t\t\tif (!abbrUtils.isSnippet(item))\n\t\t\t\tprocessTag(item, profile, level);\n\t\t\t\n\t\t\tprocess(item, profile, level + 1);\n\t\t});\n\t\t\n\t\treturn tree;\n\t});\n});/**\n * Filter that produces HTML tree\n * @author Sergey Chikuyonok (serge.che@gmail.com)\n * @link http://chikuyonok.ru\n * @constructor\n * @memberOf __htmlFilterDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\t/**\n\t * Creates HTML attributes string from tag according to profile settings\n\t * @param {AbbreviationNode} node\n\t * @param {OutputProfile} profile\n\t */\n\tfunction makeAttributesString(node, profile) {\n\t\tvar attrQuote = profile.attributeQuote();\n\t\tvar cursor = profile.cursor();\n\t\t\n\t\treturn _.map(node.attributeList(), function(a) {\n\t\t\tvar attrName = profile.attributeName(a.name);\n\t\t\treturn ' ' + attrName + '=' + attrQuote + (a.value || cursor) + attrQuote;\n\t\t}).join('');\n\t}\n\t\n\t/**\n\t * Processes element with <code>tag</code> type\n\t * @param {AbbreviationNode} item\n\t * @param {OutputProfile} profile\n\t * @param {Number} level Depth level\n\t */\n\tfunction processTag(item, profile, level) {\n\t\tif (!item.parent) // looks like it's root element\n\t\t\treturn item;\n\t\t\n\t\tvar abbrUtils = require('abbreviationUtils');\n\t\tvar utils = require('utils');\n\t\t\n\t\tvar attrs = makeAttributesString(item, profile); \n\t\tvar cursor = profile.cursor();\n\t\tvar isUnary = abbrUtils.isUnary(item);\n\t\tvar start= '';\n\t\tvar end = '';\n\t\t\t\n\t\t// define opening and closing tags\n\t\tif (!item.isTextNode()) {\n\t\t\tvar tagName = profile.tagName(item.name());\n\t\t\tif (isUnary) {\n\t\t\t\tstart = '<' + tagName + attrs + profile.selfClosing() + '>';\n\t\t\t\titem.end = '';\n\t\t\t} else {\n\t\t\t\tstart = '<' + tagName + attrs + '>';\n\t\t\t\tend = '</' + tagName + '>';\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar placeholder = '%s';\n\t\t// We can't just replace placeholder with new value because\n\t\t// JavaScript will treat double $ character as a single one, assuming\n\t\t// we're using RegExp literal.\n\t\titem.start = utils.replaceSubstring(item.start, start, item.start.indexOf(placeholder), placeholder);\n\t\titem.end = utils.replaceSubstring(item.end, end, item.end.indexOf(placeholder), placeholder);\n\t\t\n\t\t// should we put caret placeholder after opening tag?\n\t\tif (\n\t\t\t\t!item.children.length \n\t\t\t\t&& !isUnary \n\t\t\t\t&& !~item.content.indexOf(cursor)\n\t\t\t\t&& !require('tabStops').extract(item.content).tabstops.length\n\t\t\t) {\n\t\t\titem.start += cursor;\n\t\t}\n\t\t\n\t\treturn item;\n\t}\n\t\n\t/**\n\t * Processes simplified tree, making it suitable for output as HTML structure\n\t * @param {AbbreviationNode} tree\n\t * @param {Object} profile\n\t * @param {Number} level Depth level\n\t */\n\trequire('filters').add('html', function process(tree, profile, level) {\n\t\tlevel = level || 0;\n\t\tvar abbrUtils = require('abbreviationUtils');\n\t\t\n\t\tif (!level) {\n\t\t\ttree = require('filters').apply(tree, '_format', profile);\n\t\t}\n\t\t\n\t\t_.each(tree.children, function(item) {\n\t\t\tif (!abbrUtils.isSnippet(item))\n\t\t\t\tprocessTag(item, profile, level);\n\t\t\t\n\t\t\tprocess(item, profile, level + 1);\n\t\t});\n\t\t\n\t\treturn tree;\n\t});\n});/**\n * Output abbreviation on a single line (i.e. no line breaks)\n * @author Sergey Chikuyonok (serge.che@gmail.com)\n * @link http://chikuyonok.ru\n * @constructor\n * @memberOf __singleLineFilterDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\tvar rePad = /^\\s+/;\n\tvar reNl = /[\\n\\r]/g;\n\t\n\trequire('filters').add('s', function process(tree, profile, level) {\n\t\tvar abbrUtils = require('abbreviationUtils');\n\t\t\n\t\t_.each(tree.children, function(item) {\n\t\t\tif (!abbrUtils.isSnippet(item)) {\n\t\t\t\t// remove padding from item \n\t\t\t\titem.start = item.start.replace(rePad, '');\n\t\t\t\titem.end = item.end.replace(rePad, '');\n\t\t\t}\n\t\t\t\n\t\t\t// remove newlines \n\t\t\titem.start = item.start.replace(reNl, '');\n\t\t\titem.end = item.end.replace(reNl, '');\n\t\t\titem.content = item.content.replace(reNl, '');\n\t\t\t\n\t\t\tprocess(item);\n\t\t});\n\t\t\n\t\treturn tree;\n\t});\n});\n/**\n * Trim filter: removes characters at the beginning of the text\n * content that indicates lists: numbers, #, *, -, etc.\n * \n * Useful for wrapping lists with abbreviation.\n * \n * @author Sergey Chikuyonok (serge.che@gmail.com)\n * @link http://chikuyonok.ru\n * \n * @constructor\n * @memberOf __trimFilterDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\trequire('preferences').define('filter.trimRegexp', '[\\\\s|\\\\u00a0]*[\\\\d|#|\\\\-|\\*|\\\\u2022]+\\\\.?\\\\s*',\n\t\t\t'Regular expression used to remove list markers (numbers, dashes, ' \n\t\t\t+ 'bullets, etc.) in <code>t</code> (trim) filter. The trim filter '\n\t\t\t+ 'is useful for wrapping with abbreviation lists, pased from other ' \n\t\t\t+ 'documents (for example, Word documents).');\n\t\n\tfunction process(tree, re) {\n\t\t_.each(tree.children, function(item) {\n\t\t\tif (item.content)\n\t\t\t\titem.content = item.content.replace(re, '');\n\t\t\t\n\t\t\tprocess(item, re);\n\t\t});\n\t\t\n\t\treturn tree;\n\t}\n\t\n\trequire('filters').add('t', function(tree) {\n\t\tvar re = new RegExp(require('preferences').get('filter.trimRegexp'));\n\t\treturn process(tree, re);\n\t});\n});\n/**\n * Filter for trimming \"select\" attributes from some tags that contains\n * child elements\n * @author Sergey Chikuyonok (serge.che@gmail.com)\n * @link http://chikuyonok.ru\n * \n * @constructor\n * @memberOf __xslFilterDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\tvar tags = {\n\t\t'xsl:variable': 1,\n\t\t'xsl:with-param': 1\n\t};\n\t\n\t/**\n\t * Removes \"select\" attribute from node\n\t * @param {AbbreviationNode} node\n\t */\n\tfunction trimAttribute(node) {\n\t\tnode.start = node.start.replace(/\\s+select\\s*=\\s*(['\"]).*?\\1/, '');\n\t}\n\t\n\trequire('filters').add('xsl', function process(tree) {\n\t\tvar abbrUtils = require('abbreviationUtils');\n\t\t_.each(tree.children, function(item) {\n\t\t\tif (!abbrUtils.isSnippet(item)\n\t\t\t\t\t&& (item.name() || '').toLowerCase() in tags \n\t\t\t\t\t&& item.children.length)\n\t\t\t\ttrimAttribute(item);\n\t\t\tprocess(item);\n\t\t});\n\t\t\n\t\treturn tree;\n\t});\n});/**\n * \"Lorem ipsum\" text generator. Matches <code>lipsum(num)?</code> or \n * <code>lorem(num)?</code> abbreviation.\n * This code is based on Django's contribution: \n * https://code.djangoproject.com/browser/django/trunk/django/contrib/webdesign/lorem_ipsum.py\n * <br><br>\n * Examples to test:<br>\n * <code>lipsum</code> – generates 30 words text.<br>\n * <code>lipsum*6</code> – generates 6 paragraphs (autowrapped with &lt;p&gt; element) of text.<br>\n * <code>ol>lipsum10*5</code> — generates ordered list with 5 list items (autowrapped with &lt;li&gt; tag)\n * with text of 10 words on each line<br>\n * <code>span*3>lipsum20</code> – generates 3 paragraphs of 20-words text, each wrapped with &lt;span&gt; element .\n * Each paragraph phrase is unique   \n * @param {Function} require\n * @param {Underscore} _ \n * @constructor\n * @memberOf __loremIpsumGeneratorDefine\n */\nemmet.define('lorem', function(require, _) {\n\tvar langs = {\n\t\ten: {\n\t\t\tcommon: ['lorem', 'ipsum', 'dolor', 'sit', 'amet', 'consectetur', 'adipisicing', 'elit'],\n\t\t\twords: ['exercitationem', 'perferendis', 'perspiciatis', 'laborum', 'eveniet',\n\t             'sunt', 'iure', 'nam', 'nobis', 'eum', 'cum', 'officiis', 'excepturi',\n\t             'odio', 'consectetur', 'quasi', 'aut', 'quisquam', 'vel', 'eligendi',\n\t             'itaque', 'non', 'odit', 'tempore', 'quaerat', 'dignissimos',\n\t             'facilis', 'neque', 'nihil', 'expedita', 'vitae', 'vero', 'ipsum',\n\t             'nisi', 'animi', 'cumque', 'pariatur', 'velit', 'modi', 'natus',\n\t             'iusto', 'eaque', 'sequi', 'illo', 'sed', 'ex', 'et', 'voluptatibus',\n\t             'tempora', 'veritatis', 'ratione', 'assumenda', 'incidunt', 'nostrum',\n\t             'placeat', 'aliquid', 'fuga', 'provident', 'praesentium', 'rem',\n\t             'necessitatibus', 'suscipit', 'adipisci', 'quidem', 'possimus',\n\t             'voluptas', 'debitis', 'sint', 'accusantium', 'unde', 'sapiente',\n\t             'voluptate', 'qui', 'aspernatur', 'laudantium', 'soluta', 'amet',\n\t             'quo', 'aliquam', 'saepe', 'culpa', 'libero', 'ipsa', 'dicta',\n\t             'reiciendis', 'nesciunt', 'doloribus', 'autem', 'impedit', 'minima',\n\t             'maiores', 'repudiandae', 'ipsam', 'obcaecati', 'ullam', 'enim',\n\t             'totam', 'delectus', 'ducimus', 'quis', 'voluptates', 'dolores',\n\t             'molestiae', 'harum', 'dolorem', 'quia', 'voluptatem', 'molestias',\n\t             'magni', 'distinctio', 'omnis', 'illum', 'dolorum', 'voluptatum', 'ea',\n\t             'quas', 'quam', 'corporis', 'quae', 'blanditiis', 'atque', 'deserunt',\n\t             'laboriosam', 'earum', 'consequuntur', 'hic', 'cupiditate',\n\t             'quibusdam', 'accusamus', 'ut', 'rerum', 'error', 'minus', 'eius',\n\t             'ab', 'ad', 'nemo', 'fugit', 'officia', 'at', 'in', 'id', 'quos',\n\t             'reprehenderit', 'numquam', 'iste', 'fugiat', 'sit', 'inventore',\n\t             'beatae', 'repellendus', 'magnam', 'recusandae', 'quod', 'explicabo',\n\t             'doloremque', 'aperiam', 'consequatur', 'asperiores', 'commodi',\n\t             'optio', 'dolor', 'labore', 'temporibus', 'repellat', 'veniam',\n\t             'architecto', 'est', 'esse', 'mollitia', 'nulla', 'a', 'similique',\n\t             'eos', 'alias', 'dolore', 'tenetur', 'deleniti', 'porro', 'facere',\n\t             'maxime', 'corrupti']\n\t\t},\n\t\tru: {\n\t\t\tcommon: ['далеко-далеко', 'за', 'словесными', 'горами', 'в стране', 'гласных', 'и согласных', 'живут', 'рыбные', 'тексты'],\n\t\t\twords: ['вдали', 'от всех', 'они', 'буквенных', 'домах', 'на берегу', 'семантика', \n\t\t            'большого', 'языкового', 'океана', 'маленький', 'ручеек', 'даль', \n\t\t            'журчит', 'по всей', 'обеспечивает', 'ее','всеми', 'необходимыми', \n\t\t            'правилами', 'эта', 'парадигматическая', 'страна', 'которой', 'жаренные', \n\t\t            'предложения', 'залетают', 'прямо', 'рот', 'даже', 'всемогущая', \n\t\t            'пунктуация', 'не', 'имеет', 'власти', 'над', 'рыбными', 'текстами', \n\t\t            'ведущими', 'безорфографичный', 'образ', 'жизни', 'однажды', 'одна', \n\t\t            'маленькая', 'строчка','рыбного', 'текста', 'имени', 'lorem', 'ipsum', \n\t\t            'решила', 'выйти', 'большой', 'мир', 'грамматики', 'великий', 'оксмокс', \n\t\t            'предупреждал', 'о', 'злых', 'запятых', 'диких', 'знаках', 'вопроса', \n\t\t            'коварных', 'точках', 'запятой', 'но', 'текст', 'дал', 'сбить', \n\t\t            'себя', 'толку', 'он', 'собрал', 'семь', 'своих', 'заглавных', 'букв', \n\t\t            'подпоясал', 'инициал', 'за', 'пояс', 'пустился', 'дорогу', \n\t\t            'взобравшись', 'первую', 'вершину', 'курсивных', 'гор', 'бросил', \n\t\t            'последний', 'взгляд', 'назад', 'силуэт', 'своего', 'родного', 'города', \n\t\t            'буквоград', 'заголовок', 'деревни', 'алфавит', 'подзаголовок', 'своего', \n\t\t            'переулка', 'грустный', 'реторический', 'вопрос', 'скатился', 'его', \n\t\t            'щеке', 'продолжил', 'свой', 'путь', 'дороге', 'встретил', 'рукопись', \n\t\t            'она', 'предупредила',  'моей', 'все', 'переписывается', 'несколько', \n\t\t            'раз', 'единственное', 'что', 'меня', 'осталось', 'это', 'приставка', \n\t\t            'возвращайся', 'ты', 'лучше', 'свою', 'безопасную', 'страну', 'послушавшись', \n\t\t            'рукописи', 'наш', 'продолжил', 'свой', 'путь', 'вскоре', 'ему', \n\t\t            'повстречался', 'коварный', 'составитель', 'рекламных', 'текстов', \n\t\t            'напоивший', 'языком', 'речью', 'заманивший', 'свое', 'агенство', \n\t\t            'которое', 'использовало', 'снова', 'снова', 'своих', 'проектах', \n\t\t            'если', 'переписали', 'то', 'живет', 'там', 'до', 'сих', 'пор']\n\t\t}\n\t};\n\n\tvar prefs = require('preferences');\n\tprefs.define('lorem.defaultLang', 'en');\n\n\t/**\n\t * @param {AbbreviationNode} tree\n\t * @param {Object} options\n\t */\n\trequire('abbreviationParser').addPreprocessor(function(tree, options) {\n\t\tvar re = /^(?:lorem|lipsum)([a-z]{2})?(\\d*)$/i, match;\n\t\t\n\t\t/** @param {AbbreviationNode} node */\n\t\ttree.findAll(function(node) {\n\t\t\tif (node._name && (match = node._name.match(re))) {\n\t\t\t\tvar wordCound = match[2] || 30;\n\t\t\t\tvar lang = match[1] || prefs.get('lorem.defaultLang') || 'en';\n\t\t\t\t\n\t\t\t\t// force node name resolving if node should be repeated\n\t\t\t\t// or contains attributes. In this case, node should be outputed\n\t\t\t\t// as tag, otherwise as text-only node\n\t\t\t\tnode._name = '';\n\t\t\t\tnode.data('forceNameResolving', node.isRepeating() || node.attributeList().length);\n\t\t\t\tnode.data('pasteOverwrites', true);\n\t\t\t\tnode.data('paste', function(i, content) {\n\t\t\t\t\treturn paragraph(lang, wordCound, !i);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t});\n\t\n\t/**\n\t * Returns random integer between <code>from</code> and <code>to</code> values\n\t * @param {Number} from\n\t * @param {Number} to\n\t * @returns {Number}\n\t */\n\tfunction randint(from, to) {\n\t\treturn Math.round(Math.random() * (to - from) + from);\n\t}\n\t\n\t/**\n\t * @param {Array} arr\n\t * @param {Number} count\n\t * @returns {Array}\n\t */\n\tfunction sample(arr, count) {\n\t\tvar len = arr.length;\n\t\tvar iterations = Math.min(len, count);\n\t\tvar result = [];\n\t\twhile (result.length < iterations) {\n\t\t\tvar randIx = randint(0, len - 1);\n\t\t\tif (!_.include(result, randIx))\n\t\t\t\tresult.push(randIx);\n\t\t}\n\t\t\n\t\treturn _.map(result, function(ix) {\n\t\t\treturn arr[ix];\n\t\t});\n\t}\n\t\n\tfunction choice(val) {\n\t\tif (_.isString(val))\n\t\t\treturn val.charAt(randint(0, val.length - 1));\n\t\t\n\t\treturn val[randint(0, val.length - 1)];\n\t}\n\t\n\tfunction sentence(words, end) {\n\t\tif (words.length) {\n\t\t\twords[0] = words[0].charAt(0).toUpperCase() + words[0].substring(1);\n\t\t}\n\t\t\n\t\treturn words.join(' ') + (end || choice('?!...')); // more dots that question marks\n\t}\n\t\n\t/**\n\t * Insert commas at randomly selected words. This function modifies values\n\t * inside <code>words</code> array \n\t * @param {Array} words\n\t */\n\tfunction insertCommas(words) {\n\t\tvar len = words.length;\n\t\tvar totalCommas = 0;\n\t\t\n\t\tif (len > 3 && len <= 6) {\n\t\t\ttotalCommas = randint(0, 1);\n\t\t} else if (len > 6 && len <= 12) {\n\t\t\ttotalCommas = randint(0, 2);\n\t\t} else {\n\t\t\ttotalCommas = randint(1, 4);\n\t\t}\n\n\t\t_.each(_.range(totalCommas), function(ix) {\n\t\t\tif (ix < words.length - 1) {\n\t\t\t\twords[ix] += ',';\n\t\t\t}\n\t\t});\n\t}\n\t\n\t/**\n\t * Generate a paragraph of \"Lorem ipsum\" text\n\t * @param {Number} wordCount Words count in paragraph\n\t * @param {Boolean} startWithCommon Should paragraph start with common \n\t * \"lorem ipsum\" sentence.\n\t * @returns {String}\n\t */\n\tfunction paragraph(lang, wordCount, startWithCommon) {\n\t\tvar data = langs[lang];\n\t\tif (!data) {\n\t\t\treturn '';\n\t\t}\n\n\t\tvar result = [];\n\t\tvar totalWords = 0;\n\t\tvar words;\n\t\t\n\t\twordCount = parseInt(wordCount, 10);\n\t\t\n\t\tif (startWithCommon && data.common) {\n\t\t\twords = data.common.slice(0, wordCount);\n\t\t\tif (words.length > 5)\n\t\t\t\twords[4] += ',';\n\t\t\ttotalWords += words.length;\n\t\t\tresult.push(sentence(words, '.'));\n\t\t}\n\t\t\n\t\twhile (totalWords < wordCount) {\n\t\t\twords = sample(data.words, Math.min(randint(3, 12) * randint(1, 5), wordCount - totalWords));\n\t\t\ttotalWords += words.length;\n\t\t\tinsertCommas(words);\n\t\t\tresult.push(sentence(words));\n\t\t}\n\t\t\n\t\treturn result.join(' ');\n\t}\n\n\treturn {\n\t\t/**\n\t\t * Adds new language words for Lorem Ipsum generator\n\t\t * @param {String} lang Two-letter lang definition\n\t\t * @param {Object} data Words for language. Maight be either a space-separated \n\t\t * list of words (String), Array of words or object with <code>text</code> and\n\t\t * <code>common</code> properties\n\t\t */\n\t\taddLang: function(lang, data) {\n\t\t\tif (_.isString(data)) {\n\t\t\t\tdata = {words: _.compact(data.split(' '))};\n\t\t\t} else if (_.isArray(data)) {\n\t\t\t\tdata = {words: data};\n\t\t\t}\n\n\t\t\tlangs[lang] = data;\n\t\t}\n\t}\n});/**\n * A back-end bootstrap module with commonly used methods for loading user data\n * @param {Function} require\n * @param {Underscore} _  \n */\nemmet.define('bootstrap', function(require, _) {\nvar snippets = {\n\t\"variables\": {\n\t\t\"lang\": \"en\",\n\t\t\"locale\": \"en-US\",\n\t\t\"charset\": \"UTF-8\",\n\t\t\"indentation\": \"\\t\",\n\t\t\"newline\": \"\\n\"\n\t},\n\t\n\t\"css\": {\n\t\t\"filters\": \"html\",\n\t\t\"snippets\": {\n\t\t\t\"@i\": \"@import url(|);\",\n\t\t\t\"@import\": \"@import url(|);\",\n\t\t\t\"@m\": \"@media ${1:screen} {\\n\\t|\\n}\",\n\t\t\t\"@media\": \"@media ${1:screen} {\\n\\t|\\n}\",\n\t\t\t\"@f\": \"@font-face {\\n\\tfont-family:|;\\n\\tsrc:url(|);\\n}\",\n\t\t\t\"@f+\": \"@font-face {\\n\\tfont-family: '${1:FontName}';\\n\\tsrc: url('${2:FileName}.eot');\\n\\tsrc: url('${2:FileName}.eot?#iefix') format('embedded-opentype'),\\n\\t\\t url('${2:FileName}.woff') format('woff'),\\n\\t\\t url('${2:FileName}.ttf') format('truetype'),\\n\\t\\t url('${2:FileName}.svg#${1:FontName}') format('svg');\\n\\tfont-style: ${3:normal};\\n\\tfont-weight: ${4:normal};\\n}\",\n\n\t\t\t\"@kf\": \"@-webkit-keyframes ${1:identifier} {\\n\\t${2:from} { ${3} }${6}\\n\\t${4:to} { ${5} }\\n}\\n@-o-keyframes ${1:identifier} {\\n\\t${2:from} { ${3} }${6}\\n\\t${4:to} { ${5} }\\n}\\n@-moz-keyframes ${1:identifier} {\\n\\t${2:from} { ${3} }${6}\\n\\t${4:to} { ${5} }\\n}\\n@keyframes ${1:identifier} {\\n\\t${2:from} { ${3} }${6}\\n\\t${4:to} { ${5} }\\n}\",\n\n\n\t\t\t\"anim\": \"animation:|;\",\n\t\t\t\"anim-\": \"animation:${1:name} ${2:duration} ${3:timing-function} ${4:delay} ${5:iteration-count} ${6:direction} ${7:fill-mode};\",\n\t\t\t\"animdel\": \"animation-delay:${1:time};\",\n\t\t\t\n\t\t\t\"animdir\": \"animation-direction:${1:normal};\",\n\t\t\t\"animdir:n\": \"animation-direction:normal;\",\n\t\t\t\"animdir:r\": \"animation-direction:reverse;\",\n\t\t\t\"animdir:a\": \"animation-direction:alternate;\",\n\t\t\t\"animdir:ar\": \"animation-direction:alternate-reverse;\",\n\t\t\t\n\t\t\t\"animdur\": \"animation-duration:${1:0}s;\",\n\t\t\t\n\t\t\t\"animfm\": \"animation-fill-mode:${1:both};\",\n\t\t\t\"animfm:f\": \"animation-fill-mode:forwards;\",\n\t\t\t\"animfm:b\": \"animation-fill-mode:backwards;\",\n\t\t\t\"animfm:bt\": \"animation-fill-mode:both;\",\n\t\t\t\"animfm:bh\": \"animation-fill-mode:both;\",\n\t\t\t\n\t\t\t\"animic\": \"animation-iteration-count:${1:1};\",\n\t\t\t\"animic:i\": \"animation-iteration-count:infinite;\",\n\t\t\t\n\t\t\t\"animn\": \"animation-name:${1:none};\",\n\n\t\t\t\"animps\": \"animation-play-state:${1:running};\",\n\t\t\t\"animps:p\": \"animation-play-state:paused;\",\n\t\t\t\"animps:r\": \"animation-play-state:running;\",\n\n\t\t\t\"animtf\": \"animation-timing-function:${1:linear};\",\n\t\t\t\"animtf:e\": \"animation-timing-function:ease;\",\n\t\t\t\"animtf:ei\": \"animation-timing-function:ease-in;\",\n\t\t\t\"animtf:eo\": \"animation-timing-function:ease-out;\",\n\t\t\t\"animtf:eio\": \"animation-timing-function:ease-in-out;\",\n\t\t\t\"animtf:l\": \"animation-timing-function:linear;\",\n\t\t\t\"animtf:cb\": \"animation-timing-function:cubic-bezier(${1:0.1}, ${2:0.7}, ${3:1.0}, ${3:0.1});\",\n\t\t\t\n\t\t\t\"ap\": \"appearance:${none};\",\n\n\t\t\t\"!\": \"!important\",\n\t\t\t\"pos\": \"position:${1:relative};\",\n\t\t\t\"pos:s\": \"position:static;\",\n\t\t\t\"pos:a\": \"position:absolute;\",\n\t\t\t\"pos:r\": \"position:relative;\",\n\t\t\t\"pos:f\": \"position:fixed;\",\n\t\t\t\"t\": \"top:|;\",\n\t\t\t\"t:a\": \"top:auto;\",\n\t\t\t\"r\": \"right:|;\",\n\t\t\t\"r:a\": \"right:auto;\",\n\t\t\t\"b\": \"bottom:|;\",\n\t\t\t\"b:a\": \"bottom:auto;\",\n\t\t\t\"l\": \"left:|;\",\n\t\t\t\"l:a\": \"left:auto;\",\n\t\t\t\"z\": \"z-index:|;\",\n\t\t\t\"z:a\": \"z-index:auto;\",\n\t\t\t\"fl\": \"float:${1:left};\",\n\t\t\t\"fl:n\": \"float:none;\",\n\t\t\t\"fl:l\": \"float:left;\",\n\t\t\t\"fl:r\": \"float:right;\",\n\t\t\t\"cl\": \"clear:${1:both};\",\n\t\t\t\"cl:n\": \"clear:none;\",\n\t\t\t\"cl:l\": \"clear:left;\",\n\t\t\t\"cl:r\": \"clear:right;\",\n\t\t\t\"cl:b\": \"clear:both;\",\n\n\t\t\t\"colm\": \"columns:|;\",\n\t\t\t\"colmc\": \"column-count:|;\",\n\t\t\t\"colmf\": \"column-fill:|;\",\n\t\t\t\"colmg\": \"column-gap:|;\",\n\t\t\t\"colmr\": \"column-rule:|;\",\n\t\t\t\"colmrc\": \"column-rule-color:|;\",\n\t\t\t\"colmrs\": \"column-rule-style:|;\",\n\t\t\t\"colmrw\": \"column-rule-width:|;\",\n\t\t\t\"colms\": \"column-span:|;\",\n\t\t\t\"colmw\": \"column-width:|;\",\n\n\t\t\t\"d\": \"display:${1:block};\",\n\t\t\t\"d:n\": \"display:none;\",\n\t\t\t\"d:b\": \"display:block;\",\n\t\t\t\"d:i\": \"display:inline;\",\n\t\t\t\"d:ib\": \"display:inline-block;\",\n\t\t\t\"d:ib+\": \"display: inline-block;\\n*display: inline;\\n*zoom: 1;\",\n\t\t\t\"d:li\": \"display:list-item;\",\n\t\t\t\"d:ri\": \"display:run-in;\",\n\t\t\t\"d:cp\": \"display:compact;\",\n\t\t\t\"d:tb\": \"display:table;\",\n\t\t\t\"d:itb\": \"display:inline-table;\",\n\t\t\t\"d:tbcp\": \"display:table-caption;\",\n\t\t\t\"d:tbcl\": \"display:table-column;\",\n\t\t\t\"d:tbclg\": \"display:table-column-group;\",\n\t\t\t\"d:tbhg\": \"display:table-header-group;\",\n\t\t\t\"d:tbfg\": \"display:table-footer-group;\",\n\t\t\t\"d:tbr\": \"display:table-row;\",\n\t\t\t\"d:tbrg\": \"display:table-row-group;\",\n\t\t\t\"d:tbc\": \"display:table-cell;\",\n\t\t\t\"d:rb\": \"display:ruby;\",\n\t\t\t\"d:rbb\": \"display:ruby-base;\",\n\t\t\t\"d:rbbg\": \"display:ruby-base-group;\",\n\t\t\t\"d:rbt\": \"display:ruby-text;\",\n\t\t\t\"d:rbtg\": \"display:ruby-text-group;\",\n\t\t\t\"v\": \"visibility:${1:hidden};\",\n\t\t\t\"v:v\": \"visibility:visible;\",\n\t\t\t\"v:h\": \"visibility:hidden;\",\n\t\t\t\"v:c\": \"visibility:collapse;\",\n\t\t\t\"ov\": \"overflow:${1:hidden};\",\n\t\t\t\"ov:v\": \"overflow:visible;\",\n\t\t\t\"ov:h\": \"overflow:hidden;\",\n\t\t\t\"ov:s\": \"overflow:scroll;\",\n\t\t\t\"ov:a\": \"overflow:auto;\",\n\t\t\t\"ovx\": \"overflow-x:${1:hidden};\",\n\t\t\t\"ovx:v\": \"overflow-x:visible;\",\n\t\t\t\"ovx:h\": \"overflow-x:hidden;\",\n\t\t\t\"ovx:s\": \"overflow-x:scroll;\",\n\t\t\t\"ovx:a\": \"overflow-x:auto;\",\n\t\t\t\"ovy\": \"overflow-y:${1:hidden};\",\n\t\t\t\"ovy:v\": \"overflow-y:visible;\",\n\t\t\t\"ovy:h\": \"overflow-y:hidden;\",\n\t\t\t\"ovy:s\": \"overflow-y:scroll;\",\n\t\t\t\"ovy:a\": \"overflow-y:auto;\",\n\t\t\t\"ovs\": \"overflow-style:${1:scrollbar};\",\n\t\t\t\"ovs:a\": \"overflow-style:auto;\",\n\t\t\t\"ovs:s\": \"overflow-style:scrollbar;\",\n\t\t\t\"ovs:p\": \"overflow-style:panner;\",\n\t\t\t\"ovs:m\": \"overflow-style:move;\",\n\t\t\t\"ovs:mq\": \"overflow-style:marquee;\",\n\t\t\t\"zoo\": \"zoom:1;\",\n\t\t\t\"zm\": \"zoom:1;\",\n\t\t\t\"cp\": \"clip:|;\",\n\t\t\t\"cp:a\": \"clip:auto;\",\n\t\t\t\"cp:r\": \"clip:rect(${1:top} ${2:right} ${3:bottom} ${4:left});\",\n\t\t\t\"bxz\": \"box-sizing:${1:border-box};\",\n\t\t\t\"bxz:cb\": \"box-sizing:content-box;\",\n\t\t\t\"bxz:bb\": \"box-sizing:border-box;\",\n\t\t\t\"bxsh\": \"box-shadow:${1:inset }${2:hoff} ${3:voff} ${4:blur} ${5:color};\",\n\t\t\t\"bxsh:r\": \"box-shadow:${1:inset }${2:hoff} ${3:voff} ${4:blur} ${5:spread }rgb(${6:0}, ${7:0}, ${8:0});\",\n\t\t\t\"bxsh:ra\": \"box-shadow:${1:inset }${2:h} ${3:v} ${4:blur} ${5:spread }rgba(${6:0}, ${7:0}, ${8:0}, .${9:5});\",\n\t\t\t\"bxsh:n\": \"box-shadow:none;\",\n\t\t\t\"m\": \"margin:|;\",\n\t\t\t\"m:a\": \"margin:auto;\",\n\t\t\t\"mt\": \"margin-top:|;\",\n\t\t\t\"mt:a\": \"margin-top:auto;\",\n\t\t\t\"mr\": \"margin-right:|;\",\n\t\t\t\"mr:a\": \"margin-right:auto;\",\n\t\t\t\"mb\": \"margin-bottom:|;\",\n\t\t\t\"mb:a\": \"margin-bottom:auto;\",\n\t\t\t\"ml\": \"margin-left:|;\",\n\t\t\t\"ml:a\": \"margin-left:auto;\",\n\t\t\t\"p\": \"padding:|;\",\n\t\t\t\"pt\": \"padding-top:|;\",\n\t\t\t\"pr\": \"padding-right:|;\",\n\t\t\t\"pb\": \"padding-bottom:|;\",\n\t\t\t\"pl\": \"padding-left:|;\",\n\t\t\t\"w\": \"width:|;\",\n\t\t\t\"w:a\": \"width:auto;\",\n\t\t\t\"h\": \"height:|;\",\n\t\t\t\"h:a\": \"height:auto;\",\n\t\t\t\"maw\": \"max-width:|;\",\n\t\t\t\"maw:n\": \"max-width:none;\",\n\t\t\t\"mah\": \"max-height:|;\",\n\t\t\t\"mah:n\": \"max-height:none;\",\n\t\t\t\"miw\": \"min-width:|;\",\n\t\t\t\"mih\": \"min-height:|;\",\n\t\t\t\"mar\": \"max-resolution:${1:res};\",\n\t\t\t\"mir\": \"min-resolution:${1:res};\",\n\t\t\t\"ori\": \"orientation:|;\",\n\t\t\t\"ori:l\": \"orientation:landscape;\",\n\t\t\t\"ori:p\": \"orientation:portrait;\",\n\t\t\t\"ol\": \"outline:|;\",\n\t\t\t\"ol:n\": \"outline:none;\",\n\t\t\t\"olo\": \"outline-offset:|;\",\n\t\t\t\"olw\": \"outline-width:|;\",\n\t\t\t\"olw:tn\": \"outline-width:thin;\",\n\t\t\t\"olw:m\": \"outline-width:medium;\",\n\t\t\t\"olw:tc\": \"outline-width:thick;\",\n\t\t\t\"ols\": \"outline-style:|;\",\n\t\t\t\"ols:n\": \"outline-style:none;\",\n\t\t\t\"ols:dt\": \"outline-style:dotted;\",\n\t\t\t\"ols:ds\": \"outline-style:dashed;\",\n\t\t\t\"ols:s\": \"outline-style:solid;\",\n\t\t\t\"ols:db\": \"outline-style:double;\",\n\t\t\t\"ols:g\": \"outline-style:groove;\",\n\t\t\t\"ols:r\": \"outline-style:ridge;\",\n\t\t\t\"ols:i\": \"outline-style:inset;\",\n\t\t\t\"ols:o\": \"outline-style:outset;\",\n\t\t\t\"olc\": \"outline-color:#${1:000};\",\n\t\t\t\"olc:i\": \"outline-color:invert;\",\n\t\t\t\"bd\": \"border:|;\",\n\t\t\t\"bd+\": \"border:${1:1px} ${2:solid} ${3:#000};\",\n\t\t\t\"bd:n\": \"border:none;\",\n\t\t\t\"bdbk\": \"border-break:${1:close};\",\n\t\t\t\"bdbk:c\": \"border-break:close;\",\n\t\t\t\"bdcl\": \"border-collapse:|;\",\n\t\t\t\"bdcl:c\": \"border-collapse:collapse;\",\n\t\t\t\"bdcl:s\": \"border-collapse:separate;\",\n\t\t\t\"bdc\": \"border-color:#${1:000};\",\n\t\t\t\"bdc:t\": \"border-color:transparent;\",\n\t\t\t\"bdi\": \"border-image:url(|);\",\n\t\t\t\"bdi:n\": \"border-image:none;\",\n\t\t\t\"bdti\": \"border-top-image:url(|);\",\n\t\t\t\"bdti:n\": \"border-top-image:none;\",\n\t\t\t\"bdri\": \"border-right-image:url(|);\",\n\t\t\t\"bdri:n\": \"border-right-image:none;\",\n\t\t\t\"bdbi\": \"border-bottom-image:url(|);\",\n\t\t\t\"bdbi:n\": \"border-bottom-image:none;\",\n\t\t\t\"bdli\": \"border-left-image:url(|);\",\n\t\t\t\"bdli:n\": \"border-left-image:none;\",\n\t\t\t\"bdci\": \"border-corner-image:url(|);\",\n\t\t\t\"bdci:n\": \"border-corner-image:none;\",\n\t\t\t\"bdci:c\": \"border-corner-image:continue;\",\n\t\t\t\"bdtli\": \"border-top-left-image:url(|);\",\n\t\t\t\"bdtli:n\": \"border-top-left-image:none;\",\n\t\t\t\"bdtli:c\": \"border-top-left-image:continue;\",\n\t\t\t\"bdtri\": \"border-top-right-image:url(|);\",\n\t\t\t\"bdtri:n\": \"border-top-right-image:none;\",\n\t\t\t\"bdtri:c\": \"border-top-right-image:continue;\",\n\t\t\t\"bdbri\": \"border-bottom-right-image:url(|);\",\n\t\t\t\"bdbri:n\": \"border-bottom-right-image:none;\",\n\t\t\t\"bdbri:c\": \"border-bottom-right-image:continue;\",\n\t\t\t\"bdbli\": \"border-bottom-left-image:url(|);\",\n\t\t\t\"bdbli:n\": \"border-bottom-left-image:none;\",\n\t\t\t\"bdbli:c\": \"border-bottom-left-image:continue;\",\n\t\t\t\"bdf\": \"border-fit:${1:repeat};\",\n\t\t\t\"bdf:c\": \"border-fit:clip;\",\n\t\t\t\"bdf:r\": \"border-fit:repeat;\",\n\t\t\t\"bdf:sc\": \"border-fit:scale;\",\n\t\t\t\"bdf:st\": \"border-fit:stretch;\",\n\t\t\t\"bdf:ow\": \"border-fit:overwrite;\",\n\t\t\t\"bdf:of\": \"border-fit:overflow;\",\n\t\t\t\"bdf:sp\": \"border-fit:space;\",\n\t\t\t\"bdlen\": \"border-length:|;\",\n\t\t\t\"bdlen:a\": \"border-length:auto;\",\n\t\t\t\"bdsp\": \"border-spacing:|;\",\n\t\t\t\"bds\": \"border-style:|;\",\n\t\t\t\"bds:n\": \"border-style:none;\",\n\t\t\t\"bds:h\": \"border-style:hidden;\",\n\t\t\t\"bds:dt\": \"border-style:dotted;\",\n\t\t\t\"bds:ds\": \"border-style:dashed;\",\n\t\t\t\"bds:s\": \"border-style:solid;\",\n\t\t\t\"bds:db\": \"border-style:double;\",\n\t\t\t\"bds:dtds\": \"border-style:dot-dash;\",\n\t\t\t\"bds:dtdtds\": \"border-style:dot-dot-dash;\",\n\t\t\t\"bds:w\": \"border-style:wave;\",\n\t\t\t\"bds:g\": \"border-style:groove;\",\n\t\t\t\"bds:r\": \"border-style:ridge;\",\n\t\t\t\"bds:i\": \"border-style:inset;\",\n\t\t\t\"bds:o\": \"border-style:outset;\",\n\t\t\t\"bdw\": \"border-width:|;\",\n\t\t\t\"bdtw\": \"border-top-width:|;\",\n\t\t\t\"bdrw\": \"border-right-width:|;\",\n\t\t\t\"bdbw\": \"border-bottom-width:|;\",\n\t\t\t\"bdlw\": \"border-left-width:|;\",\n\t\t\t\"bdt\": \"border-top:|;\",\n\t\t\t\"bt\": \"border-top:|;\",\n\t\t\t\"bdt+\": \"border-top:${1:1px} ${2:solid} ${3:#000};\",\n\t\t\t\"bdt:n\": \"border-top:none;\",\n\t\t\t\"bdts\": \"border-top-style:|;\",\n\t\t\t\"bdts:n\": \"border-top-style:none;\",\n\t\t\t\"bdtc\": \"border-top-color:#${1:000};\",\n\t\t\t\"bdtc:t\": \"border-top-color:transparent;\",\n\t\t\t\"bdr\": \"border-right:|;\",\n\t\t\t\"br\": \"border-right:|;\",\n\t\t\t\"bdr+\": \"border-right:${1:1px} ${2:solid} ${3:#000};\",\n\t\t\t\"bdr:n\": \"border-right:none;\",\n\t\t\t\"bdrst\": \"border-right-style:|;\",\n\t\t\t\"bdrst:n\": \"border-right-style:none;\",\n\t\t\t\"bdrc\": \"border-right-color:#${1:000};\",\n\t\t\t\"bdrc:t\": \"border-right-color:transparent;\",\n\t\t\t\"bdb\": \"border-bottom:|;\",\n\t\t\t\"bb\": \"border-bottom:|;\",\n\t\t\t\"bdb+\": \"border-bottom:${1:1px} ${2:solid} ${3:#000};\",\n\t\t\t\"bdb:n\": \"border-bottom:none;\",\n\t\t\t\"bdbs\": \"border-bottom-style:|;\",\n\t\t\t\"bdbs:n\": \"border-bottom-style:none;\",\n\t\t\t\"bdbc\": \"border-bottom-color:#${1:000};\",\n\t\t\t\"bdbc:t\": \"border-bottom-color:transparent;\",\n\t\t\t\"bdl\": \"border-left:|;\",\n\t\t\t\"bl\": \"border-left:|;\",\n\t\t\t\"bdl+\": \"border-left:${1:1px} ${2:solid} ${3:#000};\",\n\t\t\t\"bdl:n\": \"border-left:none;\",\n\t\t\t\"bdls\": \"border-left-style:|;\",\n\t\t\t\"bdls:n\": \"border-left-style:none;\",\n\t\t\t\"bdlc\": \"border-left-color:#${1:000};\",\n\t\t\t\"bdlc:t\": \"border-left-color:transparent;\",\n\t\t\t\"bdrs\": \"border-radius:|;\",\n\t\t\t\"bdtrrs\": \"border-top-right-radius:|;\",\n\t\t\t\"bdtlrs\": \"border-top-left-radius:|;\",\n\t\t\t\"bdbrrs\": \"border-bottom-right-radius:|;\",\n\t\t\t\"bdblrs\": \"border-bottom-left-radius:|;\",\n\t\t\t\"bg\": \"background:#${1:000};\",\n\t\t\t\"bg+\": \"background:${1:#fff} url(${2}) ${3:0} ${4:0} ${5:no-repeat};\",\n\t\t\t\"bg:n\": \"background:none;\",\n\t\t\t\"bg:ie\": \"filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src='${1:x}.png',sizingMethod='${2:crop}');\",\n\t\t\t\"bgc\": \"background-color:#${1:fff};\",\n\t\t\t\"bgc:t\": \"background-color:transparent;\",\n\t\t\t\"bgi\": \"background-image:url(|);\",\n\t\t\t\"bgi:n\": \"background-image:none;\",\n\t\t\t\"bgr\": \"background-repeat:|;\",\n\t\t\t\"bgr:n\": \"background-repeat:no-repeat;\",\n\t\t\t\"bgr:x\": \"background-repeat:repeat-x;\",\n\t\t\t\"bgr:y\": \"background-repeat:repeat-y;\",\n\t\t\t\"bgr:sp\": \"background-repeat:space;\",\n\t\t\t\"bgr:rd\": \"background-repeat:round;\",\n\t\t\t\"bga\": \"background-attachment:|;\",\n\t\t\t\"bga:f\": \"background-attachment:fixed;\",\n\t\t\t\"bga:s\": \"background-attachment:scroll;\",\n\t\t\t\"bgp\": \"background-position:${1:0} ${2:0};\",\n\t\t\t\"bgpx\": \"background-position-x:|;\",\n\t\t\t\"bgpy\": \"background-position-y:|;\",\n\t\t\t\"bgbk\": \"background-break:|;\",\n\t\t\t\"bgbk:bb\": \"background-break:bounding-box;\",\n\t\t\t\"bgbk:eb\": \"background-break:each-box;\",\n\t\t\t\"bgbk:c\": \"background-break:continuous;\",\n\t\t\t\"bgcp\": \"background-clip:${1:padding-box};\",\n\t\t\t\"bgcp:bb\": \"background-clip:border-box;\",\n\t\t\t\"bgcp:pb\": \"background-clip:padding-box;\",\n\t\t\t\"bgcp:cb\": \"background-clip:content-box;\",\n\t\t\t\"bgcp:nc\": \"background-clip:no-clip;\",\n\t\t\t\"bgo\": \"background-origin:|;\",\n\t\t\t\"bgo:pb\": \"background-origin:padding-box;\",\n\t\t\t\"bgo:bb\": \"background-origin:border-box;\",\n\t\t\t\"bgo:cb\": \"background-origin:content-box;\",\n\t\t\t\"bgsz\": \"background-size:|;\",\n\t\t\t\"bgsz:a\": \"background-size:auto;\",\n\t\t\t\"bgsz:ct\": \"background-size:contain;\",\n\t\t\t\"bgsz:cv\": \"background-size:cover;\",\n\t\t\t\"c\": \"color:#${1:000};\",\n\t\t\t\"c:r\": \"color:rgb(${1:0}, ${2:0}, ${3:0});\",\n\t\t\t\"c:ra\": \"color:rgba(${1:0}, ${2:0}, ${3:0}, .${4:5});\",\n\t\t\t\"cm\": \"/* |${child} */\",\n\t\t\t\"cnt\": \"content:'|';\",\n\t\t\t\"cnt:n\": \"content:normal;\",\n\t\t\t\"cnt:oq\": \"content:open-quote;\",\n\t\t\t\"cnt:noq\": \"content:no-open-quote;\",\n\t\t\t\"cnt:cq\": \"content:close-quote;\",\n\t\t\t\"cnt:ncq\": \"content:no-close-quote;\",\n\t\t\t\"cnt:a\": \"content:attr(|);\",\n\t\t\t\"cnt:c\": \"content:counter(|);\",\n\t\t\t\"cnt:cs\": \"content:counters(|);\",\n\n\n\t\t\t\"tbl\": \"table-layout:|;\",\n\t\t\t\"tbl:a\": \"table-layout:auto;\",\n\t\t\t\"tbl:f\": \"table-layout:fixed;\",\n\t\t\t\"cps\": \"caption-side:|;\",\n\t\t\t\"cps:t\": \"caption-side:top;\",\n\t\t\t\"cps:b\": \"caption-side:bottom;\",\n\t\t\t\"ec\": \"empty-cells:|;\",\n\t\t\t\"ec:s\": \"empty-cells:show;\",\n\t\t\t\"ec:h\": \"empty-cells:hide;\",\n\t\t\t\"lis\": \"list-style:|;\",\n\t\t\t\"lis:n\": \"list-style:none;\",\n\t\t\t\"lisp\": \"list-style-position:|;\",\n\t\t\t\"lisp:i\": \"list-style-position:inside;\",\n\t\t\t\"lisp:o\": \"list-style-position:outside;\",\n\t\t\t\"list\": \"list-style-type:|;\",\n\t\t\t\"list:n\": \"list-style-type:none;\",\n\t\t\t\"list:d\": \"list-style-type:disc;\",\n\t\t\t\"list:c\": \"list-style-type:circle;\",\n\t\t\t\"list:s\": \"list-style-type:square;\",\n\t\t\t\"list:dc\": \"list-style-type:decimal;\",\n\t\t\t\"list:dclz\": \"list-style-type:decimal-leading-zero;\",\n\t\t\t\"list:lr\": \"list-style-type:lower-roman;\",\n\t\t\t\"list:ur\": \"list-style-type:upper-roman;\",\n\t\t\t\"lisi\": \"list-style-image:|;\",\n\t\t\t\"lisi:n\": \"list-style-image:none;\",\n\t\t\t\"q\": \"quotes:|;\",\n\t\t\t\"q:n\": \"quotes:none;\",\n\t\t\t\"q:ru\": \"quotes:'\\\\00AB' '\\\\00BB' '\\\\201E' '\\\\201C';\",\n\t\t\t\"q:en\": \"quotes:'\\\\201C' '\\\\201D' '\\\\2018' '\\\\2019';\",\n\t\t\t\"ct\": \"content:|;\",\n\t\t\t\"ct:n\": \"content:normal;\",\n\t\t\t\"ct:oq\": \"content:open-quote;\",\n\t\t\t\"ct:noq\": \"content:no-open-quote;\",\n\t\t\t\"ct:cq\": \"content:close-quote;\",\n\t\t\t\"ct:ncq\": \"content:no-close-quote;\",\n\t\t\t\"ct:a\": \"content:attr(|);\",\n\t\t\t\"ct:c\": \"content:counter(|);\",\n\t\t\t\"ct:cs\": \"content:counters(|);\",\n\t\t\t\"coi\": \"counter-increment:|;\",\n\t\t\t\"cor\": \"counter-reset:|;\",\n\t\t\t\"va\": \"vertical-align:${1:top};\",\n\t\t\t\"va:sup\": \"vertical-align:super;\",\n\t\t\t\"va:t\": \"vertical-align:top;\",\n\t\t\t\"va:tt\": \"vertical-align:text-top;\",\n\t\t\t\"va:m\": \"vertical-align:middle;\",\n\t\t\t\"va:bl\": \"vertical-align:baseline;\",\n\t\t\t\"va:b\": \"vertical-align:bottom;\",\n\t\t\t\"va:tb\": \"vertical-align:text-bottom;\",\n\t\t\t\"va:sub\": \"vertical-align:sub;\",\n\t\t\t\"ta\": \"text-align:${1:left};\",\n\t\t\t\"ta:l\": \"text-align:left;\",\n\t\t\t\"ta:c\": \"text-align:center;\",\n\t\t\t\"ta:r\": \"text-align:right;\",\n\t\t\t\"ta:j\": \"text-align:justify;\",\n\t\t\t\"ta-lst\": \"text-align-last:|;\",\n\t\t\t\"tal:a\": \"text-align-last:auto;\",\n\t\t\t\"tal:l\": \"text-align-last:left;\",\n\t\t\t\"tal:c\": \"text-align-last:center;\",\n\t\t\t\"tal:r\": \"text-align-last:right;\",\n\t\t\t\"td\": \"text-decoration:${1:none};\",\n\t\t\t\"td:n\": \"text-decoration:none;\",\n\t\t\t\"td:u\": \"text-decoration:underline;\",\n\t\t\t\"td:o\": \"text-decoration:overline;\",\n\t\t\t\"td:l\": \"text-decoration:line-through;\",\n\t\t\t\"te\": \"text-emphasis:|;\",\n\t\t\t\"te:n\": \"text-emphasis:none;\",\n\t\t\t\"te:ac\": \"text-emphasis:accent;\",\n\t\t\t\"te:dt\": \"text-emphasis:dot;\",\n\t\t\t\"te:c\": \"text-emphasis:circle;\",\n\t\t\t\"te:ds\": \"text-emphasis:disc;\",\n\t\t\t\"te:b\": \"text-emphasis:before;\",\n\t\t\t\"te:a\": \"text-emphasis:after;\",\n\t\t\t\"th\": \"text-height:|;\",\n\t\t\t\"th:a\": \"text-height:auto;\",\n\t\t\t\"th:f\": \"text-height:font-size;\",\n\t\t\t\"th:t\": \"text-height:text-size;\",\n\t\t\t\"th:m\": \"text-height:max-size;\",\n\t\t\t\"ti\": \"text-indent:|;\",\n\t\t\t\"ti:-\": \"text-indent:-9999px;\",\n\t\t\t\"tj\": \"text-justify:|;\",\n\t\t\t\"tj:a\": \"text-justify:auto;\",\n\t\t\t\"tj:iw\": \"text-justify:inter-word;\",\n\t\t\t\"tj:ii\": \"text-justify:inter-ideograph;\",\n\t\t\t\"tj:ic\": \"text-justify:inter-cluster;\",\n\t\t\t\"tj:d\": \"text-justify:distribute;\",\n\t\t\t\"tj:k\": \"text-justify:kashida;\",\n\t\t\t\"tj:t\": \"text-justify:tibetan;\",\n\t\t\t\"tov\": \"text-overflow:${ellipsis};\",\n\t\t\t\"tov:e\": \"text-overflow:ellipsis;\",\n\t\t\t\"tov:c\": \"text-overflow:clip;\",\n\t\t\t\"to\": \"text-outline:|;\",\n\t\t\t\"to+\": \"text-outline:${1:0} ${2:0} ${3:#000};\",\n\t\t\t\"to:n\": \"text-outline:none;\",\n\t\t\t\"tr\": \"text-replace:|;\",\n\t\t\t\"tr:n\": \"text-replace:none;\",\n\t\t\t\"tt\": \"text-transform:${1:uppercase};\",\n\t\t\t\"tt:n\": \"text-transform:none;\",\n\t\t\t\"tt:c\": \"text-transform:capitalize;\",\n\t\t\t\"tt:u\": \"text-transform:uppercase;\",\n\t\t\t\"tt:l\": \"text-transform:lowercase;\",\n\t\t\t\"tw\": \"text-wrap:|;\",\n\t\t\t\"tw:n\": \"text-wrap:normal;\",\n\t\t\t\"tw:no\": \"text-wrap:none;\",\n\t\t\t\"tw:u\": \"text-wrap:unrestricted;\",\n\t\t\t\"tw:s\": \"text-wrap:suppress;\",\n\t\t\t\"tsh\": \"text-shadow:${1:hoff} ${2:voff} ${3:blur} ${4:#000};\",\n\t\t\t\"tsh:r\": \"text-shadow:${1:h} ${2:v} ${3:blur} rgb(${4:0}, ${5:0}, ${6:0});\",\n\t\t\t\"tsh:ra\": \"text-shadow:${1:h} ${2:v} ${3:blur} rgba(${4:0}, ${5:0}, ${6:0}, .${7:5});\",\n\t\t\t\"tsh+\": \"text-shadow:${1:0} ${2:0} ${3:0} ${4:#000};\",\n\t\t\t\"tsh:n\": \"text-shadow:none;\",\n\t\t\t\"trf\": \"transform:|;\",\n\t\t\t\"trf:skx\": \"transform: skewX(${1:angle});\",\n\t\t\t\"trf:sky\": \"transform: skewY(${1:angle});\",\n\t\t\t\"trf:sc\": \"transform: scale(${1:x}, ${2:y});\",\n\t\t\t\"trf:scx\": \"transform: scaleX(${1:x});\",\n\t\t\t\"trf:scy\": \"transform: scaleY(${1:y});\",\n\t\t\t\"trf:r\": \"transform: rotate(${1:angle});\",\n\t\t\t\"trf:t\": \"transform: translate(${1:x}, ${2:y});\",\n\t\t\t\"trf:tx\": \"transform: translateX(${1:x});\",\n\t\t\t\"trf:ty\": \"transform: translateY(${1:y});\",\n\t\t\t\"trfo\": \"transform-origin:|;\",\n\t\t\t\"trfs\": \"transform-style:${1:preserve-3d};\",\n\t\t\t\"trs\": \"transition:${1:prop} ${2:time};\",\n\t\t\t\"trsde\": \"transition-delay:${1:time};\",\n\t\t\t\"trsdu\": \"transition-duration:${1:time};\",\n\t\t\t\"trsp\": \"transition-property:${1:prop};\",\n\t\t\t\"trstf\": \"transition-timing-function:${1:tfunc};\",\n\t\t\t\"lh\": \"line-height:|;\",\n\t\t\t\"whs\": \"white-space:|;\",\n\t\t\t\"whs:n\": \"white-space:normal;\",\n\t\t\t\"whs:p\": \"white-space:pre;\",\n\t\t\t\"whs:nw\": \"white-space:nowrap;\",\n\t\t\t\"whs:pw\": \"white-space:pre-wrap;\",\n\t\t\t\"whs:pl\": \"white-space:pre-line;\",\n\t\t\t\"whsc\": \"white-space-collapse:|;\",\n\t\t\t\"whsc:n\": \"white-space-collapse:normal;\",\n\t\t\t\"whsc:k\": \"white-space-collapse:keep-all;\",\n\t\t\t\"whsc:l\": \"white-space-collapse:loose;\",\n\t\t\t\"whsc:bs\": \"white-space-collapse:break-strict;\",\n\t\t\t\"whsc:ba\": \"white-space-collapse:break-all;\",\n\t\t\t\"wob\": \"word-break:|;\",\n\t\t\t\"wob:n\": \"word-break:normal;\",\n\t\t\t\"wob:k\": \"word-break:keep-all;\",\n\t\t\t\"wob:ba\": \"word-break:break-all;\",\n\t\t\t\"wos\": \"word-spacing:|;\",\n\t\t\t\"wow\": \"word-wrap:|;\",\n\t\t\t\"wow:nm\": \"word-wrap:normal;\",\n\t\t\t\"wow:n\": \"word-wrap:none;\",\n\t\t\t\"wow:u\": \"word-wrap:unrestricted;\",\n\t\t\t\"wow:s\": \"word-wrap:suppress;\",\n\t\t\t\"wow:b\": \"word-wrap:break-word;\",\n\t\t\t\"wm\": \"writing-mode:${1:lr-tb};\",\n\t\t\t\"wm:lrt\": \"writing-mode:lr-tb;\",\n\t\t\t\"wm:lrb\": \"writing-mode:lr-bt;\",\n\t\t\t\"wm:rlt\": \"writing-mode:rl-tb;\",\n\t\t\t\"wm:rlb\": \"writing-mode:rl-bt;\",\n\t\t\t\"wm:tbr\": \"writing-mode:tb-rl;\",\n\t\t\t\"wm:tbl\": \"writing-mode:tb-lr;\",\n\t\t\t\"wm:btl\": \"writing-mode:bt-lr;\",\n\t\t\t\"wm:btr\": \"writing-mode:bt-rl;\",\n\t\t\t\"lts\": \"letter-spacing:|;\",\n\t\t\t\"lts-n\": \"letter-spacing:normal;\",\n\t\t\t\"f\": \"font:|;\",\n\t\t\t\"f+\": \"font:${1:1em} ${2:Arial,sans-serif};\",\n\t\t\t\"fw\": \"font-weight:|;\",\n\t\t\t\"fw:n\": \"font-weight:normal;\",\n\t\t\t\"fw:b\": \"font-weight:bold;\",\n\t\t\t\"fw:br\": \"font-weight:bolder;\",\n\t\t\t\"fw:lr\": \"font-weight:lighter;\",\n\t\t\t\"fs\": \"font-style:${italic};\",\n\t\t\t\"fs:n\": \"font-style:normal;\",\n\t\t\t\"fs:i\": \"font-style:italic;\",\n\t\t\t\"fs:o\": \"font-style:oblique;\",\n\t\t\t\"fv\": \"font-variant:|;\",\n\t\t\t\"fv:n\": \"font-variant:normal;\",\n\t\t\t\"fv:sc\": \"font-variant:small-caps;\",\n\t\t\t\"fz\": \"font-size:|;\",\n\t\t\t\"fza\": \"font-size-adjust:|;\",\n\t\t\t\"fza:n\": \"font-size-adjust:none;\",\n\t\t\t\"ff\": \"font-family:|;\",\n\t\t\t\"ff:s\": \"font-family:serif;\",\n\t\t\t\"ff:ss\": \"font-family:sans-serif;\",\n\t\t\t\"ff:c\": \"font-family:cursive;\",\n\t\t\t\"ff:f\": \"font-family:fantasy;\",\n\t\t\t\"ff:m\": \"font-family:monospace;\",\n\t\t\t\"ff:a\": \"font-family: Arial, \\\"Helvetica Neue\\\", Helvetica, sans-serif;\",\n\t\t\t\"ff:t\": \"font-family: \\\"Times New Roman\\\", Times, Baskerville, Georgia, serif;\",\n\t\t\t\"ff:v\": \"font-family: Verdana, Geneva, sans-serif;\",\n\t\t\t\"fef\": \"font-effect:|;\",\n\t\t\t\"fef:n\": \"font-effect:none;\",\n\t\t\t\"fef:eg\": \"font-effect:engrave;\",\n\t\t\t\"fef:eb\": \"font-effect:emboss;\",\n\t\t\t\"fef:o\": \"font-effect:outline;\",\n\t\t\t\"fem\": \"font-emphasize:|;\",\n\t\t\t\"femp\": \"font-emphasize-position:|;\",\n\t\t\t\"femp:b\": \"font-emphasize-position:before;\",\n\t\t\t\"femp:a\": \"font-emphasize-position:after;\",\n\t\t\t\"fems\": \"font-emphasize-style:|;\",\n\t\t\t\"fems:n\": \"font-emphasize-style:none;\",\n\t\t\t\"fems:ac\": \"font-emphasize-style:accent;\",\n\t\t\t\"fems:dt\": \"font-emphasize-style:dot;\",\n\t\t\t\"fems:c\": \"font-emphasize-style:circle;\",\n\t\t\t\"fems:ds\": \"font-emphasize-style:disc;\",\n\t\t\t\"fsm\": \"font-smooth:|;\",\n\t\t\t\"fsm:a\": \"font-smooth:auto;\",\n\t\t\t\"fsm:n\": \"font-smooth:never;\",\n\t\t\t\"fsm:aw\": \"font-smooth:always;\",\n\t\t\t\"fst\": \"font-stretch:|;\",\n\t\t\t\"fst:n\": \"font-stretch:normal;\",\n\t\t\t\"fst:uc\": \"font-stretch:ultra-condensed;\",\n\t\t\t\"fst:ec\": \"font-stretch:extra-condensed;\",\n\t\t\t\"fst:c\": \"font-stretch:condensed;\",\n\t\t\t\"fst:sc\": \"font-stretch:semi-condensed;\",\n\t\t\t\"fst:se\": \"font-stretch:semi-expanded;\",\n\t\t\t\"fst:e\": \"font-stretch:expanded;\",\n\t\t\t\"fst:ee\": \"font-stretch:extra-expanded;\",\n\t\t\t\"fst:ue\": \"font-stretch:ultra-expanded;\",\n\t\t\t\"op\": \"opacity:|;\",\n\t\t\t\"op+\": \"opacity: $1;\\nfilter: alpha(opacity=$2);\",\n\t\t\t\"op:ie\": \"filter:progid:DXImageTransform.Microsoft.Alpha(Opacity=100);\",\n\t\t\t\"op:ms\": \"-ms-filter:'progid:DXImageTransform.Microsoft.Alpha(Opacity=100)';\",\n\t\t\t\"rsz\": \"resize:|;\",\n\t\t\t\"rsz:n\": \"resize:none;\",\n\t\t\t\"rsz:b\": \"resize:both;\",\n\t\t\t\"rsz:h\": \"resize:horizontal;\",\n\t\t\t\"rsz:v\": \"resize:vertical;\",\n\t\t\t\"cur\": \"cursor:${pointer};\",\n\t\t\t\"cur:a\": \"cursor:auto;\",\n\t\t\t\"cur:d\": \"cursor:default;\",\n\t\t\t\"cur:c\": \"cursor:crosshair;\",\n\t\t\t\"cur:ha\": \"cursor:hand;\",\n\t\t\t\"cur:he\": \"cursor:help;\",\n\t\t\t\"cur:m\": \"cursor:move;\",\n\t\t\t\"cur:p\": \"cursor:pointer;\",\n\t\t\t\"cur:t\": \"cursor:text;\",\n\t\t\t\"pgbb\": \"page-break-before:|;\",\n\t\t\t\"pgbb:au\": \"page-break-before:auto;\",\n\t\t\t\"pgbb:al\": \"page-break-before:always;\",\n\t\t\t\"pgbb:l\": \"page-break-before:left;\",\n\t\t\t\"pgbb:r\": \"page-break-before:right;\",\n\t\t\t\"pgbi\": \"page-break-inside:|;\",\n\t\t\t\"pgbi:au\": \"page-break-inside:auto;\",\n\t\t\t\"pgbi:av\": \"page-break-inside:avoid;\",\n\t\t\t\"pgba\": \"page-break-after:|;\",\n\t\t\t\"pgba:au\": \"page-break-after:auto;\",\n\t\t\t\"pgba:al\": \"page-break-after:always;\",\n\t\t\t\"pgba:l\": \"page-break-after:left;\",\n\t\t\t\"pgba:r\": \"page-break-after:right;\",\n\t\t\t\"orp\": \"orphans:|;\",\n\t\t\t\"us\": \"user-select:${none};\",\n\t\t\t\"wid\": \"widows:|;\",\n\t\t\t\"wfsm\": \"-webkit-font-smoothing:${antialiased};\",\n\t\t\t\"wfsm:a\": \"-webkit-font-smoothing:antialiased;\",\n\t\t\t\"wfsm:s\": \"-webkit-font-smoothing:subpixel-antialiased;\",\n\t\t\t\"wfsm:sa\": \"-webkit-font-smoothing:subpixel-antialiased;\",\n\t\t\t\"wfsm:n\": \"-webkit-font-smoothing:none;\"\n\t\t}\n\t},\n\t\n\t\"html\": {\n\t\t\"filters\": \"html\",\n\t\t\"profile\": \"html\",\n\t\t\"snippets\": {\n\t\t\t\"!!!\":    \"<!doctype html>\",\n\t\t\t\"!!!4t\":  \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.01 Transitional//EN\\\" \\\"http://www.w3.org/TR/html4/loose.dtd\\\">\",\n\t\t\t\"!!!4s\":  \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.01//EN\\\" \\\"http://www.w3.org/TR/html4/strict.dtd\\\">\",\n\t\t\t\"!!!xt\":  \"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\" \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\",\n\t\t\t\"!!!xs\":  \"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Strict//EN\\\" \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\\\">\",\n\t\t\t\"!!!xxs\": \"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.1//EN\\\" \\\"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\\\">\",\n\n\t\t\t\"c\": \"<!-- |${child} -->\",\n\t\t\t\"cc:ie6\": \"<!--[if lte IE 6]>\\n\\t${child}|\\n<![endif]-->\",\n\t\t\t\"cc:ie\": \"<!--[if IE]>\\n\\t${child}|\\n<![endif]-->\",\n\t\t\t\"cc:noie\": \"<!--[if !IE]><!-->\\n\\t${child}|\\n<!--<![endif]-->\"\n\t\t},\n\t\t\n\t\t\"abbreviations\": {\n\t\t\t\"!\": \"html:5\",\n\t\t\t\"a\": \"<a href=\\\"\\\">\",\n\t\t\t\"a:link\": \"<a href=\\\"http://|\\\">\",\n\t\t\t\"a:mail\": \"<a href=\\\"mailto:|\\\">\",\n\t\t\t\"abbr\": \"<abbr title=\\\"\\\">\",\n\t\t\t\"acronym\": \"<acronym title=\\\"\\\">\",\n\t\t\t\"base\": \"<base href=\\\"\\\" />\",\n\t\t\t\"basefont\": \"<basefont/>\",\n\t\t\t\"br\": \"<br/>\",\n\t\t\t\"frame\": \"<frame/>\",\n\t\t\t\"hr\": \"<hr/>\",\n\t\t\t\"bdo\": \"<bdo dir=\\\"\\\">\",\n\t\t\t\"bdo:r\": \"<bdo dir=\\\"rtl\\\">\",\n\t\t\t\"bdo:l\": \"<bdo dir=\\\"ltr\\\">\",\n\t\t\t\"col\": \"<col/>\",\n\t\t\t\"link\": \"<link rel=\\\"stylesheet\\\" href=\\\"\\\" />\",\n\t\t\t\"link:css\": \"<link rel=\\\"stylesheet\\\" href=\\\"${1:style}.css\\\" />\",\n\t\t\t\"link:print\": \"<link rel=\\\"stylesheet\\\" href=\\\"${1:print}.css\\\" media=\\\"print\\\" />\",\n\t\t\t\"link:favicon\": \"<link rel=\\\"shortcut icon\\\" type=\\\"image/x-icon\\\" href=\\\"${1:favicon.ico}\\\" />\",\n\t\t\t\"link:touch\": \"<link rel=\\\"apple-touch-icon\\\" href=\\\"${1:favicon.png}\\\" />\",\n\t\t\t\"link:rss\": \"<link rel=\\\"alternate\\\" type=\\\"application/rss+xml\\\" title=\\\"RSS\\\" href=\\\"${1:rss.xml}\\\" />\",\n\t\t\t\"link:atom\": \"<link rel=\\\"alternate\\\" type=\\\"application/atom+xml\\\" title=\\\"Atom\\\" href=\\\"${1:atom.xml}\\\" />\",\n\t\t\t\"meta\": \"<meta/>\",\n\t\t\t\"meta:utf\": \"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html;charset=UTF-8\\\" />\",\n\t\t\t\"meta:win\": \"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html;charset=windows-1251\\\" />\",\n\t\t\t\"meta:vp\": \"<meta name=\\\"viewport\\\" content=\\\"width=${1:device-width}, user-scalable=${2:no}, initial-scale=${3:1.0}, maximum-scale=${4:1.0}, minimum-scale=${5:1.0}\\\" />\",\n\t\t\t\"meta:compat\": \"<meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"${1:IE=7}\\\" />\",\n\t\t\t\"style\": \"<style>\",\n\t\t\t\"script\": \"<script>\",\n\t\t\t\"script:src\": \"<script src=\\\"\\\">\",\n\t\t\t\"img\": \"<img src=\\\"\\\" alt=\\\"\\\" />\",\n\t\t\t\"iframe\": \"<iframe src=\\\"\\\" frameborder=\\\"0\\\">\",\n\t\t\t\"embed\": \"<embed src=\\\"\\\" type=\\\"\\\" />\",\n\t\t\t\"object\": \"<object data=\\\"\\\" type=\\\"\\\">\",\n\t\t\t\"param\": \"<param name=\\\"\\\" value=\\\"\\\" />\",\n\t\t\t\"map\": \"<map name=\\\"\\\">\",\n\t\t\t\"area\": \"<area shape=\\\"\\\" coords=\\\"\\\" href=\\\"\\\" alt=\\\"\\\" />\",\n\t\t\t\"area:d\": \"<area shape=\\\"default\\\" href=\\\"\\\" alt=\\\"\\\" />\",\n\t\t\t\"area:c\": \"<area shape=\\\"circle\\\" coords=\\\"\\\" href=\\\"\\\" alt=\\\"\\\" />\",\n\t\t\t\"area:r\": \"<area shape=\\\"rect\\\" coords=\\\"\\\" href=\\\"\\\" alt=\\\"\\\" />\",\n\t\t\t\"area:p\": \"<area shape=\\\"poly\\\" coords=\\\"\\\" href=\\\"\\\" alt=\\\"\\\" />\",\n\t\t\t\"form\": \"<form action=\\\"\\\">\",\n\t\t\t\"form:get\": \"<form action=\\\"\\\" method=\\\"get\\\">\",\n\t\t\t\"form:post\": \"<form action=\\\"\\\" method=\\\"post\\\">\",\n\t\t\t\"label\": \"<label for=\\\"\\\">\",\n\t\t\t\"input\": \"<input type=\\\"${1:text}\\\" />\",\n\t\t\t\"inp\": \"<input type=\\\"${1:text}\\\" name=\\\"\\\" id=\\\"\\\" />\",\n\t\t\t\"input:hidden\": \"input[type=hidden name]\",\n\t\t\t\"input:h\": \"input:hidden\",\n\t\t\t\"input:text\": \"inp\",\n\t\t\t\"input:t\": \"inp\",\n\t\t\t\"input:search\": \"inp[type=search]\",\n\t\t\t\"input:email\": \"inp[type=email]\",\n\t\t\t\"input:url\": \"inp[type=url]\",\n\t\t\t\"input:password\": \"inp[type=password]\",\n\t\t\t\"input:p\": \"input:password\",\n\t\t\t\"input:datetime\": \"inp[type=datetime]\",\n\t\t\t\"input:date\": \"inp[type=date]\",\n\t\t\t\"input:datetime-local\": \"inp[type=datetime-local]\",\n\t\t\t\"input:month\": \"inp[type=month]\",\n\t\t\t\"input:week\": \"inp[type=week]\",\n\t\t\t\"input:time\": \"inp[type=time]\",\n\t\t\t\"input:number\": \"inp[type=number]\",\n\t\t\t\"input:color\": \"inp[type=color]\",\n\t\t\t\"input:checkbox\": \"inp[type=checkbox]\",\n\t\t\t\"input:c\": \"input:checkbox\",\n\t\t\t\"input:radio\": \"inp[type=radio]\",\n\t\t\t\"input:r\": \"input:radio\",\n\t\t\t\"input:range\": \"inp[type=range]\",\n\t\t\t\"input:file\": \"inp[type=file]\",\n\t\t\t\"input:f\": \"input:file\",\n\t\t\t\"input:submit\": \"<input type=\\\"submit\\\" value=\\\"\\\" />\",\n\t\t\t\"input:s\": \"input:submit\",\n\t\t\t\"input:image\": \"<input type=\\\"image\\\" src=\\\"\\\" alt=\\\"\\\" />\",\n\t\t\t\"input:i\": \"input:image\",\n\t\t\t\"input:button\": \"<input type=\\\"button\\\" value=\\\"\\\" />\",\n\t\t\t\"input:b\": \"input:button\",\n\t\t\t\"isindex\": \"<isindex/>\",\n\t\t\t\"input:reset\": \"input:button[type=reset]\",\n\t\t\t\"select\": \"<select name=\\\"\\\" id=\\\"\\\">\",\n\t\t\t\"select:disabled\": \"select[disabled]\",\n\t\t\t\"select:d\": \"select[disabled]\",\n\t\t\t\"option\": \"<option value=\\\"\\\">\",\n\t\t\t\"textarea\": \"<textarea name=\\\"\\\" id=\\\"\\\" cols=\\\"${1:30}\\\" rows=\\\"${2:10}\\\">\",\n\t\t\t\"marquee\": \"<marquee behavior=\\\"\\\" direction=\\\"\\\">\",\n\t\t\t\"menu:context\": \"menu[type=context]>\",\n\t\t\t\"menu:c\": \"menu:context\",\n\t\t\t\"menu:toolbar\": \"menu[type=toolbar]>\",\n\t\t\t\"menu:t\": \"menu:toolbar\",\n\t\t\t\"video\": \"<video src=\\\"\\\">\",\n\t\t\t\"audio\": \"<audio src=\\\"\\\">\",\n\t\t\t\"html:xml\": \"<html xmlns=\\\"http://www.w3.org/1999/xhtml\\\">\",\n\t\t\t\"keygen\": \"<keygen/>\",\n\t\t\t\"command\": \"<command/>\",\n\t\t\t\"button:submit\" : \"button[type=submit]\",\n\t\t\t\"button:s\" : \"button[type=submit]\",\n\t\t\t\"button:reset\" : \"button[type=reset]\",\n\t\t\t\"button:r\" : \"button[type=reset]\",\n\t\t\t\"button:disabled\" : \"button[disabled]\",\n\t\t\t\"button:d\" : \"button[disabled]\",\n\t\t\t\"fieldset:disabled\" : \"fieldset[disabled]\",\n\t\t\t\"fieldset:d\" : \"fieldset[disabled]\",\n\t\t\t\n\t\t\t\"bq\": \"blockquote\",\n\t\t\t\"acr\": \"acronym\",\n\t\t\t\"fig\": \"figure\",\n\t\t\t\"figc\": \"figcaption\",\n\t\t\t\"ifr\": \"iframe\",\n\t\t\t\"emb\": \"embed\",\n\t\t\t\"obj\": \"object\",\n\t\t\t\"src\": \"source\",\n\t\t\t\"cap\": \"caption\",\n\t\t\t\"colg\": \"colgroup\",\n\t\t\t\"fst\": \"fieldset\",\n\t\t\t\"fst:d\": \"fieldset[disabled]\",\n\t\t\t\"btn\": \"button\",\n\t\t\t\"btn:b\": \"button[type=button]\",\n\t\t\t\"btn:r\": \"button[type=reset]\",\n\t\t\t\"btn:s\": \"button[type=submit]\",\n\t\t\t\"btn:d\": \"button[disabled]\",\n\t\t\t\"optg\": \"optgroup\",\n\t\t\t\"opt\": \"option\",\n\t\t\t\"tarea\": \"textarea\",\n\t\t\t\"leg\": \"legend\",\n\t\t\t\"sect\": \"section\",\n\t\t\t\"art\": \"article\",\n\t\t\t\"hdr\": \"header\",\n\t\t\t\"ftr\": \"footer\",\n\t\t\t\"adr\": \"address\",\n\t\t\t\"dlg\": \"dialog\",\n\t\t\t\"str\": \"strong\",\n\t\t\t\"prog\": \"progress\",\n\t\t\t\"fset\": \"fieldset\",\n\t\t\t\"fset:d\": \"fieldset[disabled]\",\n\t\t\t\"datag\": \"datagrid\",\n\t\t\t\"datal\": \"datalist\",\n\t\t\t\"kg\": \"keygen\",\n\t\t\t\"out\": \"output\",\n\t\t\t\"det\": \"details\",\n\t\t\t\"cmd\": \"command\",\n\t\t\t\"doc\": \"html>(head>meta[charset=UTF-8]+title{${1:Document}})+body\",\n\t\t\t\"doc4\": \"html>(head>meta[http-equiv=\\\"Content-Type\\\" content=\\\"text/html;charset=${charset}\\\"]+title{${1:Document}})+body\",\n\n\t\t\t\"html:4t\":  \"!!!4t+doc4[lang=${lang}]\",\n\t\t\t\"html:4s\":  \"!!!4s+doc4[lang=${lang}]\",\n\t\t\t\"html:xt\":  \"!!!xt+doc4[xmlns=http://www.w3.org/1999/xhtml xml:lang=${lang}]\",\n\t\t\t\"html:xs\":  \"!!!xs+doc4[xmlns=http://www.w3.org/1999/xhtml xml:lang=${lang}]\",\n\t\t\t\"html:xxs\": \"!!!xxs+doc4[xmlns=http://www.w3.org/1999/xhtml xml:lang=${lang}]\",\n\t\t\t\"html:5\":   \"!!!+doc[lang=${lang}]\",\n\t\t\t\n\t\t\t\"ol+\": \"ol>li\",\n\t\t\t\"ul+\": \"ul>li\",\n\t\t\t\"dl+\": \"dl>dt+dd\",\n\t\t\t\"map+\": \"map>area\",\n\t\t\t\"table+\": \"table>tr>td\",\n\t\t\t\"colgroup+\": \"colgroup>col\",\n\t\t\t\"colg+\": \"colgroup>col\",\n\t\t\t\"tr+\": \"tr>td\",\n\t\t\t\"select+\": \"select>option\",\n\t\t\t\"optgroup+\": \"optgroup>option\",\n\t\t\t\"optg+\": \"optgroup>option\"\n\t\t}\n\t},\n\t\n\t\"xml\": {\n\t\t\"extends\": \"html\",\n\t\t\"profile\": \"xml\",\n\t\t\"filters\": \"html\"\n\t},\n\t\n\t\"xsl\": {\n\t\t\"extends\": \"html\",\n\t\t\"profile\": \"xml\",\n\t\t\"filters\": \"html, xsl\",\n\t\t\"abbreviations\": {\n\t\t\t\"tm\": \"<xsl:template match=\\\"\\\" mode=\\\"\\\">\",\n\t\t\t\"tmatch\": \"tm\",\n\t\t\t\"tn\": \"<xsl:template name=\\\"\\\">\",\n\t\t\t\"tname\": \"tn\",\n\t\t\t\"call\": \"<xsl:call-template name=\\\"\\\"/>\",\n\t\t\t\"ap\": \"<xsl:apply-templates select=\\\"\\\" mode=\\\"\\\"/>\",\n\t\t\t\"api\": \"<xsl:apply-imports/>\",\n\t\t\t\"imp\": \"<xsl:import href=\\\"\\\"/>\",\n\t\t\t\"inc\": \"<xsl:include href=\\\"\\\"/>\",\n\n\t\t\t\"ch\": \"<xsl:choose>\",\n\t\t\t\"xsl:when\": \"<xsl:when test=\\\"\\\">\",\n\t\t\t\"wh\": \"xsl:when\",\n\t\t\t\"ot\": \"<xsl:otherwise>\",\n\t\t\t\"if\": \"<xsl:if test=\\\"\\\">\",\n\n\t\t\t\"par\": \"<xsl:param name=\\\"\\\">\",\n\t\t\t\"pare\": \"<xsl:param name=\\\"\\\" select=\\\"\\\"/>\",\n\t\t\t\"var\": \"<xsl:variable name=\\\"\\\">\",\n\t\t\t\"vare\": \"<xsl:variable name=\\\"\\\" select=\\\"\\\"/>\",\n\t\t\t\"wp\": \"<xsl:with-param name=\\\"\\\" select=\\\"\\\"/>\",\n\t\t\t\"key\": \"<xsl:key name=\\\"\\\" match=\\\"\\\" use=\\\"\\\"/>\",\n\n\t\t\t\"elem\": \"<xsl:element name=\\\"\\\">\",\n\t\t\t\"attr\": \"<xsl:attribute name=\\\"\\\">\",\n\t\t\t\"attrs\": \"<xsl:attribute-set name=\\\"\\\">\",\n\n\t\t\t\"cp\": \"<xsl:copy select=\\\"\\\"/>\",\n\t\t\t\"co\": \"<xsl:copy-of select=\\\"\\\"/>\",\n\t\t\t\"val\": \"<xsl:value-of select=\\\"\\\"/>\",\n\t\t\t\"each\": \"<xsl:for-each select=\\\"\\\">\",\n\t\t\t\"for\": \"each\",\n\t\t\t\"tex\": \"<xsl:text></xsl:text>\",\n\n\t\t\t\"com\": \"<xsl:comment>\",\n\t\t\t\"msg\": \"<xsl:message terminate=\\\"no\\\">\",\n\t\t\t\"fall\": \"<xsl:fallback>\",\n\t\t\t\"num\": \"<xsl:number value=\\\"\\\"/>\",\n\t\t\t\"nam\": \"<namespace-alias stylesheet-prefix=\\\"\\\" result-prefix=\\\"\\\"/>\",\n\t\t\t\"pres\": \"<xsl:preserve-space elements=\\\"\\\"/>\",\n\t\t\t\"strip\": \"<xsl:strip-space elements=\\\"\\\"/>\",\n\t\t\t\"proc\": \"<xsl:processing-instruction name=\\\"\\\">\",\n\t\t\t\"sort\": \"<xsl:sort select=\\\"\\\" order=\\\"\\\"/>\",\n\n\t\t\t\"choose+\": \"xsl:choose>xsl:when+xsl:otherwise\",\n\t\t\t\"xsl\": \"!!!+xsl:stylesheet[version=1.0 xmlns:xsl=http://www.w3.org/1999/XSL/Transform]>{\\n|}\"\n\t\t}, \n\t\t\"snippets\": {\n\t\t\t\"!!!\": \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\"\n\t\t}\n\t},\n\t\n\t\"haml\": {\n\t\t\"filters\": \"haml\",\n\t\t\"extends\": \"html\",\n\t\t\"profile\": \"xml\"\n\t},\n\t\n\t\"scss\": {\n\t\t\"extends\": \"css\"\n\t},\n\t\n\t\"sass\": {\n\t\t\"extends\": \"css\"\n\t},\n\t\n\t\"less\": {\n\t\t\"extends\": \"css\"\n\t},\n\t\n\t\"stylus\": {\n\t\t\"extends\": \"css\"\n\t},\n\n\t\"styl\": {\n\t\t\"extends\": \"stylus\"\n\t}\n}\n;\nvar res = require('resources');\nvar userData = res.getVocabulary('user') || {};\nres.setVocabulary(require('utils').deepMerge(userData, snippets), 'user');\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/emmet/emmet.js\n// module id = 187\n// module chunks = 29"],"sourceRoot":""}